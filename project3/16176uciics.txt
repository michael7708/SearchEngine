fibonacci numbers 
sequential binary search 
ics
161
design
analysis
algorithms
lecture
notes
january
11
1996
sequential
binary
search
example
looking
topic
baase
suppose
tuesday's
application
matrix
multiplication
fibonacci
numbers
wanted
know
says
matrix
multiplication
look
index
will
give
many
different
pages
look
somewhat
relevant
read
table
contents
find
relevant
looking
titles
6
2
7
3
sequential
search
second
method
reading
table
contents
example
sequential
search
similar
sorts
problems
show
time
programming
operating
systems
look
file
names
directory
unix
system
usually
sequential
search
abstractly
sequential
search
list
item
item
list
matches
return
return
match
many
variants
stop
found
one
match
keep
going
found
represent
list
using
pointers
linked
lists
indicate
match
want
analyse
really
understand
running
time
know
quick
matches
part
everything
else
straightforward
way
written
pseudocode
part
still
needs
filled
can
still
analyse
algorithm
just
measure
time
terms
number
comparisons
examples
8
appear
list
first
10
fib
numbers
9
note
9
algorithm
go
whole
list
time
seems
depend
want
able
predict
time
easily
without
running
algorithm
saying
comparisons
position
true
informative
methods
analysis
able
predict
time
without
look
details
input
measure
function
length
input
basically
constant
length
depending
item
length
just
number
items
given
list
items
many
comparisons
algorithm
take
answer
depends
want
answer
depend
various
ways
getting
one
combining
times
different
inputs
length
worst
case
analysis
comparisons
ever
see
matter
perverse
input
time
wc
max
time
input
size
best
case
analysis
fewest
comparisons
algorithm
take
input
well
behaved
time
wc
min
time
input
size
average
case
analysis
much
time
algorithm
take
typical
input
assume
input
size
probability
actual
input
use
proabilities
find
weighted
average
time
avg
sum
time
distinctions
make
sense
fibonacci
numbers
time
always
function
can
give
different
answers
see
sequential
search
average
case
probably
important
general
problematic
terms
typical
input
make
assumption
probabilities
analysis
will
accurate
validity
assumptions
also
note
possible
algorithm
input
takes
average
time
takes
either
1
step
100
steps
average
may
around
50
even
though
input
actually
takes
50
steps
worst
case
usually
easier
average
case
analysis
useful
can
guarantee
algorithm
will
ever
take
longer
worst
case
bound
also
true
average
case
worst
case
matter
probabilities
choose
can
use
worst
case
analysis
get
information
average
case
without
make
assumptions
typical
input
looks
like
best
case
fun
useful
analysis
sequential
search
best
case
sequential
search
one
comparison
matches
right
away
worst
case
sequential
search
comparisons
either
matches
last
item
list
match
anything
average
case
harder
know
number
comparisons
position
list
typical
position
one
reasonable
assumption
list
equally
likely
anywhere
pos
1
average
number
comparisons
1
sum
1
1
sum
1
1
2
list
number
comparisons
always
finding
something
takes
half
long
finding
average
definition
typical
can
define
stronger
version
typical
suppose
list
permutation
list
equally
likely
can
average
possible
permutations
average
number
comparisons
1
sum
position
permutation
1
1
sum
number
permutations
position
1
1
sum
1
1
1
sum
1
1
2
assumption
ends
giving
analysis
second
point
made
average
case
analysis
sometimes
makes
sense
analyse
different
cases
separately
analysis
assumes
always
list
list
always
get
comparisons
make
probability
list
combine
two
numbers
get
total
average
number
comparisons
equal
pn
1
1
2
makes
sense
just
report
numbers
separately
randomized
algorithms
sometimes
useful
pay
little
bit
reduce
uncertainty
world
insurance
know
pay
fixed
amount
instead
either
paying
nothing
stay
healthy
lot
get
appendicitis
concept
applies
computer
programs
worst
case
much
larger
average
case
might
prefer
slightly
complicated
program
reduces
worst
case
long
increase
average
case
much
instance
programming
computer
controlling
car
want
tell
crash
activate
air
bags
want
running
algorithm
usually
takes
half
second
maybe
sometimes
takes
much
five
minutes
random
numbers
useful
respect
also
useful
making
average
case
analysis
apply
even
input
random
know
good
definition
typical
input
idea
scramble
input
looks
typical
say
algorithm
randomized
uses
random
numbers
algorithm
randomized
called
deterministic
expected
time
analysis
random
algorithm
measured
terms
time
input
sequence
random
numbers
particular
input
expected
time
algorithm
just
average
different
sequences
random
numbers
sum
prob
time
random
sequence
expected
time
algorithm
worst
case
inputs
length
computed
combining
formula
previous
formula
worst
case
analysis
max
sum
prob
time
input
size
random
sequence
looks
complicated
usually
much
harder
average
case
analysis
sequential
search
want
scramble
position
random
idea
pick
random
permutation
sequential
search
randomized
search
list
item
randomly
permute
item
matches
return
return
match
slows
algorithm
somewhat
take
time
permutation
may
speed
searching
part
just
searching
number
list
numbers
pretty
bad
method
time
random
permutation
probably
worst
case
original
deterministic
sequential
search
algorithm
however
comparisons
slow
much
slower
steps
algorithm
total
number
comparisons
will
dominate
overall
time
algorithm
improvement
plug
algorithm
formula
expected
times
time
max
sum
permutation
probability
time
note
permutations
1
given
position
time
max
sum
sum
prob
perm
time
l'
perm
pos
max
sum
perms
pos
1
max
sum
1
max
sum
1
2
number
comparisons
exactly
average
case
now
matter
list
see
idea
using
random
permutation
avoid
worst
case
later
quicksort
quickselect
algorithms
algorithms
use
randomization
decreases
running
time
enormously
2
log
also
sometimes
possible
make
stronger
forms
analysis
random
algorithms
just
expected
time
instance
compute
variance
running
time
prove
statements
high
probability
algorithm
uses
time
close
expectation
important
one
wants
sure
slow
possibilities
rare
usually
much
complicated
much
sort
analysis
class
binary
search
go
back
original
example
finding
matrix
multiplication
baase
talked
looking
table
contents
sequential
search
also
looking
index
index
baase
books
useful
property
alphabetized
can
smarter
search
instance
stop
sequential
search
whenever
found
speed
time
can
much
better
basically
people
alphabetized
lists
binary
search
let
length
2
0
return
match
else
matches
return
else
binary
search
1
1
else
binary
search
1
recursion
really
necessary
alternate
search
let
length
let
1
2
match
1
else
1
return
match
return
analysis
1
2
log
precisely
worst
case
2
ceiling
1
2
solves
approximately
2
log
logarithm
base
2
binary
search
fast
order
use
need
somehow
get
list
sorted
order
problem
known
sorting
see
much
detail
next
week
ics
161
dept
information
computer
science
uc
irvine
last
update
02
may
2000
20
17
36
pdt
