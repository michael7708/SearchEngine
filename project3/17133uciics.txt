ics 142 winter 2004 iloc examples 
commented iloc examples 
ics
142
winter
2004
news
course
reference
schedule
lab
manual
ics
142
newsgroup
alex
ics
142
winter
2004
iloc
examples
examples
iloc
examples
intermediate
code
generation
lecture
friday
march
12
examples
will
legal
assignment
6
since
condition
code
based
approach
conditional
branching
using
comp
cbr
instructions
supported
assignment
6
since
used
registers
descriptive
names
like
result
instead
made
separate
bundle
examples
can
actually
use
assignment
6
along
output
solution
examples
use
assignment
6
boolean
expressions
suppose
first
want
emit
intermediate
code
implements
boolean
expression
examples
boolean
expression
will
assume
already
reside
registers
one
approach
implementing
boolean
expressions
numerical
encoding
stores
value
subexpression
register
uses
logical
instructions
compute
value
entire
expression
using
condition
code
based
approach
intermediate
code
look
something
like
comp
rx
ry
cc1
compare
setting
condition
code
register
cc1
result
cbr
lt
cc1
l1
l2
last
comparison
set
less
flag
condition
code
register
branch
l1
else
branch
l2
l1
loadi
true
r1
store
true
r1
jumpi
l3
skip
assignment
false
r1
l2
loadi
false
r1
store
false
r1
jumpi
l3
always
kind
jump
end
basic
block
blocks
can
safely
reordered
l3
comp
rz
rw
cc2
now
compare
cbr
lt
cc2
l4
l5
branch
l4
else
branch
l5
l4
loadi
true
r2
store
true
r2
jumpi
l6
skip
assignment
false
r2
l5
loadi
false
r2
store
false
r2
jumpi
l6
l6
r1
r2
result
now
r1
r2
results
two
relational
comparisons
can
results
together
store
final
result
result
two
downsides
approach
two
conditional
branches
always
executed
storing
values
r1
r2
really
unnecessary
condition
code
approach
can
better
using
positional
encoding
uses
position
code
indicate
value
subexpressions
comp
rx
ry
cc1
compare
cbr
lt
cc1
l1
l2
branch
l1
else
branch
l2
l1
comp
rz
rw
cc2
point
know
store
value
r1
just
proceed
immediately
next
comparison
instead
cbr
lt
cc2
l3
l2
branch
l3
will
set
final
result
true
else
branch
l2
will
set
final
result
false
l2
loadi
false
result
two
ways
get
cases
know
overall
answer
false
jumpi
l4
l3
loadi
true
result
get
know
overall
answer
true
jumpi
l4
l4
point
result
contains
result
entire
expression
given
condition
code
approach
comparisons
great
improvement
short
circuiting
now
taking
place
eliminates
one
conditional
branches
short
circuited
case
also
useless
loads
immediate
true
false
temporary
registers
now
eliminated
well
still
boolean
comparison
instructions
stored
true
false
result
register
instead
implementation
greatly
simplified
used
numerical
encoding
cmp
lt
rx
ry
r1
store
true
r1
else
store
false
r1
cmp
lt
rz
rw
r2
store
true
r2
else
store
false
r2
r1
r2
result
now
results
subexpressions
sitting
r1
r2
can
simply
together
store
result
result
dramatic
improvement
since
branching
required
keep
pipelined
machine
much
happier
noted
version
short
circuited
order
implement
short
circuiting
approach
actually
slow
code
check
r1's
result
conditionally
branching
based
perhaps
going
positional
encoding
approach
instead
moral
story
short
circuited
operations
always
better
end
loops
also
discussed
intermediate
code
generation
loops
example
loop
int
1
loop
body
good
intermediate
code
pattern
loop
looks
like
loadi
1
ri
ri
will
store
value
throughout
loop
initialize
1
loadi
10
r1
since
comparison
instructions
iloc
take
constant
operands
need
store
upper
bound
10
register
good
code
generator
will
get
rid
register
target
machine's
instruction
set
instruction
compares
register
immediate
constant
cmp
le
ri
r1
r2
compare
upper
bound
loop
store
result
r2
cbr
r2
l1
l2
loop
body
intermediate
code
loop
body
appear
addi
ri
1
ri
cmp
le
ri
r1
r3
compare
upper
bound
loop
store
result
r3
cbr
r3
l1
l2
reasons
pattern
good
one
intermediate
code
loop
iteration
may
fit
one
basic
block
course
loop
body
may
control
flow
require
one
loop
body
simple
loop
iteration
will
consist
one
basic
block
keeping
pipeline
happy
also
enabling
local
optimization
effect
entire
loop
rather
just
piece
separately
testing
initial
loop
condition
subsequent
ones
allows
us
perform
separate
optimization
case
loop
like
one
constant
boundaries
uncommon
real
programs
allow
us
optimize
away
initial
comparison
can
proven
compile
time
loop's
body
will
never
execute
entire
loop
can
optimized
away
altogether
