nisc toolset faq 
nisc toolset faq 
nisc
toolset
frequently
asked
questions
nisc
design
methodologies
can
nisc
toolset
use
nisc
toolset
inputs
outputs
tools
input
application
language
use
describe
application
limitation
language
size
limitation
application
can
write
assembly
can
include
standard
libraries
code
can
configure
nisctoolset
use
different
versions
microsoft
visual
studio
architecture
component
description
format
format
architecture
described
format
library
components
described
can
add
custom
functional
unit
nisc
library
can
add
functional
unit
nisc
datapath
outputs
supported
platforms
know
output
rtl
code
difference
generic
verilog
output
xilinx
specific
verilog
output
can
synthesize
output
verilog
code
asic
style
output
verilog
codes
expect
simulating
verilog
code
support
vhdl
architecture
components
features
compiler
support
multi
cycle
units
compiler
support
pipelined
units
nisc
toolset
support
cache
can
make
nisc
programmable
can
reprogram
implementation
can
reduce
code
size
can
reuse
pre
designed
nisc
ip
new
application
validation
verification
validate
nisc
ip
system
design
integration
design
system
multiple
niscs
design
interface
two
niscs
write
driver
code
communicate
two
niscs
can
design
nisc
handles
external
interrupts
can
design
nisc
communicates
bus
possible
multiple
communication
interfaces
network
topologies
implemented
using
nisc
performance
improvement
techniques
techniques
can
used
improve
performance
nsic
ips
power
optimizations
nisc
toolset
reduce
power
consumption
ip
comparison
approaches
compare
nisc
high
level
synthesis
hls
compare
nisc
custom
processor
designs
online
tool
can
use
online
tool
actual
design
nisc
design
methodologies
can
nisc
toolset
can
use
nisc
toolset
two
purposes
1
synthesizing
hdl
verilog
2
designing
custom
embedded
processors
nisc
toolset
comes
retargetable
compiler
can
compile
application
given
datapath
nisc
toolset
can
also
used
fast
exploration
scenarios
use
nisc
toolset
can
download
install
nisc
toolset
local
machine
can
run
nisc
free
online
verilog
tool
inputs
outputs
tools
inputs
outputs
depend
selected
methodology
using
tool
hdl
synthesis
tool
inputs
application
code
well
design
constraints
using
tool
custom
processor
design
inputs
application
code
datapath
description
captured
architecture
description
language
adl
called
gnr
outputs
include
generic
platform
specific
verilog
code
register
transfer
level
rtl
well
utilization
reports
can
used
optimize
datapath
additionally
tool
generates
high
level
schematic
architecture
helpful
future
modifications
input
application
language
use
describe
application
ansi
limitation
language
limitations
input
program
function
pointers
virtual
functions
global
pointer
initialization
currently
supported
complete
list
limitations
please
refer
section
5
nisc
quick
guide
can
include
standard
libraries
code
include
standard
libraries
stdio
note
compiling
application
single
processor
os
therefore
function
calls
printf
os
calls
malloc
meaningless
setup
however
standard
library
functions
string
manipulators
can
used
program
source
code
body
functions
also
included
input
program
information
please
refer
section
5
nisc
quick
guide
size
limitation
application
application
size
limited
nisc
can
write
assembly
nisc
assembly
low
level
programming
supported
pre
bound
functions
can
configure
nisctoolset
use
different
versions
microsoft
visual
studio
nisctoolset
can
configured
use
different
versions
editions
microsot
visual
studio
front
end
configure
tools
properly
open
nisctoolset
niscenvironment
bin
msvcfrontend
config
xml
ath
top
will
find
param
frontend
msvc9
param
set
value
paramter
msvc7
visual
studio
2003
msvc8
visual
studio
2005
msvc9
visual
studio
2008
application
niscdesign
proper
project
files
configuration
already
included
wich
will
use
global
frontend
parameter
select
proper
verion
also
remember
update
tools
paths
argument
group
tools
nisctoolset
niscenvironment
bin
global
config
xml
architecture
component
description
format
format
architecture
described
architecture
described
generic
netlist
representation
gnr
gnr
hierarchical
xml
based
adl
used
describing
components
nisc
processors
entire
system
gnr
strongly
typed
captures
different
aspects
components
different
tools
can
operate
information
gnr
see
publication
gorjiara
reshadi
chandraiah
gajski
generic
netlist
representation
system
pe
level
design
exploration
international
symposium
hardware
software
codesign
system
synthesis
codes
isss
october
2006
format
library
components
described
library
components
captured
gnr
well
can
add
custom
functional
unit
nisc
library
add
functional
unit
nisc
library
need
capture
entity
gnr
describe
internal
netlist
gnr
verilog
specify
functions
operations
unit
can
handle
custom
unit
can
parameterized
similar
verilog
vhdl
may
also
multi
cycle
pipelined
unit
can
add
functional
unit
nisc
datapath
using
tool
verilog
synthesis
mode
simply
need
instantiate
functional
unit
nisc
template
toolset
automatically
connect
rest
components
using
tool
custom
processor
design
mode
simplest
way
include
unit
instantiate
add
connection
register
file
rf
outputs
inputs
unit's
inputs
outputs
respectively
can
also
create
data
forwarding
bypass
paths
new
units
units
datapath
outputs
supported
platforms
know
output
rtl
code
tool
generates
structural
verilog
code
register
transfer
level
rtl
since
code
rt
level
even
primitive
synthesis
tools
xilinx
ise
can
synthesize
correctly
also
unlike
many
high
level
synthesis
tools
output
synthesizable
large
codes
nisc
output
verilog
synthesizable
size
code
point
tool
generates
two
types
verilog
code
1
generic
code
2
xilinx
specific
code
stored
simulation
synthesis
folders
respectively
verilog
modules
merged
one
file
called
design
also
testbench
file
generated
design
drives
reset
clk
signals
batch
file
also
provided
simulate
code
using
modelsim
simulator
difference
generic
verilog
output
xilinx
specific
verilog
output
generic
verilog
code
platform
independent
code
can
simulated
synthesized
platform
xilinx
specific
verilog
code
however
can
synthesized
using
xilinx
synthesis
tool
code
utilizes
optimized
xilinx
cores
memory
divider
etc
produce
efficient
results
fpgas
control
data
memory
implemented
using
block
rams
available
xilinx
fpgas
memories
initialized
correctly
design
binary
loaded
fpga
chip
can
synthesize
output
verilog
code
asic
design
uses
lut
based
controller
need
data
memory
generated
verilog
code
can
synthesized
asic
box
design
needs
memory
units
synthesis
tool
can
synthesize
memory
descriptions
much
thing
need
make
sure
initial
values
control
data
memories
loaded
simulating
design
synthesis
tool
synthesize
memory
descriptions
need
manually
run
memory
generator
tool
generate
memory
blocks
design
also
need
write
simple
wrapper
around
memory
block
make
compatible
nisc
memory
interface
style
output
verilog
codes
code
register
transfer
level
rtl
expect
simulating
verilog
code
simulate
design
simple
testbench
generated
automatically
testbench
drives
clock
signal
resets
ip
cycles
ip
gets
executes
execution
done
halt
signal
becomes
'1'
testbench
terminates
simulation
halt
becomes
'1'
writes
number
cycles
screen
also
design
contains
one
display
units
one
text
files
created
output
directory
files
can
see
values
program
printed
execution
values
can
used
verifying
design
explained
verification
section
faq
support
vhdl
currently
support
vhdl
though
possibility
future
architecture
components
features
compiler
support
multi
cycle
units
yes
component
high
delay
can
parameterize
multi
cycle
unit
set
delay
parameter
instantiating
unit
way
can
run
design
higher
clock
frequency
compiler
support
pipelined
units
yes
unit
pipelined
can
specify
properties
compiler
aspect
unit
compiler
supports
complex
pipeline
behavior
nisc
toolset
support
cache
potentially
yes
designed
cache
nisc
interested
cache
design
nisc
please
contact
us
can
make
nisc
programmable
can
reprogram
implementation
yes
can
choose
dedicated
programmable
controller
nisc
using
programmable
controller
big
code
size
can
reduce
code
size
size
code
depends
application
size
think
code
size
application
large
can
enable
code
compression
reduce
code
size
40
70
cost
8
18
performance
penalty
depending
application
information
see
publication
gorjiara
gajski
fpga
friendly
code
compression
horizontal
microcoded
custom
ips
international
symposium
field
programmable
gate
arrays
fpga
february
2007
can
reuse
pre
designed
nisc
ip
new
application
possible
ip
units
new
application
needs
can
add
units
connections
compile
application
new
datapath
validation
verification
validate
nisc
ip
simplest
way
validate
ip
instantiate
display
unit
aka
stdio
datapath
application
print
values
must
examined
display
unit
using
pre
bound
function
call
verilog
simulation
display
unit
opens
text
file
writes
values
file
values
file
correct
ip
behaving
correctly
final
implementation
remove
display
unit
datapath
comment
print
calls
system
design
integration
design
system
multiple
niscs
can
describe
system
contains
multiple
nisc
using
gnr
nisc
need
specify
program
project
file
addition
need
define
nisc
components
interface
design
interface
two
niscs
can
use
shared
register
dual
port
shared
memory
queue
interrupt
bus
communicate
two
niscs
instantiate
communication
medium
outside
two
nisc
system
make
communication
possible
need
instantiate
proxy
unit
nisc
describe
communication
api
side
verilog
implementation
proxy
unit
usually
straight
wiring
proxy
output
signals
control
communication
medium
write
driver
code
communicate
two
niscs
program
call
proxy
apis
form
pre
bound
functions
order
calling
apis
depend
communication
protocol
can
design
nisc
handles
external
interrupts
yes
nisc
library
comes
interrupt
handling
unit
several
external
interrupts
can
connected
unit
interrupt
triggered
function
niscinterrupt
exists
called
therefore
write
interrupt
handling
routine
function
based
id
triggered
interrupt
program
may
show
different
behavior
information
interrupt
handling
please
see
publication
reshadi
gajski
interrupt
low
level
programming
support
expanding
application
domain
statically
scheduled
horizontally
microcoded
architectures
embedded
systems
design
automation
test
europe
date
april
2007
can
design
nisc
communicates
bus
yes
information
connecting
nisc
bus
see
publications
gorjiara
reshadi
gajski
nisc
communication
interface
center
embedded
computer
systems
tr
06
05
march
2006
reshadi
gajski
interrupt
low
level
programming
support
expanding
application
domain
statically
scheduled
horizontally
microcoded
architectures
embedded
systems
design
automation
test
europe
date
april
2007
possible
multiple
communication
interfaces
yes
simply
instantiate
multiple
communication
proxies
inside
datapath
use
code
network
topologies
implemented
using
nisc
several
examples
come
downloadable
package
communication
examples
include
shared
dual
port
memory
double
handshake
bus
network
chip
mesh
nisc
processors
routers
performance
improvement
techniques
techniques
can
used
improve
performance
nsic
ips
improve
performance
different
techniques
instance
reduce
number
cycles
four
techniques
1
enhancing
parallelism
program
techniques
loop
unrolling
software
pipelining
various
code
transformations
developed
vliw
machines
2
incorporating
custom
functional
units
datapath
example
custom
functional
unit
bit
wise
operation
can
far
efficient
functionality
using
shift
logic
operations
3
increasing
parallelism
datapath
adding
many
functional
units
enough
bandwidth
read
write
operands
time
4
changing
pipeline
structure
chain
operations
adding
forwarding
paths
units
addition
reducing
cycle
count
improving
clock
frequency
increases
performance
well
information
please
refer
following
paper
gorjiara
gajski
design
space
exploration
programs
using
nisc
case
study
dct
algorithm
workshop
embedded
systems
real
time
multimedia
estimedia
pages
21
26
september
2005
power
optimizations
nisc
toolset
reduce
power
energy
consumption
ip
nisc
technology
toolset
reduce
power
energy
consumption
design
significantly
information
low
power
nisc
please
see
following
book
chapter
gorjiara
reshadi
gajski
chapter
2
low
power
design
nisc
technology
henkel
parameswaran
designing
embedded
processors
low
power
perspective
springer
isbn
978
1
4020
5868
4
april
2007
also
following
publication
contains
case
study
shows
nisc
reduces
energy
consumption
12
times
gorjiara
gajski
design
space
exploration
programs
using
nisc
case
study
dct
algorithm
workshop
embedded
systems
real
time
multimedia
estimedia
pages
21
26
september
2005
furthermore
nisc
low
power
architecture
generator
targets
controller
datapath
reduce
dynamic
power
overall
design
comparison
approaches
compare
nisc
high
level
synthesis
hls
standard
hls
behavioral
synthesis
tools
provide
top
design
flow
high
level
low
level
rtl
nisc
provides
top
flow
generating
architecture
bottom
flow
providing
datapath
input
using
hls
change
application
will
result
many
changes
generated
rtl
way
predict
correlate
application
changes
changes
results
therefore
way
improve
unsatisfactory
results
trial
error
guesswork
nisc
enables
designers
control
every
aspect
design
designer
can
select
exact
points
improvement
quickly
example
directly
changing
gnr
description
architecture
designer
can
reduce
critical
path
delay
fix
complex
multiplexers
connections
consume
much
power
make
layout
unroutable
hls
tools
provide
extension
input
language
extensions
require
extra
effort
learning
additionally
prevent
use
unmodified
code
lock
designer
proprietary
tool
making
developed
algorithms
non
portable
tools
nisc
technology
uses
standard
languages
designers
need
extra
training
also
can
use
favorite
development
tools
editors
debuggers
nisc
provides
seamless
way
combining
standard
verilog
pre
bound
functions
enabling
inclusion
low
level
verilog
code
inside
program
compare
nisc
custom
processor
designs
custom
processor
design
requires
processor
instruction
set
design
expertise
since
custom
instructions
directly
affect
instruction
binary
coding
instruction
decoder
hardware
number
custom
instructions
can
added
processor
limited
therefore
designer
must
look
profitable
instructions
added
finding
instructions
challenging
task
additionally
adding
custom
instructions
designer
either
use
hls
synthesis
datapath
controller
typically
unpredictable
unsatisfactory
results
must
manually
time
consuming
nisc
technology
designer
needs
specify
datapath
components
connections
possible
functionalities
datapath
will
directly
used
nisc
compiler
execute
program
nisc
approach
easier
designing
custom
processor
also
designer
able
directly
control
details
structure
datapath
get
much
better
quality
terms
area
clock
frequency
etc
end
online
tool
can
use
online
tool
actual
design
yes
time
can
write
externalouputs
port
read
externalinputs
good
enough
shared
register
communication
going
extend
online
tool
enable
communication
dual
port
shared
memory
