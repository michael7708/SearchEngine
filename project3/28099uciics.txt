ics 22 cse 22 fall 2012 unit testing test driven development junit 
what we did how we did it 
ics
22
cse
22
fall
2012
news
course
reference
schedule
lab
manual
code
examples
alex
ics
22
cse
22
fall
2012
unit
testing
test
driven
development
junit
introduction
asked
fairly
early
demonstration
take
notes
wanted
able
concentrate
process
test
driven
development
following
example
step
step
document
combined
step
step
code
examples
meant
take
place
notes
might
taken
also
taken
liberty
saying
additional
things
chance
talk
lecture
process
test
driven
development
encourages
build
program
one
small
feature
time
taking
small
steps
one
piece
stable
ground
another
notion
small
feature
open
debate
though
good
guideline
prefer
features
simple
size
newly
created
collection
songs
zero
features
complex
complete
songcollection
class
goal
write
test
verifies
behavior
new
feature
write
code
implements
feature
using
test
guide
indicate
done
point
feature
complete
tested
means
taken
step
stable
ground
importantly
test
can
keep
forever
able
run
repeatedly
ensure
feature
still
works
make
changes
add
new
features
program
contrast
approach
one
taken
worked
programs
thus
far
quarter
current
approach
know
part
program
finished
ensure
continues
work
correctly
continue
make
changes
program
lecture
went
step
step
example
group
developing
portions
songcollection
class
using
test
driven
development
process
best
follow
steps
though
sometimes
forgot
took
liberties
interest
time
different
programming
style
accustomed
takes
little
time
adjust
get
rhythm
test
driven
development
let
learning
curve
chase
away
take
long
get
adjusted
benefits
higher
quality
code
terms
well
works
well
designed
ability
make
changes
program
confidence
pick
new
feature
want
implement
preferring
simple
features
can
verified
single
test
implement
complex
programs
using
test
driven
development
just
break
simpler
pieces
good
practice
whether
using
test
driven
philosophy
write
test
test
intended
verify
behavior
feature
class
classes
likely
added
yet
means
potentially
creating
objects
classes
yet
exist
calling
methods
written
may
seem
weird
actually
whole
point
pretend
like
classes
methods
want
already
written
least
couple
benefits
writing
test
first
need
guess
whether
code
works
test
will
tell
successfully
implemented
feature
tested
design
ever
implemented
discover
code
sets
necessary
objects
calls
method
testing
seems
cumbersome
needs
good
indication
design
probably
convoluted
needs
design
least
important
code
write
clean
design
ensures
program
will
understandable
original
author
others
well
maintainable
extensible
users
request
bug
fixes
new
features
qualities
underestimated
programs
real
world
often
live
good
deal
longer
original
authors
intend
often
stay
organization
long
original
author
moved
greener
pastures
important
able
introduce
changes
program
without
falling
like
house
cards
wise
start
simple
features
work
way
somewhat
complex
ones
chose
begin
testing
size
empty
collection
songs
zero
compile
test
even
though
know
compile
without
errors
point
get
compiler
tell
missing
rather
guessing
compiling
test
reading
error
messages
clear
idea
code
needs
added
rewritten
order
make
test
compile
successfully
saw
demonstration
eclipse
automates
step
recompiles
code
every
time
save
write
minimum
amount
code
class
will
make
test
compile
without
worrying
whether
class
will
pass
test
objective
declare
new
methods
class
will
needed
test
implement
yet
let
test
tell
us
code
missing
next
step
run
test
will
almost
always
fail
will
tell
precisely
telling
behavior
expected
behavior
observed
occasionally
test
fail
first
time
stub
wrote
accidentally
correct
example
initially
wrote
method
songcollection
class
tried
get
size
empty
collection
zero
test
compile
public
int
size
return
0
just
happened
returning
0
right
thing
though
reason
said
return
0
java
return
integer
method
order
compile
goal
get
method
compile
saying
return
0
good
anything
else
luckily
0
right
result
usually
assuming
test
failed
usually
will
test
told
specifically
failed
write
minimum
amount
code
class
will
make
test
pass
difficult
habit
get
first
often
necessitates
writing
code
works
perfectly
simple
case
testing
clearly
work
later
okay
able
write
code
general
case
later
will
old
tests
can
verify
simpler
cases
well
functionality
already
built
still
work
correctly
change
tests
something
write
throw
away
keep
long
keep
program
time
want
go
back
make
changes
anywhere
program
tests
will
available
verify
nothing
else
broken
result
run
test
hopefully
will
pass
means
new
feature
implemented
now
reached
stable
ground
approach
using
far
quarter
often
feel
like
stable
ground
now
new
feature
implemented
see
whether
ways
improve
design
code
looking
often
called
code
smells
places
design
made
better
duplicated
code
another
part
class
class
code
just
added
render
older
code
useless
fix
problems
now
running
tests
small
change
name
process
called
refactoring
can
make
changes
confidence
tests
provide
valuable
safety
net
change
made
breaks
code
worked
tests
will
tell
immediately
can
work
new
problem
change
just
made
still
fresh
mind
now
start
process
another
feature
continue
believe
features
program
implemented
going
one
iteration
process
added
one
new
feature
program
verified
feature
works
expected
cleaned
brewing
design
problems
become
significantly
bigger
problems
later
junit
folks
say
keep
bar
green
keep
code
clean
still
discover
bug
talk
lecture
done
discover
bug
program
even
faithfully
adhered
test
driven
strategy
naturally
using
test
driven
development
process
guarantee
program
will
work
variety
reasons
following
process
allows
compiler
testing
framework
help
avoid
many
mistakes
many
aspects
software
development
process
much
improve
first
program
works
well
tests
say
will
one
tests
expects
behavior
incorrect
size
empty
collection
1
write
code
passes
test
mean
code
makes
sense
broader
context
similarly
tests
verify
program's
requirements
appropriate
tasked
building
software
meet
business
needs
customer
tests
help
identify
issue
short
testing
helps
verify
program
correct
notion
correct
often
black
white
one
unfortunately
will
still
bugs
question
done
discover
one
following
steps
can
guide
bug
fixing
write
test
reproduces
bug
asserts
unintended
behavior
happen
step
critical
will
provide
way
sure
actually
fixed
bug
run
test
verify
fails
bug
isolated
problem
need
go
back
write
better
test
find
fix
bug
normally
find
need
add
new
features
program
order
fix
bug
follow
set
steps
described
adding
carefully
writing
tests
first
writing
minimum
amounts
code
needed
make
work
run
tests
verify
bug
fixed
tests
still
pass
well
now
can
confidence
fixed
problem
also
broken
anything
else
previously
worked
reach
stable
ground
quickly
additional
thoughts
give
process
genuine
try
even
feels
less
productive
just
plain
strange
compared
usual
strategy
writing
programs
trust
can
get
rhythm
will
find
writing
higher
quality
code
quickly
less
mistakes
early
less
debugging
end
learned
experience
lecture
test
driven
development
works
nicely
pair
programming
sometimes
made
mistakes
haste
get
code
written
still
explaining
everything
folks
working
collectively
partner
ended
virtually
mistakes
lasted
longer
seconds
fun
developing
software
exciting
enjoyable
stimulating
experience
test
driven
development
takes
away
good
deal
frustration
involved
allowing
concentrate
understanding
problem
constructing
clean
solution
adapted
similar
document
written
alex
thornton
informatics
42
winter
2005
winter
2007
