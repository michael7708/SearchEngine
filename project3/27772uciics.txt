informatics 102 spring 2012 assignment 3 concurrent programming erlang 
assignment 3 
informatics
102
spring
2012
news
course
reference
schedule
lab
manual
code
examples
alex
informatics
102
spring
2012
assignment
3
concurrent
programming
erlang
due
date
time
wednesday
may
16
11
59pm
introduction
erlang
functional
programming
language
direct
built
support
concurrency
ability
perform
one
task
simultaneously
machine
distribution
ability
perform
cooperating
tasks
multiple
machines
era
networked
multicore
computers
concurrency
distribution
becoming
increasingly
important
erlang
anything
special
done
languages
clearly
demonstrates
difference
language
allows
build
infrastructure
supports
concurrency
distribution
like
java
one
infrastructure
built
assignment
gives
experience
sequential
concurrent
programming
erlang
though
will
focus
concurrent
aspects
using
sequential
problems
warm
familiarize
erlang
syntax
semantics
whether
previously
written
concurrent
programs
languages
java
likely
experience
erlang
will
feel
different
anything
done
learn
erlang
presume
new
erlang
programming
language
new
programming
language
two
hurdles
cross
syntax
hurdle
say
want
say
semantic
hurdle
want
say
first
place
erlang
encourages
fact
requires
think
differently
programming
java
semantic
hurdle
will
actually
little
bit
tougher
though
will
able
rely
previous
experience
functional
languages
like
scheme
haskell
erlang
features
familiar
goal
become
immediate
experts
experience
aspects
erlang
new
interesting
relative
things
done
new
experience
will
make
us
better
software
writers
even
never
see
erlang
get
started
written
tutorial
describes
subset
erlang
discussed
lecture
along
instructions
using
erlang
ics
labs
installing
erlang
computer
part
1
sequential
erlang
programming
30
points
module
named
part1
file
named
part1
erl
write
export
following
six
functions
will
likely
need
write
helper
functions
export
permitted
use
case
expressions
cover
lecture
use
pattern
matching
instead
important
learning
new
language
write
using
idioms
know
languages
get
experience
want
use
idioms
like
pattern
matching
appropriate
new
language
fib
calculates
nth
fibonacci
number
use
tail
recursion
rather
non
tail
recursive
form
shown
mymath
module
erlang
tutorial
solution
run
time
given
parameter
examples
fib
0
¡÷
0fib
6
¡÷
8fib
40
¡÷
102334155
adjacent
duplicates
takes
list
returns
list
containing
elements
adjacent
duplicate
elements
element
following
identical
use
functions
predefined
lists
module
examples
adjacent
duplicates
1
1
2
2
3
3
¡÷
1
2
3
adjacent
duplicates
1
2
2
2
3
¡÷
2
2
adjacent
duplicates
1
2
3
4
¡÷
adjacent
duplicates
1
2
3
2
1
¡÷
deep
sum
takes
possibly
nested
list
tuples
containing
two
numbers
returns
sum
numbers
list
use
functions
predefined
lists
module
find
useful
examples
deep
sum
1
2
3
4
¡÷
10deep
sum
1
2
2
3
3
4
4
5
¡÷
24deep
sum
1
2
3
4
3
4
4
5
5
6
6
7
¡÷
50deep
sum
¡÷
0
concatenate
takes
list
strings
flattens
one
long
string
use
functions
predefined
lists
module
find
useful
examples
concatenate
alex
happy
¡÷
alexishappy
concatenate
time
conquerer
¡÷
time
conquerer
perimeter
shape
takes
tuple
describing
shape
returns
perimeter
shape
tuple
will
one
following
forms
circle
radius
rectangle
width
height
right
triangle
width
height
hypot
given
argument
tuple
one
forms
function
fail
examples
perimeter
circle
3
¡÷
18
8495592153876perimeter
rectangle
5
7
¡÷
24perimeter
right
triangle
3
4
5
¡÷
12
permutations
takes
list
returns
list
containing
permutations
use
functions
predefined
lists
module
find
useful
fine
output
different
order
long
permutations
included
examples
permutations
1
2
3
¡÷
1
2
3
1
3
2
2
1
3
2
3
1
3
1
2
3
2
1
permutations
1
¡÷
1
permutations
¡÷
part
2
processes
message
passing
40
points
write
module
named
dictionary
server
whose
job
implement
process
maintains
dictionary
collection
key
value
pairs
keys
remain
unique
dictionary
though
values
required
export
following
functions
start
0
starts
dictionary
server
process
already
dictionary
server
running
function
fail
important
error
returns
stop
0
stops
dictionary
server
process
running
dictionary
server
process
running
function
effect
insert
2
takes
two
parameters
key
value
adds
given
key
value
dictionary
given
key
already
dictionary
new
value
replace
old
value
dictionary
function
returns
ok
work
done
remove
1
takes
one
parameter
key
removes
given
key
dictionary
present
function
returns
ok
key
removed
successfully
notfound
key
dictionary
lookup
1
takes
one
parameter
key
finds
corresponding
value
dictionary
key
dictionary
function
returns
tuple
ok
value
value
value
associated
key
key
dictionary
function
returns
notfound
clear
0
clears
keys
values
dictionary
size
0
returns
integer
specifying
number
keys
dictionary
permitted
write
additional
non
exported
functions
need
though
required
export
functions
described
will
need
use
message
passing
make
work
though
users
dictionary
server
will
never
need
send
receive
messages
explicitly
thus
need
know
format
messages
instead
message
passing
will
take
place
within
module
reason
need
send
receive
messages
caller
say
insert
2
function
will
different
process
dictionary
server
process
way
processes
exchange
information
pass
messages
back
forth
need
decide
messages
look
like
information
important
carry
handled
important
consequence
design
requiring
users
dictionary
server
know
pid
actually
good
thing
sense
makes
dictionary
server
easier
use
downside
design
approach
one
dictionary
server
running
time
still
lots
practical
systems
want
one
particular
server
running
surprisingly
common
practice
erlang
means
need
use
process
registration
give
process
name
name
can
used
throughout
module
pid
will
never
need
used
registered
one
thing
remember
need
process
messages
recursively
one
time
since
erlang
looping
construct
remember
important
process
messages
tail
recursively
dictionary
server
potentially
run
forever
without
running
stack
space
tail
recursion
server
processes
just
nice
performance
optimization
absolutely
critical
done
part
called
lecture
actor
actors
lot
like
objects
object
oriented
languages
like
java
except
run
concurrently
actors
erlang
processes
can
one
thing
time
one
model
concurrent
programming
gaining
least
traction
software
design
circles
panacea
nice
solution
kinds
problems
extra
efficiency
challenge
optional
required
build
dictionary
using
efficient
data
structure
list
fine
welcome
build
something
better
like
binary
search
tree
like
want
try
building
binary
search
tree
one
way
represent
tuple
whose
first
element
atom
bst
second
element
can
either
atom
empty
tree
empty
three
element
tuple
containing
root
tree
two
element
tuple
containing
key
value
left
subtree
right
subtree
example
binary
search
tree
whose
root
contains
key
20
value
right
subtree
containing
node
key
30
value
children
might
look
like
bst
20
bst
empty
bst
30
bst
empty
bst
empty
additionally
suggest
building
binary
search
tree
separate
module
called
bst
separating
concern
concern
building
dictionary
server
part
3
using
mapreduce
algorithm
30
points
lecture
implemented
mapreduce
algorithm
erlang
mapreduce
algorithm
asks
concurrent
distributed
tasks
erlang
tasks
erlang
processes
perform
portion
large
job
collects
combines
intermediate
results
one
final
result
mapreduce
can
efficient
processes
can
genuinely
run
concurrently
enough
processors
run
processes
processes
distributed
different
machines
scenario
erlang
supports
natively
long
time
spent
sending
messages
combining
results
prohibitive
relative
time
individual
processes
spend
work
part
assignment
required
take
mapreduce
implementation
lecture
find
along
deeper
explanation
algorithm
code
examples
section
course
web
site
apply
new
problem
make
modifications
mapreduce
algorithm
provided
goal
learn
apply
mapreduce
different
kind
problem
demonstrated
example
part
assignment
write
two
modules
module
named
integers
list
implements
server
process
similar
counterprocess
server
mapreduce
code
example
except
job
remember
list
integers
provided
starts
provide
ability
filter
integers
using
filter
fun
counterprocess
module
integers
list
module
export
two
functions
start
1
spawns
new
integers
list
server
process
returns
pid
argument
list
integers
remember
runs
note
way
change
list
integers
process
spawned
stop
1
takes
pid
integers
list
server
process
tells
stop
waiting
response
confirm
really
stop
otherwise
contain
run
function
comprises
server's
tail
recursive
server
loop
module
named
integer
finder
exports
following
function
find
integers
2
takes
two
parameters
list
pids
corresponding
integers
list
processes
filter
fun
takes
integer
returns
either
true
false
fun
answering
arbitrary
yes
question
integer
return
whether
integer
positive
return
whether
integer
odd
return
whether
integer
ends
digit
9
find
integers
function
use
provided
mapreduce
implementation
find
return
list
integers
integers
lists
filter
fun
returns
true
returned
integers
sorted
ascending
order
opposed
just
returned
whatever
order
integers
lists
return
integer
finder
module
hide
details
mapreduce
algorithm
used
message
sent
integers
list
processes
response
messages
will
look
like
initial
result
etc
deliverables
submit
erl
files
comprise
part
assignment
submit
beam
files
files
follow
link
discussion
submit
assignment
via
checkmate
aware
holding
rules
specified
document
including
one
says
responsible
submitting
version
assignment
want
graded
regrade
assignment
simply
submitted
wrong
version
accident
commentary
miscellaneous
tweaks
slight
reorienting
part
3
alex
thornton
spring
2012
originally
written
alex
thornton
winter
2009
