strong connectivity 
strongly connected components 
ics
161
design
analysis
algorithms
lecture
notes
february
20
1996
strongly
connected
components
strong
connectivity
equivalence
relations
undirected
graphs
two
vertices
connected
path
connecting
define
connected
directed
graph
say
vertex
strongly
connected
exist
two
paths
one
another
note
allow
two
paths
share
vertices
even
share
edges
will
use
shorthand
strongly
connected
will
allow
short
paths
one
vertex
edges
vertex
strongly
connected
recall
relation
another
word
collection
pairs
objects
like
can
think
relation
directed
graph
one
using
define
connectivity
equivalence
relation
relation
satisfies
three
simple
properties
reflexive
property
vertex
strongly
connected
definition
symmetric
property
strong
connectivity
follows
symmetry
definition
two
paths
one
another
show
looked
order
one
another
show
transitive
property
expand
strong
connectivity
four
paths
concatenating
pairs
produces
two
paths
connecting
showing
transitive
property
holds
strong
connectivity
since
three
properties
true
strong
connectivity
strong
connectivity
equivalence
relation
note
critical
definition
allowed
paths
overlap
made
small
change
defining
two
vertices
connected
part
directed
cycle
able
concatenate
paths
show
transitive
property
holds
equivalence
classes
strongly
connected
components
equivalence
relation
can
define
equivalence
classes
formula
english
equivalence
class
call
defined
simply
set
things
related
equivalence
classes
strong
connectivity
called
strongly
connected
components
sets
property
partition
space
vertices
disjoint
subsets
hard
prove
first
vertex
member
reflexivity
equivalence
classes
cover
input
second
symmetry
transitivity
element
one
element
two
different
equivalence
classes
must
disjoint
can
find
strongly
connected
components
graph
easy
test
whether
two
vertices
strongly
connected
just
see
component
component
graph
weak
connectivity
strongly
connected
components
also
use
graph
algorithms
replace
every
strongly
connected
component
single
vertex
get
smaller
directed
acyclic
graph
known
component
graph
condensation
baase
ex
4
42
asks
prove
fact
graph
problems
can
use
idea
get
algorithm
reduces
problem
subproblems
component
plus
one
subproblem
component
graph
example
problem
baase
get
lecture
test
suppose
define
two
vertices
weakly
connected
also
known
semiconnected
either
path
one
necessarily
say
graph
weakly
connected
true
every
pair
vertices
hard
show
graph
weakly
connected
component
graph
path
computing
strongly
connected
components
can
also
test
weak
connectivity
computing
single
component
definition
easy
find
single
strongly
connected
component
simply
use
bfs
dfs
similar
algorithm
find
set
vertices
reachable
path
thing
graph
formed
reversing
edges
original
graph
find
set
vertices
can
reach
path
according
definition
just
intersection
time
can
find
single
component
since
components
can
find
time
mn
slower
necessary
point
today's
lecture
show
solve
problem
linear
time
solution
describe
based
depth
first
search
invented
bob
tarjan
1972
baase
ex
4
50
outlines
alternative
linear
time
algorithm
depth
first
search
tangent
pseudo
code
writing
pseudocode
book
reason
speaking
sentences
book
ideas
matter
exact
pseudocode
asking
memorize
book
lecture
answer
neither
get
understand
point
seem
like
idea
remember
idea
mind
pseudocode
dfs
directed
graph
version
looks
little
different
last
time
one
complication
forgot
mention
lecture
want
build
dfs
tree
involves
vertices
graph
just
start
somewhere
graph
vertices
might
reachable
dfs
will
get
one
solution
restart
dfs
every
time
happens
make
things
little
simpler
going
modify
graph
adding
new
vertex
connected
outward
going
edges
everything
else
change
strongly
connected
components
except
add
one
new
component
one
new
vertex
keeps
rest
algorithm
simpler
dfs
make
new
vertex
edges
build
directed
tree
initially
single
vertex
visit
visit
edge
already
add
visit
version
pseudo
code
makes
obvious
certain
edges
can
occur
already
gets
added
end
tree
must
already
tree
three
possible
places
ancestor
case
call
back
edge
descendant
case
call
forward
edge
previous
branch
tree
case
call
cross
edge
one
case
ruled
can
later
branch
tree
dfs
trees
strongly
connected
components
key
property
relates
dfs
strong
connectivity
strongly
connected
components
form
subtrees
dfs
tree
words
component
can
two
separate
parts
tree
note
paths
two
intermediate
vertices
paths
also
component
since
already
path
concatenating
also
get
path
suppose
one
component
ended
two
parts
tree
edges
one
part
definition
strong
connectivity
tells
us
must
paths
observation
intermediate
vertices
part
component
tells
us
actually
just
edges
two
parts
side
side
branches
tree
edges
one
two
directions
hand
one
part
contains
ancestor
vertex
part
can
use
argument
intermediate
vertices
show
path
tree
also
component
contradicting
assumption
different
parts
tree
possible
component
two
separate
parts
dfs
tree
wanted
prove
heads
components
since
components
graph
just
subtrees
dfs
tree
find
components
just
break
tree
certain
edges
components
will
formed
left
tree
say
vertex
head
component
topmost
break
edge
coming
observations
problem
turned
one
determining
whether
given
vertex
head
test
look
subtree
dfs
tree
rooted
suppose
subtree
back
cross
edges
going
clearly
must
head
since
paths
vertex
higher
tree
just
clearly
back
edge
subtree
ancestor
head
case
edge
together
paths
dfs
tree
form
cycle
must
part
component
higher
tree
can
head
component
complicated
case
happens
edges
going
subtree
rooted
cross
edges
branches
dfs
tree
make
complicated
case
little
easier
set
algorithm
soon
dfs
finishes
visiting
vertex
head
delete
component
graph
can
show
algorithm
whenever
see
cross
edge
subtree
head
proof
use
fact
dfs
trees
cross
edges
previously
visited
branches
tree
later
branches
suppose
see
cross
edge
let
head
visited
later
separate
branch
tree
finished
visiting
deleted
contradicting
assumption
seeing
edge
ancestor
putting
edge
together
paths
assumption
head
since
ancestor
since
ancestor
gives
us
cycle
showing
therefore
head
summarizing
see
can
test
whether
vertex
head
looking
existence
back
cross
edges
subtree
strong
connectivity
algorithm
define
dfs
numbering
dfsnum
number
vertices
visited
dfs
back
cross
edge
subtree
something
visited
therefore
smaller
dfsnum
use
defining
low
value
low
smallest
dfsnum
vertex
reachable
back
cross
edge
subtree
edge
low
dfsnum
rephrasing
seen
far
head
component
exactly
low
dfsnum
advantage
using
definitions
dfsnum
trivial
calculate
perform
dfs
low
easily
computed
combining
low
values
children
values
coming
back
cross
edges
use
one
simple
data
structure
stack
represented
list
use
identify
subtree
rooted
vertex
simply
push
new
vertex
onto
visit
finished
visiting
vertex
subtree
will
everything
pushed
onto
head
already
deleted
heads
subtree
remaining
vertices
left
will
exactly
component
now
ready
describe
actual
algorithm
simply
performs
dfs
keeping
track
low
dfsnum
values
defined
using
identify
heads
components
finding
head
deleting
whole
component
graph
using
find
vertices
component
dfs
make
new
vertex
edges
initialize
counter
zero
initialize
list
empty
build
directed
tree
initially
single
vertex
visit
visit
add
dfsnum
increment
low
dfsnum
edge
already
add
visit
low
min
low
low
else
low
min
low
dfsnum
low
dfsnum
output
component
repeat
remove
last
element
output
remove
already
seen
explanation
algorithm
works
remains
point
takes
linear
time
basic
framework
just
dfs
added
manipulations
low
dfsnum
slow
can
find
strongly
connected
components
linear
time
ics
161
dept
information
computer
science
uc
irvine
last
update
12
dec
2001
13
19
20
pst
