the fundamental rules software engineering 

fundamental
rules
software
engineering
1
don
system
architectural
design
well
defined
interfaces
integration
will
big
mess
2
design
coding
3
project
late
add
people
project
will
even
later
3
4
team
members
new
project
less
productive
1
3
2
3
less
adequately
trained
people
5
average
newly
hired
employee
productive
experienced
employee
1
6
two
factors
affect
productivity
work
force
experience
level
level
project
familiarity
due
learning
curve
effects
1
7
developers
productivity
varies
greatly
depending
individual
skills
experience
concerning
development
activity
knowledge
tools
methods
notations
used
etc
2
4
11
8
using
better
fewer
people
productive
using
less
qualified
people
2
9
greater
number
developers
working
task
simultaneously
faster
task
finished
overall
effort
required
due
growing
need
communication
among
developers
thus
productivity
individual
developer
decreases
2
10
earlier
problems
discovered
less
overall
cost
will
7
11
error
detection
effectiveness
reviews
depends
greatly
qualifications
preparations
reviewers
completeness
correctness
documents
used
reference
14
12
reviews
non
technical
documents
requirements
specification
user
manual
effective
customer
involved
10
13
develop
tests
coding
14
extreme
time
pressure
leads
decreased
productivity
7
15
extreme
time
pressure
leads
faster
rate
errors
made
leads
delay
completion
date
9
16
error
correction
efficiently
done
document
author
7
17
errors
document
previous
phase
contains
errors
will
passed
next
document
7
18
always
test
everything
19
talk
users
customers
verify
prototype
20
inspection
cost
effective
measure
finding
problems
software
21
software
inspections
find
high
percentage
errors
early
development
life
cycle
13
22
use
inspections
can
lead
defect
prevention
developers
get
early
feedback
respect
types
mistakes
making
13
23
every
group
one
programmer
10
times
productive
everyone
else
24
disable
internet
surfing
productivity
will
go
25
number
meetings
determined
kinds
processes
used
26
changing
requirements
inevitable
anticipating
change
open
architectures
adaptable
designs
flexible
planning
can
help
mediate
ill
effects
changes
6
27
design
change
variability
28
use
defensive
programming
29
configuration
management
good
30
successful
software
designed
people
understand
application
software
well
designed
missile
control
program
designed
someone
understood
missiles
8
31
software
development
requires
substantial
time
commitment
learning
application
domain
5
32
broad
application
knowledge
acquired
relevant
experience
training
5
33
bugs
find
buggy
rest
program
will
likely
34
tests
reveal
errors
code
better
test
prepared
higher
amount
detected
errors
35
sticking
tight
schedule
increases
cost
due
large
work
force
1
36
motivation
increased
monetary
incentives
profit
sharing
pay
performance
merit
pay
work
measurement
incentives
morale
measurement
creating
positive
frame
mind
work
employee
involvement
wellness
programs
creating
fun
work
encouraging
feeling
commitment
responsibility
worker
participation
decision
making
getting
employees
think
like
owners
self
managing
work
teams
commitment
productivity
breakthroughs
providing
environment
freedom
less
restrictions
increasing
schedule
pressure
using
visible
milestones
setting
individual
goals
increased
motivation
leads
increased
productivity
reduces
cycle
time
13
37
improving
work
environment
done
making
ergonomic
considerations
giving
employees
enclosed
offices
reduce
background
noise
interruptions
giving
employees
access
required
resources
computers
software
tools
support
staff
information
improving
work
environment
leads
increased
productivity
reduces
cycle
time
13
38
getting
employees
can
done
utilizing
experts
employee
training
skills
assessment
job
matching
reducing
turnover
getting
employees
leads
increased
productivity
leads
decreased
cycle
time
13
39
improving
software
development
process
can
done
formalizing
process
controlling
quality
taking
advantage
tools
improving
software
process
increases
employees
motivation
also
increases
productivity
13
40
rework
usually
due
customer
requirements
product
flaws
communication
breakdown
project
members
improving
process
reduce
rework
can
done
using
prototyping
evolutionary
development
using
formal
specification
methods
modern
programming
practices
inspections
reducing
rework
increases
productivity
13
41
design
complexity
can
reduced
using
object
oriented
design
techniques
reducing
design
complexity
reduces
product
complexity
increases
productivity
13
42
code
complexity
can
reduced
using
modularization
object
oriented
programming
techniques
reducing
code
complexity
reduces
product
complexity
increases
productivity
13
43
cognitive
complexity
can
reduced
modularization
multiple
levels
abstraction
simulation
prototyping
reducing
cognitive
complexity
reduces
product
complexity
increases
productivity
13
44
test
complexity
can
reduced
using
testing
tools
building
product
testing
mind
testing
type
environment
product
will
used
reducing
test
complexity
reduces
product
complexity
increases
productivity
13
45
management
complexity
can
reduced
using
project
management
planning
tools
methods
reducing
management
complexity
reduces
product
complexity
increases
productivity
13
46
tasks
can
eliminated
simplified
using
automation
tasks
code
generators
automated
testing
eliminating
non
value
added
activities
low
priority
tasks
leads
increased
productivity
13
47
nine
ways
reduce
cycle
time
increase
productivity
reduce
rework
maximize
software
reuse
reduce
product
complexity
eliminate
simplify
tasks
maximize
task
concurrency
reduce
undiscovered
work
reduce
risk
use
process
models
aimed
cycle
time
reduction
13
48
productivity
increased
increasing
motivation
improving
work
environment
getting
best
people
job
improving
process
maximizing
reuse
13
49
product
complexity
can
reduced
reducing
code
complexity
design
complexity
cognitive
complexity
test
complexity
management
complexity
13
50
decisions
made
upstream
portion
software
development
process
requirements
design
impact
productivity
quality
costs
throughout
life
cycle
portions
5
51
thin
spread
application
domain
knowledge
major
phenomenon
greatly
reduces
software
productivity
quality
5
52
specification
mistakes
often
occur
designers
sufficient
application
knowledge
interpret
customer
intentions
requirements
document
5
53
requirements
will
appear
fluctuate
development
team
lacks
application
knowledge
performs
incomplete
analysis
requirements
5
54
coordinating
understanding
application
environment
requires
constant
communication
customers
developers
5
55
specifications
almost
always
incomplete
fraught
ambiguities
constant
contact
customer
required
obtain
correct
requirements
without
communication
developers
tend
make
incorrect
assumptions
customer
wants
6
56
fluctuating
conflicting
requirements
major
phenomenon
greatly
reduces
software
productivity
quality
5
57
communication
coordination
breakdown
major
phenomenon
greatly
reduces
software
productivity
quality
5
58
truly
exceptional
designers
extremely
familiar
application
domain
skilled
communicating
technical
vision
project
members
possess
exceptional
ability
map
behavior
required
application
system
computational
structures
implement
behavior
recognized
intellectual
core
project
scarce
resource
5
59
new
requirements
frequently
emerge
development
since
identified
portions
system
designed
implemented
5
60
besides
developer
ability
design
implement
programs
skills
resolving
conflicting
requirements
negotiating
customer
ensuring
development
staff
shares
consistent
understanding
design
providing
communications
two
contending
groups
crucial
project
performance
5
61
undiscovered
work
work
considered
initial
planning
estimates
can
reduced
using
formal
methods
analysis
pert
sizing
metrics
spiral
life
cycle
model
prototyping
reducing
undiscovered
work
leads
increased
productivity
13
62
risk
can
reduced
using
risk
management
techniques
reducing
risk
leads
increased
productivity
13
63
inspections
thought
part
development
process
time
must
set
aside
accordingly
done
inspections
can
significant
improvement
development
organization
ability
meet
internal
schedules
13
64
proper
use
inspections
can
even
shorten
life
cycle
13
65
participants
inspection
team
get
high
degree
product
knowledge
leads
higher
productivity
13
66
slower
programmers
show
great
deal
improvement
using
inspections
13
67
new
project
assignee
become
productive
six
months
year
project
5
68
collaborators
use
hand
gestures
uniquely
communicate
significant
information
12
69
employers
often
limit
number
hours
employees
can
work
resulting
pressure
finish
project
quickly
possible
6
70
customer
often
changes
deadlines
earlier
originally
agreed
upon
requiring
negotiation
customer
either
allowing
deliverables
delivered
earlier
date
rest
delivered
later
dropping
deliverables
requirements
altogether
6
71
code
comments
documentation
often
produced
end
project
creating
major
problems
team
member
lost
short
notice
leaving
others
continue
work
can
alleviated
quality
auditors
require
inspections
short
notice
6
72
teams
often
change
projects
members
added
removed
6
73
sometimes
software
used
development
upgraded
new
version
development
despite
claims
fully
backward
compatible
won
affect
work
usually
introduces
new
problems
6
74
hardware
crashes
customers
often
unsympathetic
kind
delay
6
75
project
later
stages
development
development
hardware
software
tend
greatest
demand
performance
starts
suffer
lengthy
compilations
builds
test
runs
6
76
matching
tasks
skills
motivation
people
available
increases
productivity
2
77
employee
motivation
strongest
influence
productivity
2
78
certain
threshold
work
conditions
powerful
motivator
threshold
powerful
de
motivator
2
79
training
new
employees
usually
done
old
timers
results
reduced
level
productivity
old
timer
part
specifically
average
new
employee
consumes
training
overhead
20
experienced
employee
time
duration
training
assimilation
period
1
80
average
assimilation
delay
period
time
takes
new
employee
become
fully
productive
80
days
1
81
schedule
pressure
increases
quality
assurance
activities
especially
walk
throughs
inspections
often
relaxed
suspended
altogether
1
82
absence
schedule
pressure
full
time
employee
allocates
average
60
working
hours
project
rest
slack
time
reading
mail
personal
activities
non
project
related
company
business
etc
1
83
schedule
pressure
people
tend
increase
percentage
working
hours
spent
project
much
100
due
spending
less
time
project
activities
personal
business
non
project
communication
working
overtime
1
84
three
resource
type
variables
greatest
impact
programmer
productivity
availability
programming
tools
availability
programming
practices
programmer
experience
1
85
two
task
type
variables
greatest
impact
programmer
productivity
programming
language
quality
external
documentation
1
86
average
full
time
employee
misses
13
15
days
work
per
year
counting
vacation
time
reasons
broken
following
table
godwins
1996
1239
reasons
missed
work
day
employees
employees
dependents
stress
1
1
1
1
personal
matters
1
4
1
5
sick
child
1
2
2
1
day
care
availability
issue
0
4
0
8
elder
parent
care
0
6
0
9
family
matters
4
4
4
6
sick
illness
4
5
4
2
total
annual
downtime
days
13
6
15
2
references
1
abdel
hamid
madnick
software
project
dynamics
integrated
approach
1991
upper
saddle
river
nj
prentice
hall
inc
2
boehm
software
engineering
economics
1981
upper
saddle
river
nj
prentice
hall
inc
3
brooks
mythical
man
month
essays
software
engineering
2
ed
1995
addison
wesley
336
4
bryan
programmers
created
equal
software
engineering
project
management
thayer
editor
1997
ieee
computer
society
los
alamitos
ca
346
355
5
curtis
krasner
iscoe
field
study
software
design
process
large
systems
communications
acm
1988
31
11
1268
1287
6
dawson
twenty
dirty
tricks
train
software
engineers
proceedings
22nd
international
conference
software
engineering
2000
acm
209
218
7
drappa
ludewig
simulation
software
engineering
training
proceedings
22nd
internation
conference
software
engineering
2000
acm
199
208
8
humphrey
managing
software
process
1990
addison
wesley
9
levary
lin
modelling
software
development
process
using
expert
simulation
system
fuzzy
logic
software
practice
experience
1991
21
2
133
148
10
pressman
software
engineering
practitioner's
approach
4
ed
1997
new
york
ny
mcgraw
hill
11
sackman
erikson
grant
exploratory
experimental
studies
comparing
online
offline
programming
performance
communications
acm
1968
11
1
3
11
12
tang
findings
observational
studies
collaborative
work
readings
groupware
computer
supported
cooperative
work
baecker
editor
1990
morgan
kaufmann
san
mateo
ca
251
259
13
tvedt
extensible
model
evaluating
impact
process
improvements
software
development
cycle
time
1996
ph
dissertation
arizona
state
university
14
weller
lessons
three
years
inspection
data
ieee
software
1993
10
5
38
45
