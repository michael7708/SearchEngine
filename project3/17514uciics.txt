informatics 43 spring 2009 midterm study guide 
midterm study guide 
informatics
43
spring
2009
news
course
reference
schedule
course
project
code
examples
alex
informatics
43
spring
2009
midterm
study
guide
introduction
study
guide
summary
material
covered
lecture
thusfar
midterm
will
focused
lecture
material
assigned
readings
focus
guide
material
covered
lecture
best
advice
studying
focus
attention
much
goal
write
exam
depend
solely
ability
memorize
terms
definitions
facts
instead
much
interested
whether
understand
things
way
ability
combine
concepts
learned
novel
ways
yet
consider
lecture
point
study
guide
intended
replacement
lectures
notes
possible
something
discussed
class
will
left
study
guide
still
fair
game
exam
trying
cheat
purpose
study
guide
guide
enjoy
background
course
primarily
software
engineering
term
software
engineering
includes
word
engineering
immediately
evokes
ideas
building
things
solve
real
problemsworking
within
real
constraints
many
people
much
time
much
money
evolving
build
time
solves
new
problems
many
similar
definitions
software
engineering
one
following
software
engineering
application
systematic
disciplined
quantifiable
approach
development
operation
maintenance
software
words
stand
definition
systematic
just
going
process
willy
nilly
plan
disciplined
adhere
plan
various
best
practices
times
quantifiable
aspects
development
process
can
measure
purposes
knowing
well
might
improve
whether
attempted
improvements
worked
operation
maintenance
work
done
ship
first
version
keep
running
addressing
problems
come
adding
features
solve
new
problems
move
realm
programming
realm
software
engineering
scale
sizes
projects
programming
large
opposed
programming
small
programming
large
includes
combination
multiple
people
multiple
versions
multiple
years
multiple
related
products
basic
activities
software
engineering
include
determining
requirements
systemorganizing
teams
build
system
cooperativelydefining
overall
architecture
systembreaking
larger
architecture
modulesimplementing
individual
modulesintegrating
modules
togethertesting
throughout
process
just
endwriting
documentationconfiguration
management
process
software
said
go
lifecycle
various
activities
done
various
points
time
idealized
view
lifecycle
looks
something
like
embarking
new
software
engineering
project
need
decide
process
general
process
strategy
organizing
project
answers
questions
like
order
will
major
tasks
done
will
major
tasks
information
will
exchange
work
broad
agreement
real
world
software
development
process
used
virtually
anywhere
work
will
process
least
slightly
different
processes
use
anywhere
else
partly
software
relatively
young
discipline
partly
different
processes
work
better
worse
depending
situation
many
people
much
time
well
customers
understand
needs
built
processes
generally
fit
one
couple
categories
heavyweight
planning
driven
processes
careful
plan
everything
thoroughly
lightweight
agile
processes
accept
things
change
often
spend
less
time
planning
time
building
taking
care
work
way
allows
us
change
course
discover
need
spectrum
possible
processes
heavyweight
one
end
lightweight
discussed
two
extremes
lecture
waterfall
model
agile
methods
waterfall
model
waterfall
model
one
well
known
process
model
engineering
software
breaks
project
phases
phase
one
activities
idealized
view
software
lifecycle
shown
phase
output
combination
documentation
code
output
one
phase
becomes
input
next
phase
outputs
depicted
diagram
requirements
engineering
¡÷
requirements
specificationdesign
¡÷
design
specificationimplementation
¡÷
code
program
level
documentationtesting
¡÷
working
code
accurate
program
level
documentation
can
think
design
phase
two
separate
sub
phases
architectural
design
focused
understanding
major
modules
interactions
detailed
design
focused
understanding
design
module's
internals
classes
methods
etc
reached
maintenance
evolution
phase
focus
keeping
system
running
finding
new
business
problems
solved
modifications
product
find
new
business
problems
can
embark
waterfall
style
project
make
modifications
verification
validation
two
additional
tasks
need
perform
step
waterfall
model
verification
validation
sometimes
referred
sound
similar
validation
ensures
attempt
made
address
implement
requirements
part
program
design
can
traced
back
particular
requirement
can
summed
question
building
right
system
verification
ensures
requirements
implemented
designed
correctly
can
summed
question
building
system
right
verification
validation
every
step
example
verification
requirements
engineering
since
designed
implemented
anything
yet
testing
model
testing
incorporated
throughout
waterfall
process
throughout
process
test
plans
part
output
phase
describing
testing
will
need
done
subsequently
requirements
engineering
¡÷
acceptance
test
planarchitectural
design
¡÷
integration
test
plandetailed
design
¡÷
unit
test
plan
one
way
represent
relationship
pictorially
often
called
model
depicts
waterfall
model
along
related
forms
testing
planned
early
performed
later
assessment
waterfall
model
waterfall
model
works
beautifully
ideal
world
always
complete
phase
correctly
first
time
reality
course
need
way
backtrack
previous
steps
necessary
cost
backtracking
higher
back
go
example
discovering
incorrect
requirement
testing
phase
requires
us
revisit
requirements
specification
design
documentation
program
along
relevant
test
plans
surprisingly
waterfall
model
significant
downsides
practice
assumed
perfect
information
available
perform
perfectly
step
customers
will
know
exactly
want
requirements
engineering
phase
designers
will
anticipate
possible
problems
design
phase
implementers
make
mistakes
implementation
phase
testers
miss
problems
testing
phase
later
discover
bug
expensive
fix
phases
revisit
documentation
alter
people
involved
need
backtrack
often
working
multiple
phases
simultaneously
makes
difficult
track
progress
given
time
might
done
phases
even
though
working
agile
methods
waterfall
model
represents
one
extreme
along
spectrum
software
development
processes
one
planning
king
act
know
exactly
going
opposite
extreme
set
processes
called
agile
methods
agile
methods
arise
basic
idea
change
inevitable
mistakes
made
throughout
process
need
cleaned
always
perfect
information
available
make
decisions
customers
change
minds
need
time
customers'
actual
needs
really
change
business
processes
altered
organization
grows
applicable
laws
change
number
variants
agile
methods
extreme
programming
scrum
though
generally
built
according
set
principles
principles
laid
document
called
manifesto
agile
software
development
also
known
agile
manifesto
important
part
reads
follows
uncovering
better
ways
developing
software
helping
others
work
come
value
individuals
interactions
processes
toolsworking
software
comprehensive
documentationcustomer
collaboration
contract
negotiationresponding
change
following
plan
value
items
right
value
items
left
agile
methods
following
properties
involve
customer
throughout
process
central
tenet
least
one
customer
representative
full
fledged
member
team
build
complete
working
subsets
system
often
every
weeks
many
cases
subsets
obviously
incomplete
actual
requirements
addressed
correctly
iteration
focus
people
interactions
teams
often
work
together
one
large
room
facilitate
interactions
pair
programming
sense
used
prior
coursework
often
used
encourage
looking
code
smells
refactoring
soon
smells
develop
example
duplicate
code
eliminated
found
poor
design
choices
revisited
soon
clear
can
improved
require
testing
throughout
process
much
testing
automated
possible
generate
much
documentation
heavyweight
processes
requirements
often
written
index
cards
electronic
equivalent
code
tests
general
documentation
want
know
something
works
look
code
importantly
tests
extreme
programming
extreme
programming
xp
example
agile
method
centered
around
set
practices
small
releases
version
much
different
one
preceded
planning
game
determining
scope
next
release
done
quickly
rather
attempting
define
everything
need
just
develop
small
list
things
know
need
simple
design
creativity
cleverness
frowned
upon
simpler
clearer
always
considered
better
testing
unit
tests
written
code
will
make
product
refactoring
design
changed
necessary
without
affecting
behavior
refactoring
automated
whenever
possible
pair
programming
code
makes
product
written
pairs
reduce
probability
mistakes
collective
ownership
anyone
can
change
anything
given
time
40
hour
week
long
weeks
exception
rather
rule
since
long
weeks
tend
lead
tired
developers
leads
mistakes
will
expensive
fix
later
site
customer
customer
representative
full
fledged
memnber
team
available
times
software
quality
like
build
quality
software
software
quality
shooting
quality
software
meets
requirements
solves
business
problem
user
friendly
user
interface
safe
harm
people
property
runs
available
hardware
measuring
quality
empirically
difficult
proposition
despite
much
work
area
last
decades
measurements
can
automate
process
deciding
whether
achieved
quality
mean
attributes
quality
software
tends
know
recognize
attributes
use
guidelines
work
correctness
system
meet
requirements
fulfill
objectives
reliability
system
work
times
suffer
frequent
bugs
efficiency
system
require
reasonable
amount
resources
time
memory
processing
power
energy
security
system
prevent
unauthorized
users
accessing
information
allow
users
access
information
able
see
usability
possible
learn
use
system
relatively
short
amount
time
possible
perform
tasks
minimal
amount
effort
maintainability
simple
locate
fix
bugs
system
flexibility
possible
modify
system
easily
can
adapted
new
requirements
testability
difficult
test
system
portability
easy
move
system
one
operating
environment
hardware
operating
system
another
reusability
can
parts
system
reused
others
interoperability
can
system
integrated
easily
systems
fault
tolerance
well
system
survive
bugs
problems
safety
software
harm
people
organizations
software
property
environment
factors
trade
others
sometimes
efficiency
harms
maintainability
testability
reusability
requirements
engineering
requirements
engineering
process
analyzing
customer's
problem
gaining
understanding
system
solve
documenting
understanding
checking
accuracy
understanding
product
generated
requirements
engineering
called
requirements
specification
details
current
understanding
requirements
system
first
decide
meant
requirement
requirement
condition
capability
needed
user
solve
problem
achieve
objective
something
system
able
constraint
system
must
meet
requirements
necessary
musts
system
many
requirements
practice
negotiable
requirements
engineering
process
characterized
least
partly
need
address
concerns
many
stakeholders
stakeholder
anyone
concerned
system
way
developers
will
build
systemtesters
will
ensure
system
meets
specificationsend
users
will
use
system
completedmanagers
end
users
responsible
workregulators
will
ensure
system
meets
legal
requirementsdomain
experts
give
essential
background
information
application
domain
different
stakeholders
bring
different
kinds
requirements
table
requirements
can
even
conflict
example
youtube
requirement
people
allowed
upload
videos
ideally
can
upload
video
like
copyright
holders
however
view
requirement
differently
requirements
engineering
comprised
four
tasks
requirements
elicitation
interact
users
customers
etc
gain
understanding
requirements
requirements
specification
write
understanding
requirements
validation
verification
customers
agree
upon
understanding
requirements
negotiation
negotiate
various
stakeholders
requirements
conflict
requirements
elicitation
variety
techniques
can
used
elicit
requirements
including
interviews
brainstorming
surveys
questionnaires
task
analysis
ethnography
prototyping
choose
techniques
based
need
interact
need
know
requirements
specification
requirements
specification
document
describes
complete
set
known
requirements
software
engineering
project
good
requirements
specification
several
attributes
correct
course
first
foremost
want
specification
reflect
actual
needs
users
unambiguous
choose
clearest
least
ambiguous
language
possible
difficult
writing
natural
language
like
english
natural
languages
inherently
ambiguous
formal
languages
can
used
write
requirements
wide
use
complete
include
every
requirement
discussed
negotiated
might
still
included
future
directions
section
consistent
requirements
conflict
prioritized
requirements
prioritized
clear
important
others
must
verifiable
testable
possible
verify
requirement
can
met
need
specific
modifiable
easy
make
changes
specification
techniques
make
easier
modify
code
apply
well
avoiding
duplication
information
categorization
organization
traceable
possible
trace
requirements
forward
backward
given
unique
identifiers
use
identifiers
elsewhere
process
writing
requirements
specification
want
focus
example
want
avoid
implementation
bias
whenever
possible
building
web
based
system
underlying
technology
choose
java
ee
php
net
asp
essentially
irrelevant
either
way
web
site
web
site
kinds
requirements
can
categorize
requirements
many
ways
one
way
lecture
separate
functional
non
functional
requirements
functional
requirements
define
specific
behavior
system
non
functional
requirements
define
additional
requirements
behavior
system
supports
performance
security
cost
usability
etc
acceptance
test
plans
part
requirements
engineering
process
draw
acceptance
test
plan
details
system
will
tested
ensure
acceptable
customer
various
scenarios
will
described
relatively
open
ended
terms
since
want
avoid
implementation
bias
successful
completion
indicates
system
ready
delivered
design
requirements
agreed
upon
time
begin
working
design
system
design
many
faceted
task
whose
complexity
rises
substantially
complexity
system
developed
one
right
way
design
software
many
well
understood
lessons
best
practices
recurring
problems
well
known
solution
patterns
known
qualities
know
good
designs
generally
bad
designs
generally
lack
can
say
design
comes
two
flavors
architectural
design
focuses
big
picture
module
design
focuses
details
like
classes
methods
number
goals
trying
achieve
design
phase
decomposing
problem
modulesdeciding
architectures
arranging
modulesdeveloping
plan
team
will
work
modulesestimating
costdetermining
external
systems
need
interface
itvisualizing
intangibles
using
modeling
diagrams
etc
moduality
software
generally
built
many
people
generally
many
versions
lifetime
facts
pose
issues
need
solve
solution
modularity
pefer
decompose
system
collection
subsystems
good
modules
least
three
characteristics
high
cohesion
internal
parts
closely
related
low
coupling
modules
rely
little
possible
information
hiding
modules
hide
design
implementation
decisions
hiding
mean
modules
way
depending
decisions
depend
decisions
can
change
minds
without
breaking
modules
qualities
good
design
hard
define
precisely
good
design
know
desirable
qualities
good
designs
rigor
requirements
addressed
separation
concerns
modules
solve
single
problem
can
written
tested
independently
anticipation
change
possible
inject
new
functionality
module
minimal
impact
incrementality
possible
work
software
piecemeal
fashion
opposed
build
many
pieces
able
test
uml
unified
modeling
language
uml
collection
kinds
diagrams
can
use
describe
design
software
system
different
diagrams
address
different
parts
design
spent
fair
amount
time
talking
one
diagrams
uml
class
diagrams
discussion
slides
topic
show
various
notations
used
uml
class
diagrams
use
cases
another
way
view
design
terms
problems
system
will
need
solve
scenarios
system
will
used
solve
use
cases
way
describing
behavior
system
points
view
set
actors
actors
entities
external
system
human
users
automated
systems
use
cases
described
sequence
events
actor
interacts
system
way
use
cases
focused
goals
actor
trying
achieve
can
system
help
achieve
define
details
like
user
interface
extent
can
describe
scenario
use
cases
will
eventually
used
consider
detailed
view
design
user
interface
design
module
design
many
arrangements
use
cases
one
arrangement
use
cases
broken
following
sections
name
give
use
case
name
short
identifier
describes
requirements
addressed
requirements
addressed
use
case
goal
actors
going
try
achieve
case
described
brief
description
going
use
case
actors
actors
involved
preconditions
must
true
use
case
can
executed
triggers
forces
cause
use
case
executed
user
wanting
something
something
happens
repeating
interval
per
hour
sequence
events
description
sequence
events
will
lead
goal
achieved
postconditions
will
true
use
case
executed
example
use
case
wrote
lecture
follows
name
adding
student
systemrequirements
addressed
st
2goal
add
new
student
arrive
first
interim
counseling
meeting
brief
description
students
automatically
entered
system
student
arrives
first
interim
counseling
meeting
cco
counselors
will
need
gather
identifying
information
student
enter
system
student
can
subsequently
scheduled
courses
actors
cco
counselor
studentpreconditions
student
enrolled
classes
university
previously
triggers
student
arrives
first
ever
counseling
appointment
sequence
events
student
arrives
cco
meeting
cco
counselor
student
provides
student
id
cco
counselor
cco
counselor
logs
system
cco
counselor
looks
student
id
determines
student
new
cco
counselor
asks
student
identifying
information
see
requirement
st
1
cco
counselor
enters
identifying
information
student
system
cco
counselor
saves
changes
postconditions
student's
information
will
stored
system
architectural
styles
start
attack
larger
scale
problems
becomes
difficult
discover
methodology
arranging
modules
interactions
luckily
kinds
problems
recur
good
architectural
solutions
designed
proven
useful
solutions
called
architectural
styles
architectural
styles
represent
success
stories
work
previous
designers
understand
use
appropriate
avoid
going
process
trial
error
previous
designers
endured
order
find
design
well
known
architectural
styles
hierarchy
main
program
subroutines
set
modules
relationships
calls
form
hierarchy
useful
style
use
writing
single
program
though
lot
interesting
software
built
collection
programs
abstract
data
type
abstract
data
type
adt
set
data
set
operations
safely
manipulating
data
adts
sense
allow
us
extend
programming
language
implementing
concepts
built
language
int
boolean
types
might
available
us
throughout
system
examples
include
datetime
class
represents
point
time
timespan
class
represents
duration
time
money
class
represents
currency
implicit
invocation
modules
communicate
modules
sending
signals
sending
modules
aware
receivers
sometimes
call
bus
used
carry
signals
one
module
another
style
can
lead
flexible
design
can
mix
match
components
easily
way
guis
work
java
components
buttons
react
clicked
calling
method
set
listeners
objects
interested
knowing
button
clicked
button's
implementation
depend
listeners
onl
mechanism
notify
client
server
connections
modules
remote
procedure
calls
meaning
done
across
network
hence
word
remote
otherwise
lot
like
procedure
calls
parameters
passed
result
returned
explicit
distinction
server
module
provides
service
client
consumer
service
web
browsers
interact
web
servers
way
browsers
send
particularly
formatted
request
servers
send
back
particularly
formatted
responses
repository
blackboard
central
repository
database
holds
data
modules
surround
repository
share
data
changes
made
one
module
published
repository
changes
can
picked
pushed
modules
style
extremely
common
lots
real
systems
databases
extremely
common
examples
include
web
sites
dynamic
content
enterprise
systems
source
control
systems
peer
peer
increasingly
common
approach
solving
certain
kinds
problems
modules
interact
generally
across
network
none
anointed
clients
servers
instead
peers
meaning
equal
rights
responsibilities
peers
exchange
information
systematic
fashion
collaborating
trying
solve
kind
problem
bittorrent
peer
peer
protocol
sharing
files
amongst
many
people
splitting
file
many
smaller
chunks
peers
trade
chunks
already
great
example
pipes
filters
series
independent
sequential
transformations
made
data
output
one
module
input
next
module
modules
little
state
simply
know
take
given
affect
kind
change
approach
call
modules
filters
connections
modules
pipes
approach
can
lead
flexible
architectures
output
system
radically
changed
simply
rearranging
filters
adding
one
removing
one
changing
order
layered
modules
arranged
layers
modules
one
layer
use
modules
layer
directly
say
layer
hides
details
layers
work
layers
good
way
preventing
particular
complexities
pervading
far
system
detail
handled
one
layer
hidden
away
layer
layers
need
know
networks
almost
always
implemented
way
different
arrangements
layers
used
practiced
layered
architectures
ubiquitous
necessarily
case
one
architectural
style
whole
project
often
combine
together
