fielding dissertation chapter 2 network based application architectures 
chapter 2 network based application architectures 
top
prev
next
chapter
2
network
based
application
architectures
chapter
continues
discussion
background
material
focusing
network
based
application
architectures
describing
styles
can
used
guide
architectural
design
2
1
scope
architecture
found
multiple
levels
within
software
systems
dissertation
examines
highest
level
abstraction
software
architecture
interactions
among
components
capable
realized
network
communication
limit
discussion
styles
network
based
application
architectures
order
reduce
dimensions
variance
among
styles
studied
2
1
1
network
based
vs
distributed
primary
distinction
network
based
architectures
software
architectures
general
communication
components
restricted
message
passing
6
equivalent
message
passing
efficient
mechanism
can
selected
run
time
based
location
components
128
tanenbaum
van
renesse
127
make
distinction
distributed
systems
network
based
systems
distributed
system
one
looks
users
like
ordinary
centralized
system
runs
multiple
independent
cpus
contrast
network
based
systems
capable
operation
across
network
necessarily
fashion
transparent
user
cases
desirable
user
aware
difference
action
requires
network
request
one
satisfiable
local
system
particularly
network
usage
implies
extra
transaction
cost
133
dissertation
covers
network
based
systems
limiting
candidate
styles
preserve
transparency
user
2
1
2
application
software
vs
networking
software
another
restriction
scope
dissertation
limit
discussion
application
architectures
excluding
operating
system
networking
software
architectural
styles
use
network
system
support
process
control
styles
53
applications
represent
business
aware
functionality
system
131
application
software
architecture
abstraction
level
overall
system
goals
user
action
representable
functional
architectural
properties
example
hypermedia
application
must
concerned
location
information
pages
performing
requests
rendering
data
streams
contrast
networking
abstraction
goal
move
bits
one
location
another
without
regard
bits
moved
application
level
can
evaluate
design
trade
offs
based
number
interactions
per
user
action
location
application
state
effective
throughput
data
streams
opposed
potential
throughput
single
data
stream
extent
communication
performed
per
user
action
etc
2
2
evaluating
design
application
architectures
one
goals
dissertation
provide
design
guidance
task
selecting
creating
appropriate
architecture
given
application
domain
keeping
mind
architecture
realization
architectural
design
design
architecture
can
evaluated
run
time
characteristics
obviously
prefer
evaluation
mechanism
applied
candidate
architectural
designs
implement
unfortunately
architectural
designs
notoriously
hard
evaluate
compare
objective
manner
like
artifacts
creative
design
architectures
normally
presented
completed
work
design
simply
sprung
fully
formed
architect's
mind
order
evaluate
architectural
design
need
examine
design
rationale
behind
constraints
places
system
compare
properties
derived
constraints
target
application's
objectives
first
level
evaluation
set
application's
functional
requirements
example
makes
sense
evaluate
design
process
control
architecture
requirements
distributed
hypermedia
system
since
comparison
moot
architecture
function
although
will
eliminate
candidates
cases
will
remain
many
architectural
designs
capable
meeting
application's
functional
needs
remainder
differ
relative
emphasis
non
functional
requirements
degree
architecture
support
various
non
functional
architectural
properties
identified
necessary
system
since
properties
created
application
architectural
constraints
possible
evaluate
compare
different
architectural
designs
identifying
constraints
within
architecture
evaluating
set
properties
induced
constraint
comparing
cumulative
properties
design
properties
required
application
described
previous
chapter
architectural
style
coordinated
set
architectural
constraints
given
name
ease
reference
architectural
design
decision
can
seen
application
style
since
addition
constraint
may
derive
new
style
can
think
space
possible
architectural
styles
derivation
tree
root
null
style
empty
set
constraints
constraints
conflict
styles
can
combined
form
hybrid
styles
eventually
culminating
hybrid
style
represents
complete
abstraction
architectural
design
architectural
design
can
therefore
analyzed
breaking
set
constraints
derivation
tree
evaluating
cumulative
effect
constraints
represented
tree
understand
properties
induced
basic
style
traversing
derivation
tree
gives
us
understanding
overall
design's
architectural
properties
specific
needs
application
can
matched
properties
design
comparison
becomes
relatively
simple
matter
identifying
architectural
design
satisfies
desired
properties
application
care
must
taken
recognize
effects
one
constraint
may
counteract
benefits
constraint
nevertheless
possible
experienced
software
architect
build
derivation
tree
architectural
constraints
given
application
domain
use
tree
evaluate
many
different
architectural
designs
applications
within
domain
thus
building
derivation
tree
provides
mechanism
architectural
design
guidance
evaluation
architectural
properties
within
tree
styles
specific
needs
particular
application
domain
impact
given
constraint
often
dependent
application
characteristics
example
pipe
filter
style
enables
several
positive
architectural
properties
used
within
system
requires
data
transformations
components
whereas
add
nothing
overhead
system
consists
control
messages
since
rarely
useful
compare
architectural
designs
across
different
application
domains
simplest
means
ensuring
consistency
make
tree
domain
specific
design
evaluation
frequently
question
choosing
trade
offs
perry
wolf
105
describe
method
recognizing
trade
offs
explicitly
placing
numeric
weight
property
indicate
relative
importance
architecture
thus
providing
normalized
metric
comparing
candidate
designs
however
order
meaningful
metric
weight
carefully
chosen
using
objective
scale
consistent
across
properties
practice
scale
exists
rather
architect
fiddle
weight
values
result
matches
intuition
prefer
present
information
architect
readily
viewable
form
let
architect's
intuition
guided
visual
pattern
will
demonstrated
next
chapter
2
3
architectural
properties
key
interest
section
describes
architectural
properties
used
differentiate
classify
architectural
styles
dissertation
intended
comprehensive
list
included
properties
clearly
influenced
restricted
set
styles
surveyed
additional
properties
sometimes
referred
software
qualities
covered
textbooks
software
engineering
58
bass
et
al
9
examine
qualities
regards
software
architecture
2
3
1
performance
one
main
reasons
focus
styles
network
based
applications
component
interactions
can
dominant
factor
determining
user
perceived
performance
network
efficiency
since
architectural
style
influences
nature
interactions
selection
appropriate
architectural
style
can
make
difference
success
failure
deployment
network
based
application
performance
network
based
application
bound
first
application
requirements
chosen
interaction
style
followed
realized
architecture
finally
implementation
component
words
software
avoid
basic
cost
achieving
application
needs
application
requires
data
located
system
processed
system
software
avoid
moving
data
likewise
architecture
efficient
interaction
style
allows
cost
multiple
interactions
move
data
less
single
interaction
finally
regardless
quality
architecture
interaction
can
take
place
faster
component
implementation
can
produce
data
recipient
can
consume
data
2
3
1
1
network
performance
network
performance
measures
used
describe
attributes
communication
throughput
rate
information
including
application
data
communication
overhead
transferred
components
overhead
can
separated
initial
setup
overhead
per
interaction
overhead
distinction
useful
identifying
connectors
can
share
setup
overhead
across
multiple
interactions
amortization
bandwidth
measure
maximum
available
throughput
given
network
link
usable
bandwidth
refers
portion
bandwidth
actually
available
application
styles
impact
network
performance
influence
number
interactions
per
user
action
granularity
data
elements
style
encourages
small
strongly
typed
interactions
will
efficient
application
involving
small
data
transfers
among
known
components
will
cause
excessive
overhead
within
applications
involve
large
data
transfers
negotiated
interfaces
likewise
style
involves
coordination
multiple
components
arranged
filter
large
data
stream
will
place
application
primarily
requires
small
control
messages
2
3
1
2
user
perceived
performance
user
perceived
performance
differs
network
performance
performance
action
measured
terms
impact
user
front
application
rather
rate
network
moves
information
primary
measures
user
perceived
performance
latency
completion
time
latency
time
period
initial
stimulus
first
indication
response
latency
occurs
several
points
processing
network
based
application
action
1
time
needed
application
recognize
event
initiated
action
2
time
required
setup
interactions
components
3
time
required
transmit
interaction
components
4
time
required
process
interaction
components
5
time
required
complete
sufficient
transfer
processing
result
interactions
application
able
begin
rendering
usable
result
important
note
although
3
5
represent
actual
network
communication
five
points
can
impacted
architectural
style
furthermore
multiple
component
interactions
per
user
action
additive
latency
unless
take
place
parallel
completion
amount
time
taken
complete
application
action
completion
time
dependent
upon
aforementioned
measures
difference
action's
completion
time
latency
represents
degree
application
incrementally
processing
data
received
example
web
browser
can
render
large
image
received
provides
significantly
better
user
perceived
performance
one
waits
entire
image
completely
received
prior
rendering
even
though
experience
network
performance
important
note
design
considerations
optimizing
latency
will
often
side
effect
degrading
completion
time
vice
versa
example
compression
data
stream
can
produce
efficient
encoding
algorithm
samples
significant
portion
data
producing
encoded
transformation
resulting
shorter
completion
time
transfer
encoded
data
across
network
however
compression
performed
fly
response
user
action
buffering
large
sample
transfer
may
produce
unacceptable
latency
balancing
trade
offs
can
difficult
particularly
unknown
whether
recipient
cares
latency
web
browsers
completion
web
spiders
2
3
1
3
network
efficiency
interesting
observation
network
based
applications
best
application
performance
obtained
using
network
essentially
means
efficient
architectural
styles
network
based
application
can
effectively
minimize
use
network
possible
reuse
prior
interactions
caching
reduction
frequency
network
interactions
relation
user
actions
replicated
data
disconnected
operation
removing
need
interactions
moving
processing
data
closer
source
data
mobile
code
impact
various
performance
issues
often
related
scope
distribution
application
benefits
style
local
conditions
may
become
drawbacks
faced
global
conditions
thus
properties
style
must
framed
relation
interaction
distance
within
single
process
across
processes
single
host
inside
local
area
network
lan
spread
across
wide
area
network
wan
additional
concerns
become
evident
interactions
across
wan
single
organization
involved
compared
interactions
across
internet
involving
multiple
trust
boundaries
2
3
2
scalability
scalability
refers
ability
architecture
support
large
numbers
components
interactions
among
components
within
active
configuration
scalability
can
improved
simplifying
components
distributing
services
across
many
components
decentralizing
interactions
controlling
interactions
configurations
result
monitoring
styles
influence
factors
determining
location
application
state
extent
distribution
coupling
components
scalability
also
impacted
frequency
interactions
whether
load
component
distributed
evenly
time
occurs
peaks
whether
interaction
requires
guaranteed
delivery
best
effort
whether
request
involves
synchronous
asynchronous
handling
whether
environment
controlled
anarchic
can
trust
components
2
3
3
simplicity
primary
means
architectural
styles
induce
simplicity
applying
principle
separation
concerns
allocation
functionality
within
components
functionality
can
allocated
individual
components
substantially
less
complex
will
easier
understand
implement
likewise
separation
eases
task
reasoning
overall
architecture
chosen
lump
qualities
complexity
understandability
verifiability
general
property
simplicity
since
go
hand
hand
network
based
system
applying
principle
generality
architectural
elements
also
improves
simplicity
since
decreases
variation
within
architecture
generality
connectors
leads
middleware
22
2
3
4
modifiability
modifiability
ease
change
can
made
application
architecture
modifiability
can
broken
evolvability
extensibility
customizability
configurability
reusability
described
particular
concern
network
based
systems
dynamic
modifiability
98
modification
made
deployed
application
without
stopping
restarting
entire
system
even
possible
build
software
system
perfectly
matches
requirements
users
requirements
will
change
time
just
society
changes
time
components
participating
network
based
application
may
distributed
across
multiple
organizational
boundaries
system
must
prepared
gradual
fragmented
change
old
new
implementations
coexist
without
preventing
new
implementations
making
use
extended
capabilities
2
3
4
1
evolvability
evolvability
represents
degree
component
implementation
can
changed
without
negatively
impacting
components
static
evolution
components
generally
depends
well
architectural
abstraction
enforced
implementation
thus
something
unique
particular
architectural
style
dynamic
evolution
however
can
influenced
style
includes
constraints
maintenance
location
application
state
techniques
used
recover
partial
failure
conditions
distributed
system
133
can
used
support
dynamic
evolution
2
3
4
2
extensibility
extensibility
defined
ability
add
functionality
system
108
dynamic
extensibility
implies
functionality
can
added
deployed
system
without
impacting
rest
system
extensibility
induced
within
architectural
style
reducing
coupling
components
exemplified
event
based
integration
2
3
4
3
customizability
customizability
refers
ability
temporarily
specialize
behavior
architectural
element
can
perform
unusual
service
component
customizable
can
extended
one
client
component's
services
without
adversely
impacting
clients
component
50
styles
support
customization
may
also
improve
simplicity
scalability
since
service
components
can
reduced
size
complexity
directly
implementing
frequent
services
allowing
infrequent
services
defined
client
customizability
property
induced
remote
evaluation
code
demand
styles
2
3
4
4
configurability
configurability
related
extensibility
reusability
refers
post
deployment
modification
components
configurations
components
capable
using
new
service
data
element
type
pipe
filter
code
demand
styles
two
examples
induce
configurability
configurations
components
respectively
2
3
4
5
reusability
reusability
property
application
architecture
components
connectors
data
elements
can
reused
without
modification
applications
primary
mechanisms
inducing
reusability
within
architectural
styles
reduction
coupling
knowledge
identity
components
constraining
generality
component
interfaces
uniform
pipe
filter
style
exemplifies
types
constraints
2
3
5
visibility
styles
can
also
influence
visibility
interactions
within
network
based
application
restricting
interfaces
via
generality
providing
access
monitoring
visibility
case
refers
ability
component
monitor
mediate
interaction
two
components
visibility
can
enable
improved
performance
via
shared
caching
interactions
scalability
layered
services
reliability
reflective
monitoring
security
allowing
interactions
inspected
mediators
network
firewalls
mobile
agent
style
example
lack
visibility
may
lead
security
concerns
usage
term
visibility
differs
ghezzi
et
al
58
referring
visibility
development
process
rather
product
2
3
6
portability
software
portable
can
run
different
environments
58
styles
induce
portability
include
move
code
along
data
processed
virtual
machine
mobile
agent
styles
constrain
data
elements
set
standardized
formats
2
3
7
reliability
reliability
within
perspective
application
architectures
can
viewed
degree
architecture
susceptible
failure
system
level
presence
partial
failures
within
components
connectors
data
styles
can
improve
reliability
avoiding
single
points
failure
enabling
redundancy
allowing
monitoring
reducing
scope
failure
recoverable
action
2
4
summary
chapter
examined
scope
dissertation
focusing
network
based
application
architectures
describing
styles
can
used
guide
architectural
design
also
defined
set
architectural
properties
will
used
throughout
rest
dissertation
comparison
evaluation
architectural
styles
next
chapter
presents
survey
common
architectural
styles
network
based
application
software
within
classification
framework
evaluates
style
according
architectural
properties
induce
applied
architecture
prototypical
network
based
hypermedia
system
top
prev
next
roy
thomas
fielding
2000
rights
reserved
reference
work
