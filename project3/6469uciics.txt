nisc technology 
nisc features 
nisc
technology
toolset
rtl
datapath
generator
selector
generates
selects
datapath
given
applicationconverts
gnr
generic
netlist
representation
datapath
nisc
cycle
accurate
compiler
compiles
application
given
datapathconverts
cw
control
words
stream
controlling
components
clock
cycle
rtl
generator
generates
rtl
input
fpga
asicconverts
gnr
cw
rtl
datapath
refinement
refine
datapath
improve
quality
code
refinement
refine
application
improve
quality
nisc
technology
design
flow
nisc
technology
designer
can
iteratively
refine
get
satisfactory
results
architecture
selection
can
selected
set
pre
designed
templates
optimized
specific
application
domain
customized
architecture
can
generated
specific
application
specifying
netlist
components
profiling
analyzing
application
compilation
compiler
maps
input
code
given
architecture
rtl
generation
rtl
generator
translates
nisc
netlist
output
compiler
synthesizable
rtl
synthesis
final
result
can
simulated
synthesized
final
implementation
fpga
asic
refinement
analysis
application
architecture
can
redefined
desired
results
achieved
nisc
technology
strengths
top
bottom
design
flow
standard
behavioral
synthesis
high
level
synthesis
hls
tools
provide
top
design
flow
high
level
low
level
rtl
asip
approaches
provide
bottom
design
flow
custom
instructions
using
application
nisc
provides
top
flow
generating
architecture
bottom
flow
providing
datapath
input
fast
predictable
path
implementation
using
behavioral
synthesis
change
application
will
result
many
changes
generated
rtl
way
predict
correlate
application
changes
changes
results
therefore
way
improve
unsatisfactory
results
trial
error
guesswork
using
asip
adding
new
custom
instruction
designer
either
use
hls
synthesis
datapath
controller
unpredictable
results
must
manually
time
consuming
nisc
enables
designers
control
every
aspect
design
designer
can
select
exact
points
improvement
quickly
example
directly
changing
gnr
description
architecture
designer
can
reduce
critical
path
delay
fix
complex
multiplexers
connections
consume
much
power
make
layout
unroutable
designer
controlled
design
space
explorationsince
tools
techniques
provide
fast
predictable
path
implementation
designer
can
best
explore
design
aspects
tool
provides
ones
designer
wants
since
datapath
can
input
nisc
technology
designer
can
explore
options
quality
metrics
selectively
example
designer
can
focus
dynamic
power
minimization
modifying
connections
gating
latching
datapath
description
quickly
see
effect
final
results
right
mixture
standard
languages
since
ansi
alone
enough
designing
complete
system
hls
tools
provide
extension
input
language
extensions
require
extra
effort
learning
additionally
prevent
use
unmodified
code
lock
designer
proprietary
tool
making
developed
algorithms
unusable
tools
nisc
technology
uses
standard
languages
designers
need
extra
training
can
use
favorite
development
tools
editors
debuggers
nisc
provides
seamless
way
combining
standard
verilog
pre
bound
functions
enabling
inclusion
low
level
verilog
code
inside
program
