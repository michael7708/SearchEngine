informatics 43 spring 2009 final exam study guide 
final exam study guide 
informatics
43
spring
2009
news
course
reference
schedule
course
project
code
examples
alex
informatics
43
spring
2009
final
exam
study
guide
introduction
study
guide
summary
material
covered
lecture
since
midterm
noted
final
exam
cumulative
though
will
emphasize
post
midterm
material
somewhat
pre
midterm
material
material
covered
course
fair
game
exam
sure
check
midterm
study
guide
rundown
material
covered
midterm
best
advice
studying
focus
attention
much
goal
write
exam
depend
solely
ability
memorize
terms
definitions
facts
instead
much
interested
whether
understand
things
way
ability
combine
concepts
learned
novel
ways
yet
consider
lecture
point
study
guide
intended
replacement
lectures
notes
possible
something
discussed
class
will
left
study
guide
still
fair
game
exam
trying
cheat
purpose
study
guide
guide
enjoy
assessing
design
quality
topic
covered
just
midterm
inadvertently
left
midterm
study
guide
added
since
remains
fair
game
final
exam
one
things
can
frustrating
software
design
difficult
assess
whether
design
good
one
much
coupling
much
little
cohesion
little
know
whether
concerns
separated
well
enough
unfortunately
one
metric
set
metrics
can
use
determine
black
white
whether
design
good
enough
well
known
techniques
allow
us
quantitatively
assess
certain
aspects
designs
notably
fair
amount
work
put
assessing
complexity
can
measure
complexity
design
know
something
quality
notably
know
things
like
whether
meets
requirements
can
test
things
separately
complexity
measurements
focus
choosing
attribute
contributes
complexity
design
measuring
something
attribute
two
kinds
attributes
can
focus
intra
module
attributes
attributes
single
module
inter
module
attributes
attributes
collection
modules
taken
together
intra
module
attributes
least
two
things
can
measure
module
want
assess
complexity
quantitatively
size
longer
modules
harder
understand
harder
maintain
likelier
bugs
measuring
size
tells
us
something
complexity
structure
write
something
determines
complexity
independent
size
can
measure
aspects
module's
structure
loops
statements
parameters
etc
measuring
size
simplest
way
measure
size
measure
lines
code
often
reported
thousands
lines
code
kloc
stands
kilo
ballpark
estimate
nearest
thousand
large
project
good
perfect
number
lines
code
simple
enough
metric
though
can
terribly
misleading
count
lines
containing
comments
layout
following
counted
one
line
two
four
done
done
checkiffinished
layout
issues
aside
fact
one
line
code
can
less
complex
int
0
size
fact
languages
compact
syntax
others
tend
say
java
accomplish
goal
ruby
python
example
layout
neutral
measurement
code
size
might
count
tokens
instead
lines
tokens
individual
words
symbols
meaning
programming
language
example
block
java
code
public
static
void
main
string
args
system
println
hello
world
total
21
tokens
public
static
void
main
string
args
system
println
hello
world
notably
absent
list
tokens
whitespace
spaces
blank
lines
tabs
comments
making
metric
nothing
program
laid
unfortunately
despite
deficiencies
lines
code
metric
seems
resonate
better
programmers
know
100
lines
code
feels
like
less
sense
1
000
tokens
feels
like
measuring
structure
measuring
size
module
ignores
fact
way
write
code
least
important
much
code
write
complexity
metrics
focus
structure
code
one
measurement
called
cyclomatic
complexity
cyclomatic
complexity
measurement
begins
building
control
flow
graph
depicts
possible
flows
control
one
line
code
another
example
consider
following
block
code
public
int
nonsensealgorithm
int
1
int
0
length
2
0
3
2
4
else
0
5
integer
min
value
else
6
2
7
return
1
line
either
decision
made
action
taken
numbered
starting
1
note
line
containing
method's
signature
curly
braces
line
containing
else
numbered
since
neither
decision
made
action
taken
lines
can
now
draw
control
flow
graph
depicting
numbered
line
numbered
circle
called
node
way
can
get
one
line
another
arrow
called
edge
connecting
two
nodes
example
control
flow
graph
look
like
cyclomatic
complexity
measurement
calculated
counting
nodes
edges
connected
subgraphs
connected
subgraphs
subset
nodes
completely
connected
look
nodes
reached
starting
line
1
following
edges
single
method
will
always
one
single
connected
subgraph
control
flow
graph
entire
class
five
methods
contain
five
connected
subgraphs
one
method
given
number
nodes
edges
connected
subgraphs
cyclomatic
complexity
cyclomaticcomplexity
1
example
seven
nodes
nine
edges
one
connected
subgraph
cyclomatic
complexity
cyclomaticcomplexity
9
7
1
1cyclomaticcomplexity
4
larger
numbers
indicate
higher
complexity
smaller
ones
example
larger
number
indicates
will
difficult
come
complete
set
test
cases
cover
possible
paths
control
flow
graph
inter
module
attributes
spend
time
topic
lecture
though
topic
covered
detail
textbook
unit
testing
test
driven
development
unit
testing
preparation
implementation
course
project
discussed
unit
testing
unit
testing
generally
done
performed
developers
implementation
module
goal
unit
testing
focus
microscope
individual
parts
program
individual
classes
even
individual
methods
evaluating
well
work
outside
context
rest
program
matter
much
unit
testing
perform
certain
entire
system
correct
even
unit
tests
pass
since
unit
testing
ignores
issues
arise
different
parts
program
integrated
together
provide
way
verify
individual
parts
work
condition
without
entire
system
certainly
context
understanding
cause
bug
much
simpler
testing
entire
system
another
benefit
unit
testing
positively
affects
design
quality
order
ensure
module
can
tested
isolation
will
tend
lower
coupling
better
separation
concerns
clearer
naming
unit
tests
written
program
developed
will
tend
stray
far
poor
design
since
writing
unit
tests
will
force
clean
sooner
rather
later
sooner
clean
design
module
easier
since
fewer
modules
depend
unit
testing
generally
done
automated
fashion
unit
tests
implemented
code
major
benefit
repeatability
can
now
run
tests
often
like
keeping
tests
long
run
way
detect
behavior
individual
modules
changed
way
causes
tests
fail
later
can
decide
whether
change
behavior
expected
case
test
longer
valid
case
broken
code
look
fixing
implemented
unit
tests
course
wrote
java
using
tool
called
junit
will
ask
implement
junit
based
tests
final
exam
though
may
ask
read
understand
see
code
example
lecture
details
test
driven
development
talked
lecture
test
driven
development
tdd
process
developing
programs
designs
simultaneously
centers
following
iterative
process
focused
allowing
take
short
steps
stable
ground
stable
ground
working
program
tests
prove
works
every
minutes
choose
feature
work
generally
something
simple
can
accomplish
minutes
write
test
verifies
feature
will
work
done
sense
experimenting
design
write
code
depends
like
way
design
works
experiment
can
change
cost
since
code
implements
yet
compile
test
watch
fail
succeed
sometimes
test
compile
write
minimum
amount
code
make
test
compile
note
minimum
means
sometimes
write
things
know
will
wrong
little
bit
farther
line
run
test
watch
fail
succeed
sometimes
test
failed
write
minimum
amount
code
make
test
pass
willing
write
code
know
will
wrong
later
since
goal
iteration
make
current
test
pass
keeping
old
tests
passing
well
run
test
hopefully
watch
succeed
test
failed
go
back
step
6
succeeded
stable
ground
iteration
also
consider
ways
can
improve
code
refactoring
refactoring
improves
design
program
without
changing
see
things
designed
better
duplicated
code
eliminated
names
improved
attack
problem
right
away
knowing
tests
can
run
time
want
know
whether
code
still
working
mess
refactoring
tests
will
tell
us
note
unit
tests
central
task
tdd
use
tdd
make
good
use
unit
tests
serialization
one
requirements
faced
implementation
course
project
saving
program's
data
file
loading
back
goal
program
stopped
restarted
without
data
lost
fairly
common
problem
well
known
terminology
describes
solution
say
serialization
process
taking
set
objects
turning
single
sequence
bytes
text
deserialization
process
taking
sequence
bytes
text
turning
set
copies
original
objects
started
first
technique
sounds
little
strange
actually
useful
note
file
consists
sequence
bytes
program
sends
receives
data
across
network
sequence
bytes
sent
received
serialization
deserialization
can
used
save
objects
file
load
back
can
used
send
objects
across
network
reconstruct
end
details
java's
built
implementation
serialization
beyond
scope
final
exam
like
understand
serialization
problem
solves
test
cases
test
coverage
metrics
general
way
completely
test
chunk
code
call
every
method
every
possible
set
inputs
verify
correct
ouptut
simply
number
possibilities
vast
even
relatively
simple
methods
instead
forced
choose
representative
set
test
cases
goal
cover
everything
interesting
chunk
code
tested
test
case
least
three
things
set
inputs
action
taken
expected
output
say
test
coverage
indication
thoroughly
set
tests
verify
correct
behavior
code
talked
lecture
test
coverage
metrics
quantitative
ways
assess
whether
set
test
cases
sufficient
particular
talked
ways
given
control
flow
graph
determine
whether
sufficiently
tested
code
represented
since
achieve
complete
testing
talked
three
different
goals
one
try
attain
three
different
test
coverage
metrics
requiring
thorough
test
coverage
last
node
coverage
every
node
control
flow
graph
reached
execution
least
one
tests
means
essentially
every
statement
program
reached
least
achieving
node
coverage
means
parts
program
never
tested
hand
achieving
node
coverage
often
sufficient
method
multiple
separate
statements
node
coverage
might
achieved
couple
tests
different
combinations
statements
tested
edge
coverage
every
edge
control
flow
graph
followed
execution
least
one
tests
means
every
branch
every
way
get
one
line
another
program
followed
least
thorough
node
coverage
since
considering
line
different
ways
reaching
line
likelier
see
problems
logic
way
especially
presence
many
statements
loops
path
coverage
every
path
control
flow
graph
followed
execution
least
one
tests
means
considering
every
possible
sequence
lines
follow
beginning
end
method
thorough
edge
coverage
since
considers
possible
ways
pass
edge
number
tests
required
achieve
path
coverage
explodes
exponentially
number
conditionals
increases
since
consider
every
possible
way
passing
conditionals
one
interesting
question
deal
loops
especially
might
potentially
run
many
times
even
forever
typical
way
deal
require
different
numbers
iterations
zero
possible
one
average
number
maximum
number
tools
can
automate
kinds
test
coverage
metrics
java
example
allows
instrumentation
code
triggered
inner
workings
java
virtual
machine
write
tool
builds
control
flow
graph
method
run
unit
tests
watching
nodes
edges
reached
tool
report
node
edge
path
coverage
us
percentage
80
nodes
reached
detailed
listing
especially
nodes
edges
paths
missed
quality
assurance
testing
many
organizations
department
group
called
quality
assurance
qa
tasked
name
states
assuring
quality
system
seen
quality
broad
term
encompassing
things
like
correctness
system
meets
stated
requirements
also
whether
requirements
right
ones
first
place
safe
say
issues
quality
often
crosscut
entire
organization
qa
teams
ones
spend
vast
majority
time
focused
assessing
generally
wise
qa
group
answer
different
people
organization
software
development
group
since
goals
often
oppose
one
another
management
level
champion
set
goals
example
hen
asked
ship
system
software
development
will
often
want
say
yes
even
answer
pressure
deliver
certain
date
important
qa
able
weigh
reasoned
opinion
answer
testing
one
primary
roles
qa
group
plan
perform
testing
spent
fair
amount
time
lecture
talking
testing
several
different
angles
testing
process
determining
whether
software
meets
specification
done
planning
executing
set
test
cases
goals
simple
detecting
presence
problems
identifying
cause
problems
standard
terminology
used
describe
problems
found
testing
error
mistake
made
person
working
software
systemfault
problem
software
arises
errorfailure
behavior
system
match
specifications
due
fault
note
errors
lead
faults
faults
lead
failures
failures
concerned
finding
find
also
diagnose
means
finding
correcting
fault
ideally
deciding
cause
error
might
able
introduce
measures
avoid
future
testing
best
done
throughout
project
different
kinds
testing
focused
different
levels
depth
done
different
times
unit
testing
commonly
done
developers
implementation
individual
modulesintegration
testing
focuses
testing
modules
interact
one
anotheracceptance
testing
user
acceptance
testing
users
determine
whether
software
meets
needs
white
box
vs
black
box
testing
can
distinguish
two
kinds
testing
focused
differently
white
box
testing
structural
testing
choose
test
cases
based
structure
code
unit
testing
form
white
box
testing
can
also
white
box
testing
devising
tests
complete
system
driven
code
want
test
black
box
testing
specification
based
testing
test
system
without
regard
source
code
experimenting
behavior
complete
system
test
cases
generally
selected
based
requirements
specification
tradeoff
difficulty
needing
understand
source
code
difficulty
systematically
choosing
automating
specification
based
tests
need
understand
source
code
white
box
testing
often
best
done
developers
black
box
testing
often
best
done
others
ingrained
bias
developers
can
overcome
equivalence
partitioning
test
matrices
whether
focused
white
box
black
box
testing
still
remains
problem
deciding
set
test
cases
rather
just
choosing
test
cases
somewhat
randomly
think
one
way
focus
minds
sure
covering
variety
interesting
circumstances
equivalence
partitioning
proceeds
according
following
steps
identify
set
inputs
maybe
possible
inputs
maybe
just
identify
basis
subdividing
input
examples
include
size
collection
order
collection's
elements
appear
conditions
may
may
true
user
already
logged
divide
set
inputs
subdomains
using
basis
subdomains
forms
equivalence
partition
meaning
input
subdomain
equivalent
sense
possible
input
member
one
subdomains
fine
overlap
select
representative
test
cases
subdomains
along
test
cases
belong
multiple
subdomains
whenever
possible
follow
procedure
many
interesting
bases
tend
good
set
test
cases
test
oracles
test
oracle
mechanism
deciding
whether
test
case
failed
succeeded
oracles
critical
testing
since
meaningful
test
cases
without
expected
output
create
test
oracles
depends
formality
specifications
specifications
formal
including
say
mathematical
formulas
can
use
formulas
automatically
generate
expected
output
say
test
oracle
set
formulas
variety
reasons
formal
specifications
relatively
rare
difficult
develop
harder
understand
expensive
generally
left
decide
expected
output
manually
cases
test
oracle
ultimately
us
staged
releases
user
testing
despite
team's
best
efforts
test
product
delivering
customers
generally
possible
team
test
every
possible
scenario
will
arise
customers
begin
using
system
users
may
needs
never
discovered
requirements
elicitation
may
respond
changing
business
requirements
trying
use
existing
system
differently
notorious
attempting
things
one
ever
imagined
increasingly
common
systems
staged
releases
sequence
pre
releases
distributed
users
confidence
level
pre
release
higher
previous
one
number
users
accepting
generally
rising
one
next
one
standard
nomenclature
following
sequence
pre
releases
evolved
fairly
common
one
alpha
alpha
testing
users
accept
version
either
incomplete
fully
tested
users
get
experiment
new
featurues
accepting
fact
software
will
always
perform
well
advertised
beta
beta
testing
generally
coincides
software
feature
complete
gone
substantial
testing
users
higher
level
confidence
alpha
release
though
still
issues
will
discovered
release
candidate
rc
used
denote
version
final
one
distributed
many
users
possible
understanding
final
version
will
exactly
unless
important
problems
found
rc
releases
quite
often
stable
almost
indistinguishable
final
product
version
control
systems
multiple
people
work
together
project
sometimes
physical
location
building
sometimes
geographically
distributed
coordination
issues
dealt
person
might
copy
project
machine
yet
changes
need
shared
person
can
see
results
others'
work
least
important
effort
required
manually
synchronize
effort
many
people
increases
much
linearly
number
people
increases
long
unmanageable
mess
unless
employ
tools
help
version
control
systems
sometimes
called
source
control
systems
source
control
management
systems
tools
help
solve
kind
problem
many
version
control
systems
popular
use
share
basic
philosophy
even
differ
sometimes
substantially
details
using
vcs
generally
central
repository
sense
repository
architectural
style
saw
earlier
quarter
complete
date
copy
system
stored
usually
along
date
version
stored
database
tracking
changes
made
system
becomes
possible
say
give
complete
copy
system's
source
code
also
say
give
complete
copy
system's
source
code
april
1
repository
may
available
intranet
within
organization
internet
depending
geographic
reach
project
whether
source
code
proprietary
users
connect
repository
want
get
latest
version
code
want
publish
changes
typical
operations
provided
vcs
check
generally
means
downloading
version
system
part
system
repository
systems
also
means
locking
one
files
one
else
can
publish
changes
though
rare
nowadays
check
commit
generally
means
publishing
changes
repository
others
can
see
changes
generally
grouped
set
related
changes
different
files
become
one
changeset
associated
changeset
generally
comment
sometimes
called
changelog
explains
changed
importantly
compare
allows
see
often
visually
version
file
differs
version
currently
available
repository
see
two
different
versions
repository
different
can
useful
help
understand
history
changes
made
particular
file
understand
scope
changes
currently
making
multiple
people
working
can
still
issues
even
vcs
involved
example
consider
following
scenario
developer
checks
version
10
file
java
begins
making
changes
assume
checking
means
locked
anyone
can
still
modify
developer
checks
version
10
file
java
also
begins
making
changes
developer
finishes
changes
commits
java
now
version
11
developer
finishes
changes
wants
commit
vcs
reports
version
java
now
repository
match
version
checked
point
developer
will
need
merge
changes
developer
b's
tools
help
kind
task
fully
automated
since
exists
possibility
two
sets
changes
incompatible
point
conversation
may
need
take
place
decision
can
made
next
issue
tracking
systems
issue
tracking
systems
bug
tracking
systems
repositories
track
various
issues
related
development
maintenance
software
system
along
user
interface
can
used
view
update
search
repository
issues
version
control
systems
many
issue
tracking
products
available
mostly
share
common
philosophy
differ
details
issues
generally
classified
number
ways
examples
follow
kind
bug
feature
request
design
changeby
status
opened
assigned
closed
finished
duplicate
existing
issueby
component
module
part
system
issue
relate
version
version
system
issue
relate
issues
also
generally
assigned
individuals
groups
assignment
changing
time
example
feature
request
might
first
assigned
business
analyst
decides
whether
request
fits
within
scope
system
negotiates
requirements
might
assigned
developer
implement
tester
test
finally
back
customer
acceptance
testing
finally
closed
integrating
issue
tracking
version
control
value
integrating
issue
tracking
system
version
control
system
example
every
issue
linked
changesets
source
code
changes
made
address
conversely
changesets
linked
back
issues
fuller
picture
history
system
can
beneficial
especially
large
project
people
joining
leaving
time
