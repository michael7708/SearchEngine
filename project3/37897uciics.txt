ics 180 april 8 1997 
representation game positions 
ics
180a
spring
1997
strategy
board
game
programming
lecture
notes
april
8
1997
board
representations
order
operate
game
program
needs
able
store
manipulate
two
kinds
objects
game
positions
game
moves
representations
need
allow
program
perform
following
operations
make
given
move
just
user
requests
part
search
undo
move
just
user
interface
needed
search
display
board
user
generate
list
possible
moves
evaluate
board
position
everything
except
displaying
board
must
fast
since
happens
inner
loops
search
routine
board
display
can
slower
since
happen
often
internal
representation
moves
concise
since
want
spend
much
time
generating
long
lists
moves
quickly
decodable
important
also
able
represent
possible
moves
chess
typical
computer
move
representation
store
starting
square
ending
square
piece
moved
instance
common
beginning
move
king's
pawn
forward
two
squares
represented
e2e4
e2
name
initial
position
pawn
e4
name
final
position
piece
captured
need
stored
part
move
since
determined
final
position
computer
positions
can
represented
6
bit
values
whole
move
stored
internally
two
bytes
even
though
programs
based
representation
quite
capable
representing
moves
castling
two
pieces
move
king
rook
can
handle
special
case
list
king
movement
importantly
pawn
moves
seventh
rank
eighth
can
replaced
four
pieces
queen
rook
knight
bishop
representation
allow
us
specify
replacement
happening
designing
move
representation
one
careful
make
sure
covers
special
cases
might
happen
game
onternal
representation
board
can
less
concise
still
huge
must
represent
relevant
information
just
visible
information
including
irrelevant
information
chess
need
know
positions
pieces
board
obvious
visible
information
also
need
know
invisible
information
move
whether
either
player
can
castle
whether
en
passant
capture
possible
many
moves
since
last
capture
pawn
move
also
need
know
something
positions
occurred
past
triple
repetition
need
know
entire
list
past
moves
example
multiple
representation
possibilities
chess
many
possible
ways
representing
even
something
clearly
defined
structure
chessboard
computer
methods
used
chess
programs
representation
1
8x8
array
squares
within
square
keep
value
indicating
piece
present
square
enum
empty
wk
wn
wb
wr
wq
wp
bk
bn
br
bq
bp
advantages
1
simple
2
easy
compute
material
scores
0
8
0
8
score
value
square
little
messy
really
hard
compute
possible
moves
can
loop
squares
finding
pieces
appropriate
color
branch
according
piece
type
0
8
0
8
switch
board
case
wp
board
1
empty
generate
move
1
2
board
1
empty
board
2
empty
generate
move
2
0
board
1
1
contains
black
piece
generate
capture
1
1
7
board
1
1
contains
black
piece
generate
capture
1
1
break
however
various
annoying
boundary
conditions
check
pawn
rook
file
try
capture
one
side
making
code
complicated
slower
necessary
representation
2
extended
array
10x10
containing
extra
boundary
squares
containing
special
boundary
value
added
enum
simpifies
cases
reduces
number
conditions
statements
expense
little
space
representation
3
0x88
name
representation
comes
trick
testing
whether
square
valid
move
involving
binary
representation
number
136
hexadecimal
0x88
give
square
board
number
single
byte
high
4
bits
row
low
4
bits
column
112
113
114
115
116
117
118
119
96
97
98
99
100
101
102
103
80
81
82
83
84
85
86
87
64
65
66
67
68
69
70
71
48
49
50
51
52
53
54
55
32
33
34
35
36
37
38
39
16
17
18
19
20
21
22
23
0
1
2
3
4
5
6
7
square
left
1
right
1
16
16
etc
represent
board
array
128
squares
64
correspond
actual
squares
board
advantages
representation
1
speeds
program
little
using
one
index
instead
two
array
references
2
can
test
really
quickly
easily
whether
move
stays
board
legal
board
position
0x88
0
work
moving
board
either
overflows
column
giving
0x08
nonzero
overflows
row
giving
0x80
nonzero
pretty
commonly
used
technique
representation
4
bitboards
go
lot
length
representations
probably
unfamiliar
think
also
likely
work
better
instead
array
squares
containing
piece
types
array
piece
types
stores
packed
array
bits
listing
squares
containing
piece
since
64
possible
squares
packed
arrays
can
stored
64
bit
number
two
32
bit
words
big
advantage
can
perform
certain
evaluation
move
generation
operations
quickly
using
bitwise
boolean
operations
think
way
getting
computer
massively
parallel
computations
packing
things
long
words
example
following
position
bitboard
white
pawns
call
64
bit
value
wp
consist
bits
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
1
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
1
1
1
0
0
0
0
1
0
0
0
0
0
0
0
0
bitboard
squares
occupied
black
can
computed
formula
bocc
bp
bn
bb
br
bq
bk
bp
etc
bitboards
different
kinds
black
pieces
similarly
can
compute
white
occupied
squares
two
bitboards
together
get
occupied
squares
bitboard
possible
white
pawn
one
square
move
destinations
can
computed
formula
single
pawn
moves
wp
8
occupied
look
slow
motion
shifting
wp
8
produces
bitboard
positions
one
place
front
pawn
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
1
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
1
1
1
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
negation
occupied
gives
bitboard
empty
squares
0
0
1
1
0
0
1
0
1
0
1
0
1
0
0
0
1
1
1
0
0
0
1
1
1
0
1
1
1
0
1
1
1
0
1
1
0
1
1
1
1
0
1
1
1
0
1
1
0
0
0
1
1
1
1
0
0
1
0
1
0
0
1
0
bitwise
two
bitboards
gives
positions
front
pawn
already
occupied
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
1
0
1
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
similarly
can
find
two
square
pawn
moves
taking
bitboard
one
square
moves
shifting
another
8
bits
anding
non
occupied
squares
anding
constant
bitboard
shown
squares
fourth
row
row
onto
pawns
allowed
move
two
squares
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
1
1
1
1
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
note
constant
bitboard
can
generated
compile
time
rather
time
want
generate
moves
pawn
captures
similar
shift
seven
nine
constant
eliminate
captures
left
right
side
board
bocc
point
technique
code
simpler
program
bitboards
little
complicated
generate
pawn
moves
rather
one
time
also
lot
intermediate
expressions
need
bocc
get
used
need
computed
bitboards
end
efficient
think
even
better
games
chess
fewer
types
pieces
one
complication
arises
often
important
count
number
nonzero
bits
bitboard
find
nonzero
bit
turn
bitboard
possible
pawn
moves
explicit
list
moves
counting
can
done
one
byte
time
looking
256
entry
table
number
nonzero
bits
byte
cute
trick
finding
single
nonzero
bit
1
uparrow
notation
exclusive
gives
binary
number
000111
first
one
1
last
nonzero
bit
need
turn
actual
bit
take
result
modulo
carefully
chosen
number
numbers
000111
different
mod
look
result
table
simple
example
following
code
finds
index
last
nonzero
bit
byte
int
1
0
7
1
3
1
6
2
5
4
1
1
int
last
bit
unsigned
char
return
1
11
undo
remember
said
board
representation
needed
handle
undo
operations
two
possible
methods
1
keep
stack
stack
item
holds
whole
board
representation
make
move
push
stack
undo
move
pop
stack
probably
slow
2
keep
stack
storing
move
together
enough
extra
information
undo
move
restore
information
board
position
chess
need
store
identity
captured
piece
enough
information
restore
castling
en
passant
capturing
privileges
repetition
detection
games
go
chess
special
rules
happens
position
repeated
chess
third
repetition
position
gives
player
making
repetition
right
declare
draw
tell
short
answer
make
hash
function
translating
position
reasonably
large
number
talk
later
also
important
speeding
search
keep
list
hash
codes
previous
game
positions
test
position
shows
typical
hash
function
make
64
13
table
large
random
numbers
piece
position
look
table
add
hash
ignoring
overflow
zobrist
note
making
move
piece
positions
can
update
hash
quickly
just
subtract
table
add
table
david
eppstein
dept
information
computer
science
uc
irvine
monday
14
apr
1997
11
31
24
pdt
