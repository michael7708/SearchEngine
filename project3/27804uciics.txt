ics 65 fall 2012 project 2 maps legends 
project 2 
ics
65
fall
2012
news
course
reference
schedule
project
guide
code
examples
alex
ics
65
fall
2012
project
2
maps
legends
due
date
time
wednesday
november
7
11
59pm
introduction
last
couple
decades
two
forces
combined
fundamentally
change
software
built
rise
always
internet
local
networks
within
organizations
growing
variety
internet
capable
devices
allows
us
make
assumptions
near
ubiquitous
connectivity
cost
acquiring
connecting
many
small
servers
dropped
precipitously
thanks
especially
cloud
providers
longer
even
necessary
purchase
servers
now
possible
dynamically
automatically
rent
servers
hour
data
centers
around
world
single
large
scale
software
systems
running
beefy
individual
servers
now
collections
cooperating
services
communicating
one
another
networks
paradigm
providing
software
service
providing
ability
access
software
running
provider's
servers
even
servers
rented
provider
third
party
rather
providing
software
installed
user's
infrastructure
becoming
increasingly
popular
profitable
become
quite
useful
break
complex
problems
small
services
project
consider
one
service
authentication
service
manages
usernames
passwords
will
battle
ready
it'll
store
information
memory
redundancy
will
completely
ignore
security
example
will
serve
vehicle
us
continue
recent
exploration
writing
well
behaved
classes
begin
consider
design
somewhat
larger
programs
will
seed
work
future
projects
well
behaved
classes
discussed
lecture
call
well
behaved
classes
well
behaved
class
one
just
works
use
way
use
type
language
well
behaved
classes
objects
clean
die
can
copied
way
makes
copy
unique
separate
original
can
made
constant
preserving
ability
perform
whatever
operations
change
publicly
observable
state
object
every
class
write
starting
project
will
well
behaved
class
discover
go
forward
design
choices
make
can
make
much
simpler
goal
achieve
might
think
first
need
understand
issues
pitfalls
lie
tools
provides
us
solve
problem
program
will
writing
authentication
service
whose
role
keep
track
username
password
combinations
verify
particular
username
password
combination
valid
able
report
number
unique
username
password
combinations
currently
known
previous
project
will
read
input
standard
input
cin
will
write
output
standard
output
cout
though
certainly
imagine
work
across
network
connection
instead
text
based
communication
like
seems
primitive
might
surprised
find
many
well
known
internet
protocols
actually
send
text
based
commands
responses
little
different
program
read
one
line
input
time
parse
execute
one
command
command
unrecognized
example
unrecognized
command
parameters
recognized
invalid
valid
commands
hand
executed
will
kind
observable
effect
program
continues
reading
parsing
processing
one
command
time
special
quit
command
appears
input
case
program
ends
program
stores
collection
username
password
combinations
hash
table
stored
memory
initially
username
password
combinations
stored
commands
create
remove
program
ends
objects
allocated
dynamically
must
deallocated
commands
following
commands
must
supported
every
command
appears
line
output
every
command
appear
line
command
formatdescriptioncreate
username
passwordcreate
new
username
password
combination
stores
program's
collection
successful
output
created
username
already
stored
collection
change
made
output
exists
login
username
passwordchecks
username
password
combination
see
valid
username
password
combination
valid
exists
username
collection
associated
password
case
output
succeeded
username
password
combination
exist
output
failed
remove
usernameremoves
username
password
combination
given
username
exists
output
removed
username
password
combination
given
username
exists
output
nonexistent
countthe
output
number
username
password
combinations
currently
stored
quitthe
output
command
goodbye
command
processed
program
end
commands
require
parameters
listed
output
invalid
command
one
missing
parameters
many
parameters
simply
unrecognized
listen
music
invalid
minor
important
details
input
output
case
sensitive
find
means
worry
case
string
comparisons
default
take
case
account
safe
assume
usernames
passwords
can
contain
character
whitespace
can
never
whitespace
characters
simplifies
problem
parsing
commands
complete
example
program
execution
following
complete
example
program
execution
demonstrating
input
output
interleaved
input
shown
regular
font
weight
output
shown
bold
create
thornton
ics
uci
edu
abcdefg
created
create
boo
thornton
com
sleeping
created
create
boo
thornton
com
playing
exists
login
thornton
ics
uci
edu
abcdefg
succeeded
login
thornton
ics
uci
edu
defg
failed
login
bill
gates
microsoft
com
windows
failed
count
2
remove
thornton
ics
uci
edu
removed
remove
thornton
ics
uci
edu
nonexistent
remove
edge
u2
com
nonexistent
logins
hello
hello
com
hello
invalid
login
thornton
ics
uci
edu
invalid
login
invalid
wtf
invalid
invalid
quit
goodbye
background
hash
table
implementation
hash
tables
implemented
many
slightly
different
ways
central
concept
always
storing
collection
search
keys
possibly
information
attached
define
way
determine
search
key
belongs
use
starting
point
deciding
store
key
find
later
deciding
search
key
belongs
role
hash
function
whose
job
take
key
return
hash
value
hash
value
turn
used
choose
location
store
find
remove
key
hash
table
specific
goal
acting
map
collection
key
value
pairs
implement
class
called
hashmap
will
separately
chained
say
will
implemented
dynamically
allocated
array
buckets
bucket
singly
linked
list
specifically
dynamically
allocated
array
pointers
nodes
empty
list
represented
nullptr
keys
values
paired
together
linked
list
node
will
store
key
value
hash
functions
hashmap
can
optionally
given
hash
function
constructor
parameter
will
use
default
choosing
none
specified
hash
functions
type
std
function
unsigned
int
const
std
string
means
anything
can
treated
function
takes
const
std
string
parameter
returns
unsigned
int
since
will
unaware
number
buckets
can
actually
legally
return
arbitrary
unsigned
int
will
hashmap
class
take
values
returned
hash
function
reduce
range
available
bucket
indices
using
operator
load
factors
rehashing
linked
lists
can
grow
relative
impunity
performance
separately
chained
hash
table
function
lengths
linked
lists
strongly
incentivized
keep
lists
short
possible
even
wonderfully
designed
hash
function
separately
chained
hash
table
can
still
slow
simply
become
overly
full
every
list
storing
multiple
keys
like
avoid
problem
leads
question
measure
full
hash
table
say
load
factor
hash
table
number
keys
storing
divided
number
buckets
stated
differently
average
length
lists
avoid
performance
hit
becoming
overly
full
hashmap
class
required
allocate
larger
number
buckets
rehash
keys
whenever
load
factor
exceeds
threshold
0
8
reason
rehashing
necessary
number
buckets
effect
bucket
key
will
stored
changing
number
buckets
requires
rehashing
keys
stored
new
home
design
requirements
hashmap
class
hashmap
class
must
use
following
header
file
starting
point
hashmap
header
file
declares
set
members
class
required
implement
though
welcome
add
anything
like
able
change
remove
anything
running
set
unit
tests
hashmap
class
verify
correctness
separately
rest
program
one
primary
goals
project
explore
tools
provided
allow
write
well
behaved
class
hashmap
class
will
required
well
behaved
rules
limitations
additional
challenges
rules
limitations
governing
work
project
permitted
use
containers
std
vector
generic
algorithms
std
find
standard
library
will
exploring
standard
library
depth
relatively
near
future
goal
implement
data
structure
hand
gain
understanding
build
well
behaved
class
underlying
features
well
behaved
public
members
hashmap
class
changed
way
including
seemingly
minor
changes
removing
const
one
member
variable
declarations
can
compile
run
unit
tests
class
will
expect
public
members
identical
current
declarations
now
embracing
's
object
oriented
features
write
classes
just
hashmap
implementation
specific
rules
precisely
classes
need
consider
might
slice
program's
functionality
pieces
layers
representing
layers
class
classes
well
behaved
memory
resources
leak
anywhere
program
note
however
classes
whose
member
variables
well
behaved
types
generally
well
behaved
without
extra
work
find
need
big
three
classes
write
big
three
unless
need
every
class
must
declared
header
file
implemented
source
file
separation
interface
implementation
seen
code
examples
thus
far
additional
challenges
work
project
interested
tackling
additional
challenges
directions
can
go
general
always
feel
free
explore
use
language
features
yet
cover
though
also
aware
sometimes
able
submit
work
choose
features
explicitly
violate
one
rules
using
standard
library
containers
like
std
list
stop
learning
experience
one
design
challenge
consider
implementing
user
interface
using
command
pattern
inheritance
polymorphism
used
differentiate
different
commands
can
entered
via
standard
input
another
design
challenge
hashmap
class
somewhat
limited
requires
keys
values
strings
broadly
useful
hashmap
implemented
template
class
meaning
individual
hashmap
objects
can
key
value
types
configured
hashmap
int
student
like
go
route
can
talk
ways
break
unit
tests
approach
carefully
can
done
can
work
part
separately
submit
useful
optimization
implement
ability
hashmaps
moved
can
accomplish
adding
move
constructor
move
assignment
operator
hashmap
class
requires
use
new
11
feature
called
rvalue
references
testing
previous
project
explicit
deliverable
demonstrating
tested
program
nonetheless
well
advised
run
program
test
inputs
example
test
hashmap
class
ways
necessarily
exercised
entire
program
will
running
two
kinds
tests
whole
program
tests
will
redirect
test
input
files
program's
standard
input
check
output
expectationsunit
tests
focus
hashmap
class
including
member
functions
functionality
big
three
program
may
may
use
test
functionality
used
program
think
classes
reusable
components
extent
can
make
designs
clear
implementations
bullet
proof
reuse
will
enabled
example
finished
hashmap
class
able
write
second
separate
program
uses
ways
original
program
suggest
course
testing
yet
still
see
ultimately
works
still
work
writing
two
main
functions
main
function
special
sense
can
one
program
try
compile
program
one
main
function
linker
will
refuse
link
program
initial
call
main
one
starts
program
will
ambiguous
lot
value
writing
tests
separate
source
file
regular
main
given
least
couple
ways
work
around
problem
visual
studio
write
one
main
function
calls
two
functions
one
starts
program
normally
another
runs
tests
written
separate
source
files
comment
one
call
depending
want
run
write
main
functions
two
separate
source
files
want
choose
one
exclude
one
want
visual
studio
project
right
clicking
file
selecting
exclude
project
project
adding
one
want
right
clicking
project
selecting
add
existing
item
submit
credit
offered
please
submit
tests
runs
risk
making
difficult
us
compile
run
program
using
test
automation
value
writing
tests
please
us
value
writing
ensuring
hashmap
class
complete
correct
will
reflected
score
deliverables
submit
source
cpp
header
files
comprise
program
afterward
take
moment
sure
submitted
files
missed
one
able
compile
run
program
can
result
substantial
penalty
since
able
evaluate
program's
correctness
follow
link
discussion
submit
project
via
checkmate
aware
holding
rules
specified
document
including
one
says
responsible
submitting
version
project
want
graded
regrade
project
simply
accidentally
submitted
wrong
version
originally
written
alex
thornton
fall
2012
