ics 142 winter 2004 assignment 5 
assignment 5 
ics
142
winter
2004
news
course
reference
schedule
lab
manual
ics
142
newsgroup
alex
ics
142
winter
2004
assignment
5
due
date
time
thursday
march
11
11
59pm
introduction
can
write
programs
programming
language
first
must
decide
map
problem
abstractions
provided
programming
language
intend
use
case
language
like
java
means
make
object
oriented
design
decisions
taking
data
centric
viewpoint
decides
kind
objects
will
comprise
system
objects
will
interact
similarly
back
end
compiler
can
begin
generating
intermediate
code
target
code
equivalent
source
program
necessary
map
abstractions
provided
source
language
probably
lower
level
abstractions
provided
intermediate
language
target
language
lower
level
intermediate
code
iloc
presented
textbook
discussed
lecture
first
decisions
will
need
made
center
around
use
memory
though
variety
decisions
will
need
made
well
compiling
java
decided
use
iloc
intermediate
language
consider
many
issues
represent
objects
memory
put
static
variables
lay
manage
heap
allocated
variables
including
allocation
garbage
collection
manage
calling
methods
including
parameter
passing
return
values
saving
restoring
caller's
state
implement
dynamic
binding
method
calls
polymorphism
represent
manage
multiple
threads
fortunately
language
monkie2004
number
decisions
need
made
much
smaller
assignment
will
explore
placement
variables
memory
subsequent
use
expressions
assignment
statements
syntax
directed
analysis
previous
two
assignments
output
parser
abstract
syntax
tree
represented
meaningful
information
source
program
code
built
abstract
syntax
tree
embedded
grammar
actions
included
cup
script
built
nodes
passed
parse
tree
building
abstract
syntax
tree
performed
semantic
checking
assignment
3
interpreted
assignment
4
noted
work
done
assignment
3
another
strategy
also
worked
analysis
embedded
actions
cup
script
rather
building
entire
ast
first
performing
analysis
primary
reasons
build
ast
keep
analysis
separate
parser
still
learning
details
use
cup
also
seed
work
interpreter
assignment
4
example
assuming
global
symbol
table
called
st
available
actions
cup
script
following
action
embedded
rule
addition
expression
assuming
type
object
associated
expression
simplified
things
somewhat
purposes
example
expr5
expr5
e5
addition
op
expr6
e6
e5
st
lookuptype
integer
e6
st
lookuptype
integer
reportsemanticerror
operands
addition
must
integers
result
null
else
result
st
lookuptype
integer
similarly
rest
rules
grammar
contained
actions
performed
semantic
checking
program
parsed
conclusion
parsing
program
semantic
checking
complete
syntax
directed
analysis
performing
analysis
source
program
parsed
use
strategy
semantic
analyzer
analyses
might
perform
program
parsing
order
set
however
first
need
introduce
feature
cup
discussed
embedding
action
middle
grammar
rule
opposed
placing
end
one
discussed
class
previous
assignment
write
ups
embed
actions
end
grammar
rule
cup
script
actions
may
also
embedded
middle
rules
example
consider
following
brief
cup
script
irrelevant
parts
left
goal
happies
system
println
happies
monkies
system
println
monkies
happies
happies
happy
system
println
happy
happy
system
println
happy
monkies
monkies
monkie
system
println
monkie
monkie
system
println
monkie
notice
one
rule
goal
happies
followed
monkies
action
happies
within
rule
can
discern
script
since
'
'
character
happies
monkies
grammar
accepts
input
file
one
happy
tokens
followed
one
monkie
tokens
actions
middle
cup
rule
executed
preceding
portion
rule
matched
rest
rule
matched
equivalent
placing
dummy
nonterminal
symbol
middle
rule
along
addition
epsilon
rule
dummy
nonterminal
symbol
words
goal
rule
example
equivalent
two
rules
goal
happies
dummy
monkies
system
println
monkies
dummy
epsilon
system
println
happies
however
original
version
action
midst
rule
clearly
indicates
intent
execute
action
happies
monkies
effect
example
following
print
happy
every
happy
token
input
print
happies
happy
tokens
print
monkie
every
monkie
token
input
print
monkies
monkie
tokens
useful
technique
performing
forms
syntax
directed
analysis
example
implementing
semantic
checker
using
syntax
directed
technique
might
want
action
embedded
within
procedure
rule
parameterlist
matched
blockstatement
action
declare
parameters
symboltable
proceeding
analyze
blockstatement
work
assignment
may
find
technique
great
benefit
program
program
will
take
monkie2004
program
input
output
will
indication
things
procedure
function
layout
activation
record
ar
details
will
shown
ar's
will
laid
similarly
described
lecture
local
variables
top
parameters
bottom
relevant
information
layout
global
variables
static
memory
rather
report
absolute
address
global
variable
assume
one
contiguous
block
memory
will
used
global
variables
global
variable
addresses
will
reported
offsets
block
use
variable
assignment
statement
expression
information
allow
calculation
access
path
will
described
detail
will
required
perform
analysis
parsing
program
actions
embedded
within
cup
script
will
course
need
use
auxiliary
data
structures
store
relevant
information
activation
record
layouts
may
build
abstract
syntax
tree
analyze
previous
two
assignments
part
like
get
assignment
experience
syntax
directed
analysis
changes
monkie2004
language
assignment
order
introduce
couple
wrinkles
assignment
iron
another
two
changes
introduced
monkie2004
language
assignment
ref
parameters
dropped
entirely
language
corresponding
rule
removed
grammar
parameters
assumed
passed
value
procedure
function
declarations
may
now
nested
meaning
may
occur
statements
language
assumed
static
scoping
will
used
resolve
references
non
local
variables
rules
calling
nested
procedures
functions
relevant
assignment
may
assume
standard
rules
programming
languages
pascal
apply
memory
layout
requirements
data
widths
operate
assumption
data
must
laid
four
byte
boundaries
accommodate
assumption
make
following
rules
widths
data
monkie2004
integer
boolean
variables
will
occupy
four
bytes
strings
course
complicated
since
lengths
strings
may
vary
widely
say
string
variables
occupy
eight
bytes
either
global
memory
activation
records
operating
couple
assumptions
string
variable
will
require
four
bytes
length
four
bytes
pointer
heap
allocated
contents
assumed
change
string
concatenation
assignment
copying
string
pass
value
will
cause
automatic
heap
allocation
appropriate
size
well
necessary
deallocation
behavior
will
modeled
program
global
memory
global
variables
program
will
allocated
one
area
memory
called
global
area
global
variables
laid
global
area
order
seen
first
one
offset
0
subsequent
ones
higher
offsets
example
following
three
global
variables
declared
input
program
var
integer
var
string
var
boolean
laid
follows
appear
offset
0
global
areas
appear
offset
4
global
areab
appear
offset
12
global
area
total
size
global
area
16
bytes
since
lifetime
global
variables
entire
duration
program's
execution
overlaying
ever
done
save
memory
global
area
activation
records
subprogram
including
nested
subprograms
activation
record
activation
records
contain
local
variables
parameters
three
additional
values
pointer
caller's
ar
static
link
return
address
functions
fourth
additional
value
pointer
return
value
additional
values
occupies
four
bytes
activation
records
assumed
stack
allocated
stack
growing
higher
lower
addresses
assumed
activation
current
ar
pointer
will
point
location
caller's
ar
current
activation
record
local
variables
will
appear
caller's
ar
negative
offsets
parameters
will
appear
return
address
return
value
pointer
positive
offsets
order
local
variables
parameters
will
considered
important
can
determined
example
consider
following
monkie2004
function
function
foo
string
integer
boolean
integer
var
ii
integer
var
ss
string
var
bb
boolean
layout
foo's
ar
local
variable
bb
offset
16local
variable
ss
offset
12local
variable
ii
offset
4caller's
ar
pointer
offset
0static
link
offset
4return
address
offset
8return
value
pointer
offset
12parameter
offset
16parameter
offset
24parameter
offset
28
size
foo's
ar
48
bytes
overlaying
local
variables
activation
records
activation
records
minimally
sized
meaning
memory
within
reused
whenever
possible
easiest
way
ensure
minimum
amount
memory
used
layout
variables
guaranteed
never
live
simultaneously
offsets
ar
given
monkie2004's
block
structure
rule
lifetime
local
variables
within
block
statement
within
block
statement
reuse
fairly
straightforward
achieve
consider
following
example
procedure
bar
var
integer
var
integer
var
integer
var
integer
var
integer
var
integer
var
integer
var
integer
layout
local
variables
activation
record
bar
follows
offset
24p
offset
20n
offset
16k
offset
12j
offset
8i
offset
4
kind
layout
can
achieved
programmatically
using
technique
similar
scoped
symbol
tables
used
previous
two
assignments
static
distance
coordinates
recall
statically
scoped
languages
accessing
non
local
variables
proper
way
find
involve
searching
call
stack
looking
first
declaration
variable
desired
name
another
name
approach
called
dynamic
scoping
statically
scoped
language
uses
non
local
variables
resolved
based
static
properties
program
specifically
lexical
structure
uses
non
local
variables
resolved
finding
syntactically
closest
declaration
variable
following
example
var
integer
procedure
program
var
integer
procedure
foo
assignment
foo
assign
declared
program
one
declared
bar
foo's
caller
implement
behavior
run
time
activation
records
need
store
two
links
ar's
one
caller's
ar
often
called
dynamic
link
another
ar
recent
activation
lexically
enclosing
procedure
often
called
static
link
words
foo
executing
dynamic
link
will
point
bar's
ar
static
link
will
point
ar
recent
activation
program
details
static
links
maintained
run
time
relevant
assignment
assuming
static
links
present
every
ar
accessing
non
local
variable
relatively
straightforward
process
foo
assigns
known
static
link
foo's
ar
will
always
point
ar
recent
activation
program
finding
address
appropriate
matter
two
things
placing
foo's
static
link
register
adding
offset
program's
ar
easily
summarize
process
can
say
every
use
variable
either
assignment
expression
can
characterized
static
distance
coordinate
static
distance
coordinate
ordered
pair
containing
distance
number
static
links
must
followed
get
variable
offset
offset
variable
ar
example
uses
foo
static
distance
coordinate
1
4
assuming
offset
program's
ar
4
static
distance
coordinate
local
variable
0
offset
variable
current
ar
pointed
static
distance
coordinates
apply
global
variables
access
global
variable
can
resolved
using
address
known
compile
time
offset
global
area
need
follow
static
links
order
access
global
variables
can
accessed
much
quickly
using
statically
determined
address
sample
input
output
stated
earlier
program
will
calculate
display
three
kinds
information
parsing
input
program
layout
size
activation
record
procedure
function
layout
size
global
area
static
distance
coordinate
global
area
offset
every
assignment
use
every
variable
since
asking
calculate
display
information
parsing
program
certain
limitations
order
output
implied
example
able
report
layout
size
ar
finished
parsing
procedure
function
able
report
layout
size
global
area
finished
parsing
input
program
static
distance
coordinates
hand
may
reported
immediately
since
variables
declared
used
facts
mind
example
monkie2004
program
sample
output
look
like
sample
input
var
calls
integer
procedure
program
function
factorial
integer
integer
calls
sample
output
procedure
program
function
factorial
assignment
'calls'
global
area
offset
0
use
'calls'
global
area
offset
0
use
'n'
static
distance
coordinate
0
16
assignment
'result'
static
distance
coordinate
0
12
assignment
'result'
static
distance
coordinate
0
12
use
'n'
static
distance
coordinate
0
16
use
'n'
static
distance
coordinate
0
16
factorial
ar
layout
size
20
offset
0
caller's
arp
offset
4
static
link
offset
8
return
address
offset
12
return
value
pointer
offset
16
parameter
'n'
assignment
'calls'
global
area
offset
0
use
'calls'
global
area
offset
0
assignment
'i'
static
distance
coordinate
0
4
assignment
'j'
static
distance
coordinate
0
8
use
'i'
static
distance
coordinate
0
4
use
'i'
static
distance
coordinate
0
4
use
'calls'
global
area
offset
0
program
ar
layout
size
20
offset
8
local
variable
'j'
offset
4
local
variable
'i'
offset
0
caller's
arp
offset
4
static
link
offset
8
return
address
global
area
layout
size
4
offset
0
'calls'
sample
input
2
second
example
presented
shows
example
overlaying
variables
activation
record
accompanied
sample
output
shows
output
reflect
procedure
program
var
integer
sample
output
2
procedure
program
assignment
'i'
static
distance
coordinate
0
4
use
'i'
static
distance
coordinate
0
4
assignment
'j'
static
distance
coordinate
0
8
use
'j'
static
distance
coordinate
0
8
assignment
'k'
static
distance
coordinate
0
8
use
'k'
static
distance
coordinate
0
8
program's
ar
layout
size
20
offset
8
overlay
local
variable
'j'
local
variable
'k'
offset
4
local
variable
'i'
offset
0
caller's
arp
offset
4
static
link
offset
8
return
address
global
area
layout
size
0
erroneous
monkie2004
programs
may
assume
legal
monkie2004
programs
will
used
input
program
bear
mind
couple
changes
made
language
described
notion
legal
monkie2004
program
changed
include
nested
subprograms
exclude
pass
reference
parameters
starting
point
neither
necessary
acceptable
use
ast
solve
problem
starting
point
code
previous
two
assignments
providing
starting
point
consists
complete
scanner
cup
script
monkie
cup
actions
removed
driver
class
sets
things
runs
program
usual
starting
point
provided
zip
archive
zip
archive
deliverables
place
completed
cup
script
java
files
comprise
program
zip
archive
submit
zip
archive
need
include
java
files
created
cup
parser
java
tokens
java
penalize
however
aware
regenerating
grading
process
sure
really
come
cup
script
please
include
files
class
files
zip
archive
follow
link
discussion
submit
assignment
remember
accept
paper
submissions
assignments
accept
via
email
circumstances
order
keep
grading
process
relatively
simple
require
keep
program
designed
way
can
compiled
executed
following
set
commands
cup
monkie
cup
javac
java
java
driver
inputfile
limitations
may
make
changes
monkie2004
grammar
given
except
naturally
must
add
actions
add
names
symbols
right
hand
sides
rules
add
types
nonterminal
symbols
add
code
action
code
section
necessary
changes
cup
script
permitted
originally
written
alex
thornton
winter
2004
