minimum spanning trees 
minimum spanning trees 
ics
161
design
analysis
algorithms
lecture
notes
february
6
1996
minimum
spanning
trees
spanning
trees
spanning
tree
graph
just
subgraph
contains
vertices
tree
graph
may
many
spanning
trees
instance
complete
graph
four
vertices
sixteen
spanning
trees
minimum
spanning
trees
now
suppose
edges
graph
weights
lengths
weight
tree
just
sum
weights
edges
obviously
different
trees
different
lengths
problem
find
minimum
length
spanning
tree
problem
can
solved
many
different
algorithms
topic
recent
research
several
best
algorithms
depending
assumptions
make
randomized
algorithm
can
solve
linear
expected
time
karger
klein
tarjan
randomized
linear
time
algorithm
find
minimum
spanning
trees
acm
vol
42
1995
pp
321
328
can
solved
linear
worst
case
time
weights
small
integers
fredman
willard
trans
dichotomous
algorithms
minimum
spanning
trees
shortest
paths
31st
ieee
symp
foundations
comp
sci
1990
pp
719
725
otherwise
best
solution
close
linear
exactly
linear
exact
bound
log
beta
beta
function
complicated
definition
smallest
log
log
log
log
less
logs
nested
times
gabow
galil
spencer
tarjan
efficient
algorithms
finding
minimum
spanning
trees
undirected
directed
graphs
combinatorica
vol
6
1986
pp
109
122
algorithms
quite
complicated
probably
great
practice
unless
looking
really
huge
graphs
book
tries
keep
things
simpler
describes
one
algorithm
opinion
good
job
go
three
simple
classical
algorithms
spending
much
time
one
minimum
spanning
trees
standard
application
problem
like
phone
network
design
business
several
offices
want
lease
phone
lines
connect
phone
company
charges
different
amounts
money
connect
different
pairs
cities
want
set
lines
connects
offices
minimum
total
cost
spanning
tree
since
network
tree
can
always
remove
edges
save
money
less
obvious
application
minimum
spanning
tree
can
used
approximately
solve
traveling
salesman
problem
convenient
formal
way
defining
problem
find
shortest
path
visits
point
least
note
path
visiting
points
exactly
special
kind
tree
instance
example
twelve
sixteen
spanning
trees
actually
paths
path
visiting
vertices
can
always
drop
edges
get
tree
general
mst
weight
less
tsp
weight
minimization
strictly
larger
set
hand
draw
path
tracing
around
minimum
spanning
tree
trace
edge
twice
visit
points
tsp
weight
less
twice
mst
weight
therefore
tour
within
factor
two
optimal
complicated
way
christofides'
heuristic
using
minimum
spanning
trees
find
tour
within
factor
1
5
optimal
describe
might
covered
ics
163
graph
algorithms
next
year
find
minimum
spanning
tree
stupid
method
list
spanning
trees
find
minimum
list
already
know
find
minima
far
many
trees
efficient
also
really
algorithm
still
need
know
list
trees
better
idea
find
key
property
mst
lets
us
sure
edge
part
use
property
build
mst
one
edge
time
simplicity
assume
unique
minimum
spanning
tree
problem
4
3
baase
related
assumption
can
get
ideas
like
work
without
assumption
becomes
harder
state
theorems
write
algorithms
precisely
lemma
let
subset
vertices
let
edge
smallest
edge
connecting
part
minimum
spanning
tree
proof
suppose
tree
containing
want
show
mst
let
spanning
tree
contains
unique
path
together
forms
cycle
path
include
another
edge
connecting
another
spanning
tree
number
edges
remains
connected
since
can
replace
path
containing
one
going
way
around
cycle
smaller
weight
since
smaller
weight
minimum
wanted
prove
kruskal's
algorithm
start
kruskal's
algorithm
easiest
understand
probably
best
one
solving
problems
hand
kruskal's
algorithm
sort
edges
increasing
order
length
keep
subgraph
initially
empty
edge
sorted
order
endpoints
disconnected
add
return
note
whenever
add
edge
always
smallest
connecting
part
reachable
rest
lemma
must
part
mst
algorithm
known
greedy
algorithm
chooses
step
cheapest
edge
add
careful
trying
use
greedy
algorithms
solve
problems
since
usually
work
want
find
shortest
path
might
bad
idea
keep
taking
shortest
edges
greedy
idea
works
kruskal's
algorithm
key
property
proved
analysis
line
testing
whether
two
endpoints
disconnected
looks
like
slow
linear
time
per
iteration
mn
total
actually
complicated
data
structures
let
us
perform
test
close
constant
time
known
union
find
problem
discussed
baase
section
8
5
get
class
though
slowest
part
turns
sorting
step
takes
log
time
prim's
algorithm
rather
build
subgraph
one
edge
time
prim's
algorithm
builds
tree
one
vertex
time
prim's
algorithm
let
single
vertex
fewer
vertices
find
smallest
edge
connecting
add
since
edge
added
smallest
connecting
lemma
proved
shows
add
edges
part
mst
looks
like
loop
slow
step
data
structures
can
used
speed
idea
use
heap
remember
vertex
smallest
edge
connecting
vertex
prim
heaps
make
heap
values
vertex
edge
weight
edge
initially
infinity
vertex
let
tree
empty
fewer
vertices
let
weight
smallest
weight
heap
remove
weight
heap
add
edge
already
find
value
weight
heap
weight
weight
replace
weight
weight
analysis
perform
steps
remove
smallest
element
heap
2m
steps
examine
edge
steps
might
replace
value
heap
reducing
weight
also
find
right
value
heap
can
done
easily
enough
keeping
pointer
vertices
corresponding
values
described
reduce
weight
element
binary
heap
easy
log
time
alternately
using
complicated
data
structure
known
fibonacci
heap
can
reduce
weight
element
constant
time
result
total
time
bound
log
boruvka's
algorithm
actually
boruvka
spelled
small
raised
circle
accent
although
seems
little
complicated
explain
probably
easiest
one
computer
implementation
since
require
complicated
data
structures
idea
steps
like
prim's
algorithm
parallel
graph
time
boruvka's
algorithm
make
list
trees
single
vertex
one
tree
find
smallest
edge
connecting
add
edges
mst
causing
pairs
trees
merge
saw
prim's
algorithm
edge
add
must
part
mst
must
ok
add
analysis
similar
merge
sort
pass
reduces
number
trees
factor
two
log
passes
pass
takes
time
first
figure
tree
vertex
edge
test
whether
connects
two
trees
better
ones
seen
trees
either
endpoint
total
log
hybrid
algorithm
really
separate
algorithm
can
combine
two
classical
algorithms
better
either
one
alone
idea
log
log
passes
boruvka's
algorithm
switch
prim's
algorithm
prim's
algorithm
builds
one
large
tree
connecting
small
trees
list
built
boruvka's
algorithm
keeping
heap
stores
tree
best
edge
can
used
connect
large
tree
alternately
can
think
collapsing
trees
found
boruvka's
algorithm
supervertices
running
prim's
algorithm
resulting
smaller
graph
point
reduces
number
remove
min
operations
heap
used
prim's
algorithm
equal
number
trees
left
boruvka's
algorithm
log
analysis
log
log
first
part
log
log
second
log
log
total
ics
161
dept
information
computer
science
uc
irvine
last
update
02
may
2000
20
17
37
pdt
