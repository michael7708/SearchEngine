
split cpp 
id
split
cpp
5027
2010
02
18
19
41
48z
rares
split
cpp
copyright
2003
2007
regents
university
california
redistribution
file
permitted
terms
bsd
license
date
march
2002
authors
michael
ortega
binderberger
liang
jin
chen
li
include
include
assert
include
index
include
card
include
split
load
branch
buffer
branches
full
node
plus
extra
branch
static
void
rtreegetbranches
struct
node
struct
branch
register
struct
node
register
struct
branch
register
int
assert
assert
load
branch
buffer
0
ibranch
child
every
entry
full
branchbuf
branch
branchbuf
nodecard
branchcount
nodecard
1
calculate
rect
containing
set
coversplit
branchbuf
0
rect
1
icount
0
count
1
0
total
maxrects
minfill
minfill
0
itaken
false
partition
1
put
branch
one
groups
static
void
rtreeclassify
int
int
group
struct
partitionvars
assert
assert
taken
partition
group
taken
true
count
group
0
cover
group
branchbuf
rect
else
cover
group
rtreecombinerect
branchbuf
rect
cover
group
area
group
rtreerectsphericalvolume
cover
group
count
group
pick
two
rects
set
first
elements
two
groups
pick
two
separated
along
dimension
overlap
least
distance
separation
overlap
measured
modulo
width
space
covered
entire
set
along
dimension
static
void
rtreepickseeds
struct
partitionvars
register
struct
partitionvars
register
int
dim
high
register
struct
rect
rlow
rhigh
register
float
separation
bestsep
rectreal
width
numdims
int
leastupper
numdims
greatestlower
numdims
int
seed0
seed1
assert
dim
0
dimboundary
dim
branchbuf
greatestlower
dim
rect
boundary
dim
greatestlower
dim
boundary
high
branchbuf
leastupper
dim
rect
boundary
high
leastupper
dim
find
width
whole
collection
along
dimension
width
dim
coversplit
boundary
high
coversplit
boundary
dim
pick
best
separation
dimension
two
seed
rects
dim
0
dim
0
width
dim
0
rectreal
1
else
width
dim
rlow
branchbuf
leastupper
dim
rect
rhigh
branchbuf
greatestlower
dim
rect
dim
0
seed0
leastupper
0
seed1
greatestlower
0
separation
bestsep
rhigh
boundary
0
rlow
boundary
numdims
else
separation
rhigh
boundary
dim
rlow
boundary
dim
numdims
separation
bestsep
seed0
leastupper
dim
seed1
greatestlower
dim
bestsep
separation
seed0
seed1
rtreeclassify
seed0
0
rtreeclassify
seed1
1
put
rect
already
group
group
process
one
rect
time
using
following
hierarchy
criteria
case
tie
go
next
test
1
one
group
already
max
number
elements
will
allow
minimum
fill
group
put
2
put
group
whose
cover
will
expand
less
automatically
takes
care
case
one
group
cover
contains
3
put
group
whose
cover
will
smaller
takes
care
case
contained
covers
4
put
group
fewer
elements
5
put
group
1
arbitrary
also
update
covers
groups
static
void
rtreepigeonhole
struct
partitionvars
register
struct
partitionvars
struct
rect
newcover
2
register
int
group
rectreal
newarea
2
increase
2
0
itaken
one
group
full
put
rect
count
0
total
minfill
rtreeclassify
1
continue
else
count
1
total
minfill
rtreeclassify
0
continue
find
areas
two
groups'
old
new
covers
group
0
groupcount
group
0
newcover
group
rtreecombinerect
branchbuf
rect
cover
group
else
newcover
group
branchbuf
rect
newarea
group
rtreerectsphericalvolume
newcover
group
increase
group
newarea
group
area
group
put
rect
group
whose
cover
will
expand
less
increase
0
increase
1
rtreeclassify
0
else
increase
1
increase
0
rtreeclassify
1
put
rect
group
will
smaller
cover
else
area
0
area
1
rtreeclassify
0
else
area
1
area
0
rtreeclassify
1
put
rect
group
fewer
elements
else
count
0
count
1
rtreeclassify
0
else
rtreeclassify
1
assert
count
0
count
1
nodecard
1
method
0
finding
partition
first
find
two
seeds
one
group
well
separated
put
rects
whichever
group
will
smallest
addition
static
void
rtreemethodzero
struct
partitionvars
int
minfill
rtreeinitpvars
branchcount
minfill
rtreepickseeds
rtreepigeonhole
copy
branches
buffer
two
nodes
according
partition
static
void
rtreeloadnodes
struct
node
struct
node
struct
partitionvars
register
struct
node
register
struct
partitionvars
register
int
assert
assert
assert
0
ipartition
0
rtreeaddbranch
branchbuf
null
else
partition
1
rtreeaddbranch
branchbuf
null
else
assert
false
split
node
divides
nodes
branches
extra
one
two
nodes
old
node
one
new
ones
one
really
new
one
created
void
rtreesplitnode
struct
node
struct
branch
struct
node
nn
register
struct
partitionvars
register
int
level
rectreal
area
assert
assert
load
branches
buffer
initialize
old
node
level
level
rtreegetbranches
find
partition
partitions
0
note
use
minfill
since
cleared
getbranches
rtreemethodzero
level
0
minnodefill
minleaffill
record
good
split
statistics
area
area
0
area
1
put
branches
buffer
2
nodes
according
chosen
partition
nn
rtreenewnode
nn
level
level
level
rtreeloadnodes
nn
assert
count
nn
count
nodecard
1
print
data
partition
partitionvars
struct
static
void
rtreeprintpvars
struct
partitionvars
int
assert
printf
npartition
0
itaken
printf
else
printf
printf
0
ipartition
printf
printf
count
0
area
count
0
area
0
printf
count
1
area
count
1
area
1
printf
total
area
effectiveness
3
2f
area
0
area
1
rtreerectsphericalvolume
coversplit
area
0
area
1
printf
cover
0
rtreeprintrect
cover
0
0
printf
cover
1
rtreeprintrect
cover
1
0
