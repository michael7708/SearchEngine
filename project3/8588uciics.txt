introduction 
comose q architecture implementation 
introduction
tlam
resource
management
reflective
communication
architecture
introduction
compose
customizable
safe
distributed
systems
middleware
infrastructure
built
provide
cost
effective
qos
based
distributed
resource
management
allows
concurrent
execution
multiple
resource
management
policies
distributed
system
safe
correct
manner
allows
safe
integration
resource
management
mechanisms
services
mobility
load
balancing
fault
tolerance
end
end
qos
management
based
two
level
meta
architectural
model
facilitates
specifying
reasoning
composability
multiple
resource
management
services
open
distributed
systems
compose
reflective
framework
uses
actors
distributed
computing
paradigm
uses
model
concurrent
active
objects
built
notion
encapsulation
interaction
among
concurrent
components
open
distributed
system
actor
paradigm
universe
contains
computational
agents
called
actors
distributed
network
traditional
passive
objects
encapsulate
state
set
procedures
manipulate
state
actors
extend
encapsulating
thread
control
well
actor
potentially
executes
parallel
actors
may
communicate
actors
via
asynchronous
message
passing
using
actors
define
meta
architecture
framework
permits
customization
resource
management
mechanisms
placement
scheduling
synchronization
compose
architecture
contains
basic
composable
core
services
remote
creation
distributed
snapshot
directory
services
interaction
constraints
ensure
concurrent
execution
meta
level
services
services
built
using
core
services
actor
migration
replication
services
data
actor
scheduling
distributed
garbage
collection
name
services
etc
services
interface
definitions
interaction
constraints
qos
enforcement
mechanisms
back
top
two
level
meta
architectural
model
tlam
ensuring
correctness
purely
reflective
model
involves
reasoning
system
level
interactions
characterizing
semantics
shared
distributed
resources
understanding
correctness
overall
system
means
tlam
two
level
actor
machine
model
presented
first
step
towards
providing
formal
semantics
specifying
reasoning
properties
interactions
components
odss
tlam
system
composed
two
kinds
actors
base
actors
meta
actors
distributed
network
processing
nodes
base
level
actors
carry
application
level
computation
meta
actors
part
runtime
system
manages
system
resources
controls
runtime
behavior
base
level
meta
actors
communicate
via
message
passing
base
level
actors
may
also
examine
modify
state
base
actors
located
node
tlam
uses
reification
base
object
state
data
meta
object
level
reflection
modification
base
object
state
meta
objects
support
implicit
invocation
meta
objects
response
changes
base
level
state
provides
full
actor
style
interaction
meta
level
objects
tlam
model
meta
level
controllers
define
protocols
mechanisms
customize
various
aspects
distributed
systems
management
practice
multiple
system
application
activities
occur
concurrently
distributed
system
scheduling
protocol
processing
stream
synchronization
etc
can
therefore
interfere
ensure
non
interference
manage
complexity
reasoning
components
odss
general
strategy
identify
key
system
services
non
trivial
interactions
application
system
occur
base
meta
interactions
refer
key
services
core
services
core
services
used
specifying
implementing
complex
activities
within
framework
purely
meta
level
interactions
development
suitable
non
interference
requirements
allows
us
reason
composition
multiple
system
services
services
constraints
must
obeyed
maintain
composability
safe
concurrent
execution
use
commonly
observed
patterns
distributed
systems
identify
three
meta
level
core
activities
see
figure
remote
creation
migration
replication
load
balancing
distributed
snapshot
check
pointing
distributed
garbage
collection
etc
directory
services
access
control
resource
discovery
group
communication
back
top
resource
management
services
implementation
sophisticated
policies
mechanisms
qos
management
made
possible
providing
support
common
services
compose
instance
object
scheduling
mechanisms
use
basic
remote
creation
core
service
assign
newly
created
objects
actors
nodes
adequate
resources
using
generalized
state
capture
facilities
developing
checkpointing
service
capturing
causal
orders
executions
system
can
used
monitoring
debugging
distributed
computations
state
broadcast
mechanism
used
implement
clock
synchronization
service
informs
nodes
global
time
value
can
used
time
related
services
remote
creation
remote
creation
process
actor
creation
occurs
specified
node
node
creation
initiated
remote
creation
basic
facility
can
used
resource
management
activities
like
load
balancing
replication
migration
encapsulating
interactions
application
system
level
actors
within
remote
creation
service
can
state
requirements
ensure
safe
correct
composition
resource
management
activities
remote
creation
real
tlam
based
implementation
control
activities
remote
creation
managed
remote
creation
meta
actors
rcm
residing
every
node
system
remote
creation
request
four
parameters
description
fragment
desc
migrated
remote
node
initial
state
desc
set
initiating
actor
'b'
initiator
actor
'b'
maintained
rcm
ensure
composability
meta
level
services
v98
requester
needs
know
request
completed
names
newly
created
actors
can
achieved
specifying
appropriate
messages
part
requested
fragment
observing
delivery
distributed
snapshot
services
global
properties
like
number
application
actors
current
reachability
graph
distributed
actors
number
messages
processed
task
queue
sizes
help
making
runtime
decisions
like
load
balancing
migration
garbage
collection
leading
efficient
runtime
management
distributed
system
fully
represent
global
state
distributed
system
need
mechanism
recording
state
nodes
including
portion
node
state
communicated
network
channels
state
information
accessible
explicitly
nodes
snapshot
mechanism
must
ensure
node
state
information
channels
recorded
node
system
possibly
target
node
snapshot
mechanisms
devised
application
level
computation
system
level
services
proceed
concurrently
snapshot
thereby
preserving
application
service
semantics
order
initiate
snapshot
recording
every
node
force
messages
channels
reach
node
defined
two
wave
protocols
message
propagation
visit
nodes
exactly
capturing
node
resident
information
traverse
links
system
exactly
forcing
messages
channels
reach
nodes
state
can
recorded
migration
using
remote
creation
basis
migration
ensured
composability
migration
meta
level
services
reachability
snapshots
distributed
check
pointing
migration
process
actors
move
one
node
another
migration
service
allows
relocation
actors
easier
access
availability
load
balancing
migration
request
given
pair
£\
£\
actor
migrated
destination
node
interpreted
request
move
computation
carried
£\
node
order
state
explicitly
invariants
maintained
system
migration
process
classify
migration
process
3
phases
respect
actor
migrated
node
migrated
first
phase
initiation
phase
specifies
state
system
migration
request
received
can
processed
determines
computation
migrated
suspending
computation
actor
noting
current
description
second
configuration
actual
actor
migration
performed
using
rc
service
last
configuration
finalizes
migration
process
establishes
transparent
access
migrated
actor
qos
brokerage
service
work
illustrates
use
tlam
services
design
mechanisms
policies
needed
enforce
qos
constraints
actor
based
runtime
environment
extend
basic
meta
architectural
framework
provide
qos
based
services
applications
base
level
component
meta
architecture
implements
functionality
distributed
session
deals
data
includes
objects
varying
media
types
video
audio
files
requests
access
data
via
sessions
meta
level
component
deals
coordination
multiple
requests
sharing
existing
resources
among
multiple
requests
provide
coordination
highest
level
perform
admission
control
new
incoming
sessions
meta
level
entity
called
qos
broker
developed
organization
meta
level
services
compose
illustrated
figure
two
main
functions
qos
broker
data
management
request
management
data
management
component
decides
placement
data
distributed
system
decides
create
additional
replicas
data
also
determines
additional
replicas
data
actors
longer
needed
can
garbage
collected
dereplicated
implement
adaptive
admission
control
mechanisms
request
scheduling
module
assigns
requests
servers
ensures
cost
effective
utilization
resources
message
scheduling
module
ensures
qos
constraint
satisfaction
requests
already
initiated
data
request
management
functions
turn
require
auxiliary
services
clock
synchronization
replication
dereplication
migration
far
focused
following
services
replication
replicate
data
request
actors
using
adaptive
predictive
techniques
selecting
fast
replication
proceed
dereplication
dereplicate
garbage
collect
data
request
actors
optimize
utilization
distributed
storage
based
current
system
load
expected
future
demands
object
migration
migrate
data
requests
load
balancing
availability
locality
interaction
migration
timing
based
qos
constraints
interesting
issue
since
can
introduce
playback
jitter
mm
applications
caused
explicit
teardown
re
establishment
network
connections
auxiliary
services
described
developed
using
one
core
services
remote
creation
distributed
snapshot
directory
service
order
ensure
non
interference
among
auxiliary
services
used
provide
qos
specific
mechanisms
implemented
placement
scheduling
must
designed
conflict
currently
placement
dereplication
operate
basis
conservative
snapshot
current
resource
allocation
use
placement
dereplication
services
consider
exact
times
requests
arrive
contrast
adaptive
request
scheduling
process
makes
decisions
based
exact
arrival
times
requests
however
without
appropriate
constraints
usage
services
inconsistencies
can
arise
due
interaction
broker
coordinates
service
interaction
constraining
behavior
auxiliary
placement
scheduling
services
instance
dereplication
service
dereplicate
replica
request
scheduling
process
making
assignment
furthermore
replica
assigned
active
request
physically
dereplicated
broker
also
ensures
dereplication
placement
metalevel
services
cancel
one
another
interaction
dereplication
placement
functional
correctness
issue
cost
effective
performance
overall
system
back
top
reflective
communication
service
architecture
order
provide
correct
composition
communication
services
qos
based
applications
transparent
scalable
fashion
ensuring
correctness
basic
middleware
services
meta
level
architecture
distributed
resource
management
garbage
collection
remote
creation
tlam
model
extended
composable
reflective
communication
framework
crcf
customizes
base
level
communication
services
among
group
objects
follows
base
level
actor
meta
level
actor
called
messenger
serves
customized
transparent
mail
queue
base
level
actor
one
communication
manager
every
node
distributed
system
implements
controls
correct
composition
communication
services
specified
messenger
messenger
four
message
queues
queues
used
communicate
base
level
actor
serving
actor
send
buffer
customized
mail
queue
respectively
queues
used
interaction
communication
manager
requesting
communication
services
satisfy
qos
constraints
queues
hold
raw
messages
base
level
actors
queues
hold
processed
messages
messages
required
protocols
enforced
furthermore
communication
manager
set
communication
protocol
actors
implementing
particular
communication
service
provided
framework
reliable
protocol
order
protocol
communication
services
can
added
plugged
removed
plugged
dynamically
without
side
effects
scheme
allows
us
abstract
core
set
communication
services
share
different
messengers
node
simplifying
synchronization
composition
process
encouraging
separation
concerns
process
message
transmission
reception
order
maintain
accurate
semantics
provide
efficient
implementation
architecture
communication
manager
implements
set
meta
level
representatives
called
pool
actors
instance
pool
actor
handles
communication
services
requested
messenger
individual
message
words
every
message
requiring
communication
services
assigned
pool
actor
pool
actor
assures
correct
order
composition
required
services
provides
coordination
mechanism
messenger
requires
services
protocols
provide
concept
reusable
pool
actors
efficient
way
handle
service
request
messenger
without
pay
bottleneck
associated
centralization
services
node
communication
manager
summary
notion
pool
actors
provides
separation
concerns
manageable
concurrency
communication
process
back
top
compose
runtime
architecture
current
middleware
environment
implemented
using
java
due
many
favorable
features
portability
across
wide
variety
platforms
wide
user
base
support
flexibility
introspection
approach
suitably
'constrain'
java
programming
language
achieve
actor
semantics
order
assist
three
core
services
achieving
task
easily
efficiently
run
time
system
consists
nodemanager
manages
coordinates
various
components
node
nodeinfomanager
manages
information
needed
local
actors
interfaces
directory
service
communication
sub
system
handles
messaging
actors
nodemanager
node
running
compose
one
nodemanager
manage
actors
node
well
start
shutdown
various
modules
run
time
system
new
actor
created
registers
nodemanager
identified
actor
id
aid
nodemanager
enters
new
actor
local
table
helps
keep
track
actor
activities
node
checkpointing
node
shutdown
notifies
messageqmanager
entity
allocates
message
queue
serves
queue
actor
messageqmanager
responsible
managing
mail
queues
actors
node
start
compose
node
nodemanager
started
first
turn
initiates
various
modules
communication
components
nodeinfomanager
nodeinfomanager
repository
information
well
interface
main
directory
service
distributed
architecture
currently
nodeinfomanager
implements
basic
functionality
1
register
actor
directory
service
accessible
nodes
2
search
particular
actor
find
node
actor
currently
3
search
actor
object
given
class
name
rudimentary
naming
service
nodeinfomanager
local
table
contains
references
local
actors
updated
maintained
nodemanager
remote
actor
cache
contains
information
recently
accessed
remote
actors
communication
subsystem
communication
transport
layer
crcf
module
transport
layer
together
compose
node
communication
subsystem
message
transport
layer
provides
framework
sending
outgoing
messages
appropriate
node
routing
resolving
incoming
messages
appropriate
actor
queues
message
resolution
crcf
module
responsible
implementation
communication
services
composition
separation
layers
allows
independent
customization
protocol
implementations
messaging
runtime
facilitates
correct
composition
protocols
without
interfering
runtime
communication
semantics
communication
transport
layer
consists
following
components
router
postman
remotemessagereceiver
transport
layer
maintains
two
message
queues
node
incoming
outgoing
messages
node
called
sendpot
receivepot
respectively
router
consults
nodeinfomanager
obtain
current
location
node
target
actor
location
target
actor
local
node
router
puts
message
directly
node's
receivepot
otherwise
sends
message
remote
node
remotemessagereceiver
rmr
target
node
extracts
incoming
message
puts
node's
receivepot
postman
picks
message
adds
target
actor's
queue
communication
manager
instantiated
node
system
startup
actor
created
protocol
composition
services
desired
required
ts
messenger
created
actor
sends
receives
raw
messages
using
transport
layer
flexible
communication
required
desired
independent
messenger
created
every
base
level
actor
entire
crcf
functionality
invoked
overhead
crcf
module
minimized
case
communications
protocols
attached
scenario
tunnel
raw
messages
actor's
messenger
directly
transport
layer
back
top
