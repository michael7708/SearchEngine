deterministic selection 
graph algorithms 
ics
161
design
analysis
algorithms
lecture
notes
february
1
1996
graph
algorithms
graph
abstract
notion
used
represent
idea
kind
connection
pairs
objects
graph
consists
collection
vertices
usually
draw
small
circles
blackboard
anda
collection
edges
connecting
two
vertices
usually
draw
curves
blackboard
connecting
given
pair
vertices
definition
matter
vertices
edges
represent
will
different
depending
application
graph
comes
also
matter
draw
graph
part
matters
pairs
vertices
connected
two
different
types
graph
commonly
see
one
type
known
undirected
graph
matter
end
graph
relation
two
symmetric
case
just
draw
edges
undecorated
curve
instance
suppose
draw
graph
one
vertex
every
person
one
edge
connecting
two
people
shaken
hands
shaken
hands
shaken
hands
edge
symmetric
seems
true
graphs
like
small
em
diameter
can
connect
two
people
short
chain
handshakes
type
graph
known
directed
graph
edge
goes
one
vertices
towards
case
draw
arrowhead
vertex
towards
edge
going
drew
graph
like
handshake
graph
described
instead
connected
two
people
one
written
letter
result
directed
written
letter
may
written
letter
back
whenever
talk
graphs
use
denote
number
vertices
denote
number
edges
notation
confusing
stick
standard
also
use
denote
set
vertices
graph
denote
set
edges
examples
graphs
tree
graph
fact
trees
can
defined
undirected
graphs
connected
path
two
vertices
acyclic
sequences
edges
go
around
loop
also
possible
define
trees
terms
directed
graphs
connected
graph
least
1
edges
acyclic
graph
1
edges
tree
exactly
1
edges
last
lecture
saw
notation
decision
trees
connected
two
circles
representing
objects
sorted
downward
edge
comparison
done
found
one
greater
example
directed
graph
comparison
graph
notation
useful
solving
homework
3
19
asked
find
element
among
smallest
values
among
value
set
simple
method
uses
exactly
comparisons
just
find
minimum
first
1
values
list
prove
optimal
suppose
found
value
know
smallest
values
therefore
must
able
show
comparisons
made
least
values
larger
draw
comparison
graph
comparisons
made
must
part
connected
region
1
values
counting
region
least
edges
must
made
many
comparisons
third
example
graph
family
tree
draw
vertex
member
family
directed
edge
parent
child
really
tree
exercise
give
two
reasons
many
families
structure
similar
tree
typical
graph
algorithm
problems
example
determine
two
people
related
draw
graph
nice
picture
family
tree
can
represent
airline
schedules
graph
vertices
correspond
airports
edges
correspond
flights
unlike
previous
examples
extra
information
can
attach
graph
instance
might
store
time
cost
airline
flight
typical
graph
algorithm
problem
might
find
cheapest
route
city
city
allowing
stops
vlsi
circuit
design
consists
collection
components
gates
transistors
connected
wires
can
think
components
vertices
wires
edges
typical
problem
translate
list
electrical
connections
design
chip
another
problem
electronics
comes
printed
circuit
board
manufacturing
pc
board
made
fiberglass
wires
connecting
places
chips
plugged
one
step
making
pc
boards
involves
drilling
holes
chips
go
holes
connecting
wires
different
layers
board
want
able
plan
movement
drill
one
hole
next
spend
much
time
moving
can
make
graph
vertices
represent
holes
two
vertices
connected
edge
labeled
amount
time
take
move
drill
one
hole
complete
graph
since
every
possible
edge
representation
drill
scheduling
problem
becomes
one
finding
shortest
path
graph
visits
every
vertex
exactly
famous
problem
traveling
salesman
problem
will
see
much
later
class
example
np
complete
problem
evidence
exist
good
algorithm
solve
exactly
however
can
find
path
pretty
close
optimal
solution
using
minimum
spanning
trees
explained
next
week
compiler
design
one
problem
compiler
must
deal
variable
code
find
machine
register
can
store
value
variable
typically
just
assign
one
one
likely
variables
registers
two
variables
used
different
parts
code
safe
combine
store
register
can
draw
graph
variables
correspond
vertices
edge
shows
two
variables
exist
time
register
assignment
becomes
graph
coloring
problem
np
complete
reasonable
heuristics
known
graphs
occurring
application
final
example
comes
task
scheduling
suppose
managing
project
consisting
sequence
several
tasks
performed
example
used
class
writing
revising
handing
grading
midterm
another
comes
compiler
design
determining
order
perform
sequence
instructions
tasks
performed
others
always
case
one
fixed
global
order
everything
can
draw
graph
vertex
represents
task
directed
edge
says
one
task
pretty
similar
ways
comparison
graph
drew
analyzing
decision
trees
one
important
graph
problem
topological
sorting
consists
finding
global
ordering
consistent
local
constraints
another
determining
enough
people
work
many
different
tasks
possible
much
time
take
whole
job
equivalent
finding
longest
path
graph
see
later
longest
path
algorithm
uses
topological
sorting
important
subroutine
seen
many
problems
can
reformulated
graph
problems
hides
unnecessary
complications
problem
making
important
structure
obvious
making
easier
find
solution
translation
graph
problem
also
advantaged
several
different
real
world
problems
end
looking
like
graph
problem
finding
good
algorithm
one
problem
many
applications
representation
graphs
order
perform
graph
algorithms
computer
decide
store
graph
talk
graphs
draw
diagram
circles
lines
blackboard
computers
good
interpreting
sort
input
instead
need
representation
closer
abstract
definition
graph
several
possibilities
different
uses
go
lecture
left
incidence
list
incidence
matrix
object
oriented
representation
obvious
thing
just
copy
definition
gave
graph
structure
vertex
representing
whatever
information
want
store
another
structure
edge
pointers
two
vertices
connects
representation
little
difficult
work
unless
edges
ordered
carefully
will
difficult
find
ones
want
example
might
graph
four
vertices
call
four
edges
object
oriented
representation
just
list
array
structures
objects
total
space
used
representation
just
since
constant
amount
space
one
structure
per
vertex
edge
operations
representation
involve
scanning
whole
list
edges
take
time
adjacency
list
adjacency
list
representation
vertex
keeps
linked
list
neighboring
vertices
edges
really
appear
graph
lists
vertex
representation
makes
much
easier
find
edges
connected
particular
vertex
space
still
also
small
since
total
length
lists
2m
edge
appears
twice
endpoints
also
quite
fast
many
applications
slowest
operation
might
commonly
used
testing
whether
pair
vertices
connected
edge
done
scanning
one
lists
speed
sorting
adjacency
lists
using
binary
search
another
disadvantage
edge
listed
twice
edges
carry
extra
information
length
may
complicated
keep
track
copies
make
sure
information
incidence
list
combining
adjacency
list
object
oriented
representation
get
something
advantages
just
add
object
oriented
representation
list
vertex
pointers
edges
incident
specify
representation
probably
mind
space
little
larger
previous
two
representations
still
adjacency
matrix
situations
willing
use
somewhat
larger
data
structure
can
test
quickly
whether
edge
exists
make
matrix
rows
columns
indexed
vertices
edge
present
put
one
cell
otherwise
leave
zero
finding
neighbors
vertex
involves
scanning
row
time
test
edge
exists
just
look
entry
constant
time
store
extra
information
like
edge
lengths
can
just
use
matrices
graph
matrix
0
1
1
0
1
0
1
0
1
1
0
1
0
0
1
0
occasionally
useful
performing
graph
computations
linear
algebra
instance
take
kth
power
matrix
entry
will
nonzero
corresponding
vertices
connected
path
edges
undirected
graphs
matrix
will
symmetric
incidence
matrix
another
matrix
generally
rectangular
rather
square
rows
indexed
vertices
columns
edges
just
like
adjacency
matrix
put
one
cell
corresponding
vertex
edge
incident
therefore
every
column
will
exactly
two
ones
directed
graph
can
make
similar
matrix
every
column
one
1
one
1
entry
matrix
usually
symmetric
graph
incidence
matrix
1
0
1
0
1
1
0
0
0
1
1
1
0
0
0
1
connectivity
warmup
graph
algorithms
start
simple
problem
graph
connected
always
airline
route
everyone
family
tree
related
everyone
else
can
scheduling
task
split
two
parts
can
done
different
departments
company
rough
outline
start
vertex
build
list
vertices
can
get
time
find
new
vertex
added
list
check
neighbors
see
added
well
finally
check
whether
list
covers
whole
graph
pseudocode
test
connected
choose
vertex
make
list
vertices
reachable
another
list
vertices
explored
initially
nonempty
find
remove
vertex
edge
add
fewer
items
return
disconnected
else
return
connected
analyze
algorithm
first
notice
outer
loop
happens
times
per
vertex
time
inner
loop
finding
unreached
neighbors
complicated
depends
graph
representation
one
key
step
testing
whether
seems
like
might
slow
can
done
quickly
keeping
bit
vertex
says
whether
object
oriented
representation
execution
inner
loop
involves
scanning
edges
graph
total
time
algorithm
mn
adjacency
matrix
representation
execution
inner
loop
involves
looking
single
row
matrix
time
total
time
algorithm
2
adjacency
list
incidence
list
representation
element
list
scanned
total
time
executions
inner
loop
total
length
adjacency
lists
2m
note
multiply
even
though
nested
loop
just
add
number
times
statement
executed
overall
algorithm
total
time
algorithm
end
algorithm
list
tells
one
connected
component
graph
much
graph
can
reached
care
can
find
components
rather
just
one
component
graph
connected
can
modify
algorithm
find
tree
covering
vertices
spanning
tree
let
parent
vertex
corresponding
time
added
gives
graph
vertex
except
connected
previous
vertex
graph
must
tree
analyzing
algorithm
pay
attention
order
put
vertices
removed
different
orders
produce
different
trees
put
vertices
end
take
front
acts
like
queue
get
breadth
first
search
parent
always
close
possible
gives
shortest
paths
everything
else
tree
short
bushy
instead
add
remove
vertices
end
acts
like
stack
get
depth
first
search
tends
produce
long
stringy
spanning
trees
useful
properties
see
later
ics
161
dept
information
computer
science
uc
irvine
last
update
02
may
2000
20
17
37
pdt
