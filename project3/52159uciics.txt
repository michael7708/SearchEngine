self referential classes linked objects 

self
referential
classes
linked
objects
introduction
computer
science
ii
ics
22
introduction
lecture
will
begin
studying
self
referential
classes
leaded
linked
objects
initially
will
discuss
great
detail
simplest
kind
linked
objects
linear
linked
lists
later
week
will
discuss
advanced
linked
list
lists
header
trailer
nodes
circular
lists
doubly
linked
lists
etc
end
quarter
will
also
fully
discussed
generally
non
linear
self
referential
structures
trees
graphs
linear
linked
structures
used
like
arrays
store
sequence
values
will
soon
examine
use
kinds
linked
structures
implement
many
different
collection
classes
also
already
seen
implementations
collection
classes
using
arrays
deciding
whether
use
array
linked
structure
implementing
class
depends
ease
implementation
performance
time
space
complexity
classes
expressed
big
notation
will
make
come
back
ln
class
major
topic
discussion
next
days
use
slight
generalization
private
static
instead
public
object
replacing
int
following
class
public
class
ln
public
ln
int
ln
value
next
public
int
value
public
ln
next
read
ln
abbreviation
list
node
may
seem
odd
make
fuss
simple
class
one
contains
constructor
along
two
public
instance
variables
accessors
mutators
needed
retrieve
alter
contents
key
interestingness
every
object
constructed
ln
contains
next
instance
variable
stores
null
reference
another
object
class
value
null
used
indicate
last
node
list
list
node
following
thus
null
references
serve
important
purpose
now
use
null
java
reported
nullpointerexception
trying
call
method
variable
typically
member
array
stored
null
refer
object
data
structures
arise
repeatedly
constructing
objects
class
similar
content
arrays
store
sequence
values
example
one
structure
shown
notice
last
next
instance
variables
stores
null
although
picture
accurate
also
cumbersome
draw
instead
will
often
abbreviate
pictures
shown
notice
picture
blurs
important
distinction
object
instance
variables
addition
value
null
appears
just
slash
final
object
ensure
know
draw
real
pictures
adopting
shorthand
note
placement
ln
objects
page
exact
places
arrows
point
ln
object
really
refer
whole
object
irrelevant
relevant
able
follow
references
one
object
next
one
etc
pictorial
representations
data
will
important
need
visualize
complicated
data
structures
operations
perform
note
following
accesses
classes
values
cascaded
access
chain
ending
value
specifies
instance
variable
storing
int
cascaded
access
chain
ending
next
specifies
instance
variable
storing
null
reference
next
ln
object
specifies
variable
stores
reference
first
object
class
ln
value
specifies
instance
variable
first
object
stores
int
5
next
specifies
instance
variable
first
object
stores
reference
second
object
class
ln
next
value
specifies
instance
variable
second
object
stores
int
3
next
next
specifies
instance
variable
second
object
stores
reference
third
object
class
ln
next
next
value
specifies
instance
variable
third
object
stores
int
8
next
next
next
next
next
next
specifies
instance
variable
sixth
object
stores
null
last
object
can
store
null
otherwise
link
broken
traversing
linked
lists
via
cursors
arrays
main
processing
linked
lists
traverse
visiting
somehow
processing
every
value
store
example
following
code
computes
sum
values
contained
linked
list
note
similarity
loop
processing
sequence
integers
stored
array
int
sum
0
ln
null
next
sum
value
system
println
sum
sum
loop's
parts
initialize
reference
refer
first
object
linked
list
using
standard
semantics
copying
references
test
ensure
still
refers
object
linked
list
values
null
advance
refer
next
object
linked
list
possibly
null
objects
refer
tthe
statement
next
key
understanding
traverse
linked
lists
linked
list
equivalent
processing
arrays
following
picture
hand
simulation
illustrates
takes
successive
references
objects
linked
list
summing
value
instance
variable
compare
loop
equivalent
loop
adding
values
array
uses
special
variable
shall
now
call
cursor
step
every
value
respective
data
structures
generally
cursor
small
value
refers
specific
location
data
structure
can
store
many
values
often
use
term
cursor
refers
one
seen
text
editor
cursor
refers
location
characters
will
entered
deleted
among
many
characters
file
arrays
cursor
int
index
linked
lists
cursor
reference
object
linked
list
check
array
cursors
numerically
determine
whether
still
small
enough
refer
index
value
array
check
linked
list
cursors
null
determine
whether
still
refer
object
linked
list
advance
array
cursors
incrementing
advance
linked
list
cursors
via
statement
like
next
updates
refer
next
value
beyond
one
current
refers
loop
java
thus
general
enough
compactly
specify
information
needed
traversing
lists
examples
code
linked
list
processing
examples
processing
linked
list
code
via
traversals
encourage
hand
simulate
code
become
comfortable
processing
linked
lists
traversals
can
often
look
array
code
figure
often
linked
list
code
especially
subtle
need
perform
hand
simuation
understand
debug
first
code
fragments
prints
values
stored
linked
list
commas
values
ln
null
next
system
println
value
next
null
next
assume
declare
decisionint
criteria
store
reference
object
constructed
class
implements
decisionint
interface
can
modify
code
print
ok
values
linked
list
put
commas
values
see
use
commas
values
approach
boolean
first
true
ln
null
next
criteria
isok
value
system
println
first
value
first
false
next
static
method
computing
length
linked
list
public
static
int
length
ln
int
answer
0
ln
null
next
answer
return
answer
following
picture
illustrates
hand
simulation
method
using
static
call
frame
first
transmitting
argument
reference
parameter
reference
can
simplify
code
method
using
parameter
traverse
list
public
static
int
length
ln
int
answer
0
null
next
answer
return
answer
executing
code
sill
leaves
refering
list
still
returns
value
4
parameter
changes
matching
argument
just
receives
initial
value
argument
many
cases
methods
written
inside
classes
use
one
instance
variables
referring
beginning
linked
list
need
write
loop
declares
new
variable
traversing
list
leaving
instance
variable
unchanged
next
another
static
method
time
computing
number
times
int
value
occurs
list
public
static
int
countoccurences
ln
int
tocheck
int
answer
0
ln
null
next
value
tocheck
answer
return
answer
frequently
case
loops
traversing
linked
lists
case
loops
traversing
arrays
pattern
initializing
testing
advancing
used
also
seen
arrays
code
slight
variants
illustrated
code
computes
whether
linked
list
sorted
ascending
actually
non
descending
order
public
static
boolean
issorted
ln
ln
null
next
null
next
value
next
value
return
false
return
true
notice
complicated
test
continuation
termination
either
stores
null
refers
object
whose
next
instance
variables
stores
null
examine
method
works
carefully
passed
empty
list
null
parameter
reference
linked
list
contains
just
one
object
cases
linked
sorted
find
pair
values
order
short
circuit
evaluation
critical
null
false
evaluating
next
null
throw
nullpointerexception
evaluated
building
linked
lists
easy
update
variable
null
refering
empty
list
refer
list
one
value
say
5
new
ln
5
null
likewise
can
extend
list
second
value
say
2
writing
next
new
ln
2
null
can
extend
list
third
value
say
7
writing
next
next
new
ln
7
null
can
continue
manner
build
linked
list
manually
fact
can
even
write
one
complicated
assignment
new
ln
5
new
ln
2
new
ln
7
null
method
requires
us
write
code
manually
every
linked
list
must
build
now
let
us
examine
ways
build
lists
automatically
say
reading
values
file
following
simple
code
reads
values
file
assume
typedbufferreader
tbr
declared
intialized
places
linked
list
try
new
ln
tbr
readint
catch
eofexception
eofe
break
note
size
equal
sign
generally
code
new
ln
somevalue
adds
somevalue
front
list
whether
list
originally
empty
try
ways
making
next
refer
original
linked
list
note
executing
statement
new
ln
tbr
readint
complexity
class
1
matter
big
list
refers
operation
completed
constant
time
independent
list
size
thus
since
operation
executed
times
complexity
class
reading
list
drawback
code
values
appear
linked
list
reverse
order
appear
file
may
may
problem
depending
want
process
data
hand
simulate
code
reading
file
just
values
verify
statement
need
sequence
values
stored
order
appeared
file
many
possible
ways
accomplish
task
first
can
reverse
list
see
next
lecture
make
code
complicated
examine
code
needed
place
new
list
node
rear
linked
list
strategy
can
easily
described
list
empty
change
refer
new
list
node
list
empty
locate
last
list
node
one
currently
storing
null
next
instance
variable
store
reference
new
list
node
next
field
cases
new
list
node
stores
null
next
instance
variable
becoming
new
last
node
list
assume
int
somevalue
stores
value
want
add
end
list
can
translate
description
following
java
code
null
new
ln
somevalue
null
else
ln
next
null
next
next
new
ln
somevalue
null
interesting
aspects
code
cursor
must
declared
outside
loop
inside
reason
made
refer
current
last
node
list
must
altered
loop
terminates
variable
declared
inside
loop
usable
outside
loop
body
purpose
loop
store
reference
current
last
node
list
advance
refers
list
node
whose
next
stores
null
note
body
loop
just
empty
block
statement
replaced
just
empty
statement
prefer
emphasize
lack
actions
empty
block
programmers
even
write
nothing
body
loop
continuation
test
next
null
first
time
check
test
know
stores
non
null
reference
see
statement
likewise
subsequent
loop
know
updated
next
will
also
store
non
null
value
thus
code
will
never
throw
nullpointerexception
alternative
way
write
code
less
elegant
opinion
possibly
easier
understand
null
new
ln
somevalue
null
else
ln
next
continuation
test
always
true
next
null
next
new
ln
somevalue
null
break
given
code
adding
new
value
end
linked
list
can
now
write
code
reads
values
file
places
linked
list
correct
order
using
two
nested
loops
try
int
somevalue
tbr
readint
null
new
ln
somevalue
null
else
ln
next
null
next
next
new
ln
somevalue
null
catch
eofexception
eofe
break
although
code
correct
can
inefficient
complexity
class
number
values
read
n2
source
inefficiency
repeatedly
scanning
linked
list
find
end
first
time
requires
scanning
past
0
nodes
second
time
requires
scanning
past
1
node
third
time
requires
scanning
past
2
nodes
nth
time
requires
scanning
past
1
nodes
insert
nodes
list
requires
scanning
0
1
2
1
nodes
seen
memorize
already
general
formula
1
2
1
2
case
result
1
1
1
2
1
2
course
complexity
class
n2
inserting
1
000
nodes
list
requires
scanning
499
500
nodes
inserting
1
000
000
nodes
list
requires
scanning
500
000
000
000
nodes
even
1
billon
scans
per
second
take
8
minutes
everett
dirkson
ancient
senator
illinois
quoted
billion
dollars
billion
dollars
pretty
soon
adds
real
money
later
day
dirkson
one
computer
science
might
say
nanoseconds
adding
real
time
can
drastically
speed
process
changing
complexity
class
back
caching
reference
last
node
list
updating
whenever
new
node
added
end
way
can
eliminate
scanning
altogether
another
way
look
scanning
newly
added
list
node
remembering
similar
amortized
complexity
computations
technique
caching
wonderful
example
space
time
tradeoff
increasing
amount
space
storing
extra
reference
can
decrease
amount
running
time
code
accomplish
task
efficiently
time
bit
less
space
ln
lastcache
null
try
int
somevalue
tbr
readint
lastcache
null
lastcache
new
ln
somevalue
null
else
lastcache
next
new
ln
somevalue
null
lastcache
lastcache
next
catch
eofexception
eofe
break
fact
extra
bonus
code
even
simpler
less
confusing
code
shown
understand
lastcache
initialized
used
java
masochists
simplify
else
block
writing
single
statement
similarly
appears
else
lastcache
lastcache
next
new
ln
somevalue
null
whose
double
assignment
job
statements
block
notice
lastcache
next
lastcache
new
ln
somevalue
null
order
two
values
receiving
assignment
fails
job
problem
set
ensure
understand
material
lecture
please
solve
announced
problems
read
lecture
get
stumped
problem
go
back
read
relevant
part
lecture
still
questions
please
get
help
instructor
ta
student
hand
simulate
following
code
fragment
empty
list
first
list
containing
one
object
refers
linked
lists
illustrate
beginning
lecture
ln
answer
null
null
ln
tomove
next
tomove
next
answer
answer
tomove
answer
describe
result
using
incorrect
statement
lastcache
next
lastcache
new
ln
somevalue
null
code
reads
values
file
puts
list
sequential
order
file
3
values
code
throw
exception
final
list
look
like
