knuth morris pratt algorithm 
kmp string matching algorithm 
ics
161
design
analysis
algorithms
lecture
notes
february
27
1996
knuth
morris
pratt
string
matching
problem
given
short
pattern
long
text
strings
determine
whether
pattern
appears
somewhere
text
last
time
saw
finite
automata
time
go
knuth
morris
pratt
kmp
algorithm
can
thought
efficient
way
build
automata
also
working
source
code
might
help
understand
algorithm
better
first
look
naive
solution
suppose
text
array
char
pattern
another
array
char
one
simple
method
just
try
possible
position
pattern
appear
text
naive
string
matching
0
'
0'
0
'
0'
'
0'
'
0'
found
match
two
nested
loops
inner
one
takes
iterations
outer
one
takes
iterations
total
time
product
mn
slow
like
speed
practice
works
pretty
well
usually
bad
mn
worst
case
analysis
inner
loop
usually
finds
mismatch
quickly
move
next
position
without
going
steps
method
still
can
take
mn
inputs
one
bad
example
characters
's
except
one
end
takes
comparisons
time
discover
match
mn
overall
typical
example
row
represents
iteration
outer
loop
character
row
representing
result
comparison
comparison
unequal
suppose
looking
pattern
nano
text
banananobano
0
1
2
3
4
5
6
7
8
9
10
11
0
1
2
3
4
5
6
7
8
9
10
comparisons
wasted
work
instance
iteration
2
know
comparisons
done
3
point
comparing
iteration
3
also
know
4
point
making
comparison
iteration
4
skipping
outer
iterations
knuth
morris
pratt
idea
sort
situation
invested
lot
work
making
comparisons
inner
loop
code
know
lot
text
specifically
found
partial
match
characters
starting
position
know
positions
1
can
use
knowledge
save
work
two
ways
first
can
skip
iterations
match
possible
try
overlapping
partial
match
found
new
match
want
find
2
3
two
placements
pattern
conflict
know
2
iteration
3
4
3
iteration
looking
can
keep
skipping
positions
find
one
conflict
2
4
two
's
coincide
define
overlap
two
strings
longest
word
suffix
prefix
overlap
nan
nano
just
allow
overlap
nan
general
value
want
skip
one
corresponding
largest
overlap
current
partial
match
string
matching
skipped
iterations
0
0
'
0'
'
0'
'
0'
found
match
max
1
overlap
0
1
0
skipping
inner
iterations
optimization
can
done
skip
iterations
inner
loop
look
example
skipped
2
4
2
4
example
overlaps
already
tested
2
iteration
need
test
4
iteration
general
nontrivial
overlap
last
partial
match
can
avoid
testing
number
characters
equal
length
overlap
change
produces
version
kmp
algorithm
kmp
version
1
0
0
'
0'
'
0'
'
0'
found
match
overlap
0
1
0
max
1
remaining
detail
compute
overlap
function
function
characters
can
compute
preprocessing
stage
get
part
algorithm
first
see
fast
algorithm
kmp
time
analysis
still
outer
loop
inner
loop
looks
like
time
might
still
mn
can
count
different
way
see
actually
always
less
idea
every
time
inner
loop
one
comparison
can
count
total
time
algorithm
counting
many
comparisons
perform
split
comparisons
two
groups
return
true
return
false
comparison
returns
true
determined
value
future
iterations
long
nontrivial
overlap
involving
skip
past
overlap
make
comparison
position
position
involved
one
true
comparison
can
comparisons
total
hand
one
false
comparison
per
iteration
outer
loop
can
also
result
see
part
kmp
algorithm
makes
2n
comparisons
takes
time
kmp
finite
automata
look
just
happens
algorithm
sort
like
finite
automaton
step
set
either
1
inner
loop
match
overlap
mismatch
step
value
just
function
depend
information
like
characters
can
draw
something
like
automaton
arrows
connecting
values
labeled
matches
mismatches
difference
automata
used
two
arrows
circle
instead
one
per
character
can
still
simulate
just
like
automaton
placing
marker
start
state
0
moving
around
arrows
whenever
get
matching
character
move
next
character
text
whenever
get
mismatch
look
character
next
step
except
case
mismatch
state
0
example
one
automaton
goes
sequence
states
0
mismatch
0
0
mismatch
1
0
match
2
1
match
3
2
match
4
3
mismatch
5
1
match
5
2
match
6
3
match
7
4
found
match
0
mismatch
8
0
mismatch
9
0
match
10
1
mismatch
11
0
mismatch
11
essentially
sequence
comparisons
done
kmp
pseudocode
automaton
provides
equivalent
definition
kmp
algorithm
one
student
pointed
lecture
one
transition
automaton
may
clear
one
4
0
general
transition
smaller
value
happen
character
matches
test
making
transition
want
find
occurrences
pattern
able
find
occurrence
even
overlaps
another
one
instance
pattern
nana
find
occurrences
text
nanana
transition
go
next
longest
position
can
match
simply
overlap
pattern
pattern
case
overlap
nano
nano
empty
suffixes
nano
use
letter
prefix
go
0
alternate
version
kmp
automaton
can
translated
back
pseudo
code
looking
little
different
pseudo
code
saw
performing
comparisons
kmp
version
2
0
0
loop
break
matches
yes
move
next
state
maybe
last
state
found
match
overlap
break
else
0
break
match
state
0
give
else
overlap
try
shorter
partial
match
code
inside
iteration
outer
loop
essentially
function
match
implementation
made
available
one
advantage
version
code
tests
characters
one
one
rather
performing
random
access
array
implementation
can
made
work
stream
based
input
rather
read
whole
text
memory
first
overlap
array
stores
values
overlap
pattern
0
1
pattern
still
need
show
compute
since
algorithm
performs
comparisons
version
kmp
takes
amount
time
one
way
proving
bound
directly
note
first
one
true
comparison
per
iteration
outer
loop
since
break
inner
loop
happens
total
comparisons
results
increasing
one
iteration
inner
loop
break
loop
results
executing
statement
overlap
decreases
since
can
decrease
many
times
increased
total
number
times
happens
also
computing
overlap
function
recall
defined
overlap
two
strings
longest
word
suffix
prefix
missing
component
kmp
algorithm
computation
overlap
function
need
know
overlap
0
1
value
0
computed
values
can
store
array
look
need
compute
overlap
functions
need
know
strings
just
longest
word
suffix
prefix
words
key
fact
notice
suffix
prefix
longest
word
also
suffix
overlap
follows
simply
fact
suffix
shorter
overlap
can
list
words
suffixes
prefixes
following
loop
empty
overlap
output
now
make
another
definition
say
shorten
prefix
one
fewer
character
next
simple
observation
make
shorten
overlap
still
prefix
also
suffix
shorten
can
find
overlap
adding
one
character
word
suffix
shorten
prefix
can
just
find
words
using
loop
return
first
one
adding
one
character
produces
valid
overlap
overlap
computation
overlap
shorten
last
char
length
empty
return
overlap
empty
else
overlap
return
overlap
gives
us
recursive
algorithm
computing
overlap
function
general
apply
algorithm
prefix
pattern
pattern
see
recursive
calls
similar
arguments
store
value
compute
can
look
instead
computing
simple
idea
storing
results
instead
recomputing
known
dynamic
programming
discussed
somewhat
first
lecture
will
see
detail
next
time
replacing
0
1
0
1
pseudocode
replacing
recursive
calls
lookups
previously
computed
values
gives
us
routine
problem
trying
solve
computing
particular
overlap
values
following
pseudocode
taken
names
changed
initialization
code
implementation
made
available
value
overlap
0
just
flag
make
rest
loop
simpler
code
inside
loop
part
computes
overlap
value
kmp
overlap
computation
overlap
0
1
int
0
pattern
'
0'
overlap
1
overlap
1
overlap
1
0
pattern
pattern
overlap
1
1
overlap
1
overlap
overlap
1
1
1
return
overlap
finish
analyzing
time
taken
part
kmp
algorithm
outer
loop
executes
times
iteration
inner
loop
decreases
value
formula
overlap
1
formula's
value
increases
one
move
one
iteration
outer
loop
next
since
number
decreases
number
increases
inner
loop
also
iterations
total
time
algorithm
entire
kmp
algorithm
consists
overlap
computation
followed
main
part
algorithm
scan
text
using
overlap
values
speed
scan
first
part
takes
second
part
takes
time
total
time
ics
161
dept
information
computer
science
uc
irvine
last
update
02
may
2000
20
17
38
pdt
