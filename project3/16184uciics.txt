shortest paths topological ordering 
shortest paths topological ordering 
ics
161
design
analysis
algorithms
lecture
notes
february
8
1996
shortest
paths
basic
problem
find
best
way
getting
vertices
graph
measure
best
simply
sum
edge
lengths
path
instance
graph
map
representing
intersections
vertices
road
segments
edges
want
find
either
shortest
fastest
route
house
ics
although
problems
different
solutions
shortest
path
problems
one
length
edge
represents
actual
mileage
segment
road
represents
time
take
drive
cases
important
fact
total
length
path
measured
adding
lengths
individual
edges
another
example
mentioned
first
lecture
graph
algorithms
graph
might
vertices
representing
airports
edges
representing
possible
flights
length
edge
measuring
cost
taking
flight
problem
find
cheapest
flight
sna
jfk
note
graphs
may
directed
may
one
way
road
flights
one
direction
might
different
costs
way
going
make
big
assumption
edges
lengths
positive
numbers
often
always
case
makes
sense
examples
conceivable
airline
pay
people
take
certain
routes
lengths
edges
airport
graph
might
negative
pretend
never
happens
makes
algorithms
lot
easier
later
see
special
cases
can
handle
negative
weights
rather
computing
one
distance
compute
vertices
known
single
source
shortest
path
problem
source
turns
computing
extra
information
makes
things
easier
can
put
together
information
paths
fewer
edges
get
paths
edges
paths
distances
suppose
already
know
distances
every
vertices
solution
shortest
path
problem
want
know
actual
paths
distances
can
find
paths
two
kinds
shortest
paths
formed
single
edge
path
goes
vertices
say
last
vertex
path
goes
second
case
overall
path
must
formed
concatenating
path
edge
can
view
types
shortest
path
similar
think
shortest
path
one
edges
path
must
shortest
path
since
otherwise
concatenating
shortest
path
decrease
length
overall
path
final
observation
must
less
since
length
assuming
edges
positive
length
therefore
know
correct
value
can
find
shortest
path
algorithm
1
vertex
sorted
order
let
edge
length
path
path
edge
will
want
use
something
like
idea
compute
shortest
paths
without
already
knowing
lengths
get
loop
will
still
ok
use
terms
like
less
will
already
processed
previous
iteration
pseudo
code
uses
twice
will
work
well
get
rid
second
use
test
determine
edge
use
can
notice
computing
shortest
path
length
will
less
similar
expression
instead
testing
equality
can
just
find
minimum
algorithm
2
vertex
sorted
order
let
edge
already
processed
minimizing
length
path
path
edge
length
dijkstra's
algorithm
remaining
use
algorithm
determine
order
process
vertices
dijkstra's
algorithm
shortest
paths
almost
exactly
like
prim's
algorithm
remember
prim's
algorithm
add
vertices
edges
one
time
tree
step
choosing
shortest
possible
edge
add
dijkstra's
algorithm
thing
choosing
edge
add
step
one
minimizing
length
algorithm
3
dijkstra
basic
outline
let
single
vertex
fewer
vertices
find
edge
minimizing
length
add
length
actual
shortest
paths
can
found
following
path
defines
structure
known
shortest
path
tree
practice
may
sometimes
faster
build
two
trees
one
one
stop
run
usually
ends
visiting
less
graph
just
like
prim's
algorithm
can
use
heaps
perform
hard
part
iteration
finding
best
edge
logarithmic
time
algorithm
4
dijkstra
heaps
make
heap
values
vertex
edge
distance
initially
infinity
vertex
let
tree
empty
fewer
vertices
let
smallest
weight
heap
remove
heap
add
set
distance
edge
already
find
value
heap
length
replace
length
just
prim's
algorithm
runs
time
log
use
binary
heaps
log
use
fibonacci
heaps
dijkstra
negative
lengths
dijkstra's
algorithm
work
negative
edge
weights
instance
consider
following
graph
assume
edges
directed
left
right
2
3
2
start
dijkstra's
algorithm
will
choose
edge
minimizing
length
edge
namely
sets
2
chooses
another
edge
minimizing
choice
sets
3
never
finds
shortest
path
via
total
length
1
topological
ordering
shortest
paths
important
class
graphs
shortest
paths
can
computed
quickly
linear
time
idea
go
back
algorithms
1
2
required
visit
vertices
order
algorithms
defined
order
sorted
distance
seen
works
positive
weight
edges
negative
weights
another
ordering
always
works
define
topological
ordering
directed
graph
one
whenever
edge
ordering
visits
can
define
ordering
can
something
like
algorithm
2
sure
predecessor
vertex
always
processed
process
algorithm
5
shortest
paths
topological
order
vertex
topological
ordering
choose
edge
minimizing
length
path
path
edge
length
runs
linear
time
possible
exception
finding
ordering
works
even
graph
negative
length
edges
can
even
use
find
longest
paths
just
negate
lengths
edges
catch
works
can
find
topological
ordering
topological
ordering
acyclic
graphs
define
directed
acyclic
graph
often
known
dag
short
directed
graph
containing
cycle
cycle
set
edges
forming
loop
pointing
way
around
loop
theorem
graph
topological
ordering
directed
acyclic
graph
one
direction
proof
simple
suppose
dag
cycle
ordering
one
vertex
cycle
come
first
one
two
cycle
edges
vertex
point
wrong
way
ordering
topological
direction
prove
every
graph
without
topological
ordering
contains
cycle
prove
finding
algorithm
constructing
topological
orderings
algorithm
ever
gets
stuck
able
use
information
find
cycle
algorithm
6
topological
ordering
list
empty
empty
find
vertex
incoming
edges
delete
add
algorithm
terminates
topological
ordering
since
add
vertex
incoming
edges
deleted
point
know
predecessors
already
list
terminate
thing
go
wrong
unable
find
vertex
incoming
edges
case
vertices
incoming
edge
want
prove
case
cycle
start
vertex
follow
incoming
edge
backwards
another
vertex
follow
incoming
edge
backwards
building
chain
vertices
can
keep
stepping
backwards
like
forever
finite
number
vertices
graph
therefore
eventually
run
vertex
seen
case
directed
cycle
procedure
always
finds
directed
cycle
whenever
algorithm
6
gets
stuck
completing
proof
theorem
graph
topological
ordering
dag
incidentally
also
proves
algorithm
6
finds
topological
ordering
whenever
one
exists
can
use
algorithm
6
test
whether
graph
dag
putting
algorithm
6
together
stepping
backwards
procedure
provides
fast
method
finding
cycles
graphs
dags
finally
analyze
topological
ordering
algorithm
key
step
finding
vertex
without
incoming
edges
seems
require
scanning
whole
graph
can
speed
really
simple
data
structures
count
number
edges
incoming
list
vertices
without
incoming
edges
algorithm
7
topological
ordering
detailed
implementation
list
empty
list
empty
vertex
let
number
incoming
edges
0
add
empty
remove
vertex
outgoing
edge
decrement
0
add
add
hard
see
algorithm
runs
linear
time
combining
algorithm
5
see
can
find
shortest
paths
dags
linear
time
ics
161
dept
information
computer
science
uc
irvine
last
update
02
may
2000
20
17
37
pdt
