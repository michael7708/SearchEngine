analysis algorithms 

analysis
algorithms
introductioni
computer
science
ii
ics
22
introduction
lecture
will
study
various
ways
analyze
performance
algorithms
performance
concerns
amount
resources
algorithm
uses
solve
problem
certain
size
typically
will
speak
solving
problem
using
array
size
linked
list
nodes
addition
will
mostly
concerned
worst
case
performance
possibilities
best
case
simple
much
useful
information
average
case
complicated
mathematically
pursue
introductory
course
finally
will
mostly
concerned
speed
time
resource
algorithms
although
will
sometimes
discuss
amount
storage
require
space
resource
can
also
talk
worst
case
best
case
average
case
want
able
analyze
algorithms
just
methods
implement
means
able
say
something
interesting
performance
algorithm
independent
version
written
programming
language
machine
can
execute
examine
machine
executable
versions
lot
technology
details
deal
language
write
code
compiler
use
language
speed
processor
run
fast
memory
even
much
caching
involved
information
important
predict
running
times
fundamental
analyzing
algorithms
will
analyze
algoritms
independent
technology
making
subject
scientific
instead
will
analyze
algorithm
predicting
many
steps
takes
go
series
simplifications
leading
characterizing
algorithm
complexity
class
although
initially
may
seem
thrown
useful
information
will
learn
predict
running
times
methods
actual
machines
using
algorithm's
complexity
class
timing
machine
will
run
analyzing
algorithms
machine
language
big
notation
section
will
start
concrete
technological
approach
analyzing
algorithms
looking
java
compiles
code
machine
language
generalize
science
independent
technology
first
suppose
invent
mathematical
function
iaw
computes
number
machine
code
instructions
executed
algorithm
run
worst
case
problem
size
function
takes
integer
parameter
problem
size
returns
integer
result
number
machine
language
instructions
executed
maximum
example
following
code
computes
maximum
value
array
integers
int
max
integer
min
value
int
0
length
max
max
can
easily
examine
machine
language
instructions
java
produces
code
using
debugger
specify
mixed
bottom
control
window
java
shows
us
java
code
interspersed
machine
language
instructions
duplicated
information
reformatted
understandable
put
comments
end
every
line
put
blank
lines
compiler
folks
call
basic
blocks
int
max
integer
min
value
051e6b3d
1209
ldc
9
051e6b3f
3d
istore
2
int
0
length
051e6b40
04
iconst
0
get
0
051e6b41
3e
istore
3
store
051e6b42
a70011
goto
0x051e6b53
go
test
near
bottom
max
051e6b45
2b
aload
1
get
a's
base
address
051e6b46
1d
iload
3
get
051e6b47
2e
iaload
get
051e6b48
1c
iload
2
get
max
051e6b49
a40007
icmple
0x051e6b50
go
test
near
bottom
max
051e6b4c
2b
aload
1
get
a's
base
address
051e6b4d
1d
iload
3
get
051e6b4e
2e
iaload
get
051e6b4f
3d
istore
2
store
max
051e6b50
840301
iinc
3
1
increment
051e6b53
1d
iload
3
get
051e6b54
2b
aload
1
get
a's
051e6b55
arraylength
length
051e6b56
a1ffef
icmplt
0x051e6b45
go
basic
block
can
entered
top
exited
bottom
basic
block
entered
instructions
executed
may
multiple
ways
enter
exit
blocks
code
bit
tortuous
read
hand
simulate
can
trace
easier
way
visualize
code
basics
blocks
graph
will
annotate
information
needed
understand
computing
instruction
counts
block
initializes
max
block
initializes
loop
branch
leading
testing
termination
near
bottom
block
compare
max
either
falling
block
updates
max
skipping
block
block
increments
block
tests
whether
loop
terminate
execute
body
can
compute
exact
number
instructions
executed
inputs
simplicity
let
us
assume
array
values
bigger
smallest
integer
used
initialize
max
array
contains
0
values
9
instructions
executed
blocks
array
contains
1
value
23
instructions
executed
blocks
array
contains
2
values
either
33
instructions
executed
first
value
bigger
second
blocks
37
instructions
executed
second
value
bigger
first
worst
case
assuming
worst
case
now
array
contains
3
values
51
instructions
executed
thus
example
code
compute
maximum
value
array
can
write
formula
iaw
14n
9
14
instructions
executed
loop
iteration
blocks
housekeeping
initialize
max
initialize
check
first
loop
iteration
requires
9
instructions
blocks
fact
computing
iab
number
steps
best
case
test
true
first
iteration
iab
14n
9
4
1
10n
13
4
instructions
updating
max
block
never
executed
first
update
formula
works
0
thus
actual
number
instructions
lower
bound
10n
13
upper
bound
14n
9
0
length
number
values
stored
array
worst
case
run
will
array
strictly
increasing
values
test
executed
iteration
loop
repeatedly
true
machine
instructions
copy
value
max
block
always
executed
determining
average
case
problem
discrete
math
given
random
distribution
many
say
numbers
distributed
uniformly
values
many
times
average
expect
execute
block
meaning
next
value
bigger
prior
ones
simple
problem
can
write
programs
help
understand
return
focus
iaw
14n
9
although
formula
simple
want
make
even
simpler
can
note
gets
large
algorithmic
analysis
asymptotic
concerned
happens
problem
size
gets
large
lower
order
term
9
can
dropped
function
simplify
less
precision
without
losing
much
accuracy
example
100
iaw
1
409
drop
9
term
simplified
answer
just
1
400
99
3
correct
answer
increase
1
000
iaw
14
009
drop
9
term
simplfied
answer
just
14
000
99
94
correct
answer
increase
10
000
iaw
140
009
drop
9
term
simplfied
answer
just
140
000
99
994
correct
answer
thus
gets
large
10
000
even
large
problem
computers
lower
term
significant
will
drop
simplify
formula
iaw
14n
mathematically
td
dominant
term
14n
can
drop
term
td
0
infinity
note
9
14n
0
inifinity
term
can
dropped
sort
another
example
think
sorting
array
can
use
following
simple
code
inefficient
algorithm
int
base
0
base
base
int
check
base
1
check
check
base
check
int
temp
base
base
check
check
temp
code
example
leads
following
basic
blocks
assume
worst
case
input
every
time
two
values
array
compared
found
wrong
order
must
swapped
following
right
side
ebnf
rule
models
correct
order
execution
basic
blocks
ah
bf
cdef
gh
restriction
inner
repetition
happens
one
fewer
times
outer
repetition
array
contains
0
values
7
instructions
executed
blocks
array
contains
1
value
21
instructions
executed
blocks
array
contains
2
values
63
instructions
executed
blocks
array
contains
3
values
133
instructions
executed
resulting
instruction
counting
function
iaw
28n
1
2
14n
7
14n2
7
example
100
iaw
140
007
drop
7
term
simplified
answer
just
140
000
99
995
correct
answer
thus
gets
large
100
tiny
problem
computers
lower
term
significant
will
drop
simplify
formula
iaw
14n2
recall
terms
can
dropped
limit
td
0
infinity
note
7
14n2
0
inifinity
term
can
dropped
now
take
look
constant
front
dominant
term
value
really
matter
three
important
reasons
getting
rid
can
simplify
formula
first
computing
run
time
just
going
multiply
constant
another
constant
relating
machine
can
discard
constant
just
use
different
constant
machine
let
taw
denote
time
taken
algorithm
algorithm
run
worst
case
problem
size
machine
executes
1
billion
instructions
second
formula
second
case
taw
14n2
1x109
taw
000000014n2
second
major
question
want
answered
much
extra
work
algorithm
size
problem
doubled
note
second
simplified
version
iaw
one
dominant
term
multiplied
constant
iaw
2n
iaw
14
2n
2
14n2
4
meaning
doubling
problem
size
quadruples
number
instructions
algorithm
executes
constant
actually
irrelevant
computation
ratio
third
major
question
want
answered
speed
two
algorithms
compare
specifically
want
know
whether
iaw
ibw
0
infinity
mean
algorithm
gets
faster
faster
compared
algorithm
constant
irrelevant
calculation
big
notation
ignoring
lower
order
terms
constants
say
algorithm
n2
means
growth
rate
work
performed
algorithm
number
instructions
executes
order
n2
called
big
notation
use
specify
complexity
class
algorithm
big
notation
tell
us
everything
need
know
running
time
algorithm
example
two
algorithms
n2
know
will
eventually
become
faster
one
algorithm
another
n2
know
will
faster
small
economically
tell
us
quite
bit
performance
algorithms
see
three
important
questions
can
compute
complexity
class
algorithm
process
shown
something
much
simpler
determining
often
frequently
executed
statement
executed
function
returning
first
example
int
max
integer
min
value
int
0
length
max
max
statement
executed
times
length
array
length
returning
second
example
int
base
0
base
base
int
check
base
1
check
check
base
check
int
temp
base
base
check
check
temp
statement
executed
n2
times
length
array
length
actually
executed
exactly
1
2
times
first
outer
loop
iteration
executed
1
times
second
2
times
last
0
times
know
1
2
3
1
2
1
2
3
1
1
2
n2
2
2
dropping
lower
terms
constant
yields
n2
finally
note
comparing
algorithms
complexity
classes
useful
large
state
authoritatively
whether
algorithm
n2
algorithm
faster
small
can
state
pass
threshold
call
n0
algorithm
will
always
faster
n2
algorithm
ignorance
illustrated
picture
example
algorithm
takes
time
small
course
adjusting
constants
lower
order
terms
also
case
algorithm
always
faster
tell
information
solely
complexity
class
technically
algorithm
exist
number
n0
iaw
mf
n0
means
example
algorithm
also
n2
grows
faster
linearly
technically
£c
symbol
use
know
tight
bound
sides
exists
m1
m2
n0
m1f
iaw
m2f
n0
say
algorithm
£c
will
use
just
big
notation
often
pretending
thega
see
big
notation
online
wikipedia
details
complexity
classes
using
big
notation
can
broadly
categorize
algorithms
complexity
classes
categorization
supplies
one
kind
excellent
information
given
time
takes
method
implementing
algorithm
solve
problem
size
can
easily
compute
long
take
solve
problem
size
2n
example
method
implementing
certain
sorting
algorithm
complexity
class
n2
takes
1
second
sort
10
000
values
will
take
4
seconds
sort
20
000
values
complexity
class
n2
doubling
size
problem
quadruples
amount
time
taken
executing
method
algebra
prove
fact
simple
assuming
taw
n2
technology
constant
related
compiler
used
speed
computer
memory
etc
ratio
time
taken
solve
problem
size
2n
time
take
solve
problem
size
taw
2n
taw
2n
2
2
4cn2
cn2
4
saw
constants
irrelevant
disappear
matter
complexity
class
likewise
using
method
sort
1
000
000
values
100
times
data
take
2
8
hours
10
000
times
longer
1002
short
characterization
common
complexity
classes
many
others
expression
formula
using
will
discuss
algorithms
detail
later
handout
use
complexity
class
characterize
many
methods
throughout
quarter
complexity
classclass
nameexamplet
2n
1
constantinsertion
rear
array
insertion
front
linked
list
parameter
passingt
log2n
logarithmicbinary
searcht
constanto
linearlinear
search
arrays
linked
lists
2t
log2n
log
linear
orlinearithmicfast
sorting2t
constanto
n2
quadraticslow
simple
sorting4t
n3
cubicnxn
matrix
multiplication8t
nc
polynomial
orgeometric
2ct
cn
exponentialproving
boolean
equivalences
variablescnt
can
compute
log2n
ln
ln
2
1
4427
ln
since
log
base
2
log
base
linearly
related
really
makes
difference
use
using
big
notation
constants
ignore
different
also
memorize
log21000
10
actually
log21024
exactly
10
log2na
alog2n
fact
can
easily
compute
log21
000
000
log21
0002
2log21000
20
log21
000
000
000
one
billion
understand
simple
formulas
work
gets
large
core
asymptotic
algorithmic
analysis
note
complexity
classes
including
log
linear
considered
fast
running
time
increase
much
faster
size
problem
increases
later
complexity
classes
n2
n3
etc
slow
tractable
final
complexity
class
2n
grows
fast
called
intractable
small
problems
complexity
class
can
ever
solved
example
assume
ia1w
10
constant
ia2w
10log2n
logrithmic
ia3w
10n
linear
etc
assume
running
code
machine
executing
1
billion
109
operations
per
second
following
table
gives
us
intuitive
idea
running
times
algorithms
different
complexity
classes
changes
problem
size
complexity
classn
10n
100n
1
000
1
000
000o
1
1x10
7seconds1x10
7seconds1x10
7seconds
1x10
7secondso
log2n
3
3x10
7seconds6
6x10
7seconds10x10
7seconds
20x10
7secondso
1x10
7seconds1x10
6seconds1x10
5seconds
1x10
2secondso
nlog2n
3
3x10
7seconds6
6x10
6seconds10x10
5seconds
20x10
2secondso
n2
1x10
6seconds1x10
4seconds1x10
2seconds
2
7hourso
n3
1x10
5seconds1x10
2seconds10seconds
3x103yearso
2n
1x10
5seconds4x1021centuriesfuggidaboutit
fuggidaboutit
time
estimation
based
complexity
class
point
continually
simplified
information
algorithms
make
analysis
easier
strayed
far
reality
information
useless
section
will
learn
can
easily
accurately
say
within
10
predict
long
will
take
method
solve
large
problem
size
know
complexity
class
method
measured
long
method
takes
execute
large
problem
size
notice
measured
predicted
problem
sizes
must
reasonably
large
otherwise
simplifications
used
compute
complexity
class
will
accurate
lower
order
terms
will
real
effect
answer
first
example
will
measure
predict
running
time
simple
quadratic
sorting
method
will
use
driver
program
discussed
sorting
section
repeatedly
sort
array
containing
1
000
random
values
predict
long
will
take
method
sort
array
containing
10
000
random
values
actually
compare
prediction
measured
running
time
problem
size
sorting
method
n2
complexity
class
simply
assume
can
write
cn2
know
value
yet
run
sorting
method
five
times
array
containing
1
000
random
values
measure
average
running
time
022
seconds
now
solve
using
1000
1000
10002
022
106
022
106
2
2
10
8
thus
large
2
2x10
8
n2
seconds
using
formula
can
predict
using
method
sort
array
10
000
random
values
take
2
2
seconds
actually
amount
time
2
7
seconds
prediction
100
1
2
6
2
2
2
6
85
accurate
barely
missed
goal
90
accuracy
accurate
measured
sort
10
000
value
array
predicted
time
sort
100
000
value
array
second
example
wil
measure
predict
running
time
complicated
log
linear
sorting
method
algorithm
lowest
complexity
class
accomplish
sorting
will
use
driver
program
repeatedly
sort
array
containing
10
000
random
values
predict
long
will
take
method
sort
array
containing
1
000
000
random
values
actually
compare
prediction
measured
running
time
problem
size
small
enough
measure
sorting
method
log2n
complexity
class
simply
assume
can
write
log2n
know
value
yet
run
sorting
method
five
times
array
containing
100
000
random
values
measure
average
running
time
15
seconds
notice
method
sorts
10
times
many
values
10
times
faster
simple
quadratic
sorting
method
amount
data
now
solve
using
100
000
100
000
100
000
log
2
100
000
15
1
660
964
15
1
660
964
9
0
10
8
thus
large
9
0x10
8
log
2n
seconds
using
formula
can
predict
using
method
sort
array
1
000
000
random
values
take
1
8
seconds
actually
amount
time
1
6
seconds
prediction
100
1
1
8
1
6
1
6
87
accurate
missed
goal
90
accuracy
barely
final
word
accuracy
predictions
sort
exact
array
times
sort
testing
driver
easily
will
see
variations
10
20
likewise
get
slightly
greater
spread
sort
different
arrays
size
model
predicts
take
amount
time
kinds
things
operating
system
programs
running
network
connections
open
etc
influence
actually
amount
time
taken
sort
array
light
accuracy
naive
predictions
actually
quite
good
determining
complexity
classes
empirically
seen
fairly
simple
given
algorithm
determine
complexity
class
determin
often
frequently
executed
statement
executed
function
even
hard
big
convoluted
well
method
implementing
algorithm
can
actually
time
different
sized
problems
infer
complexity
class
data
first
aware
standard
timer
java
accurate
001
second
1
millisecond
call
one
tick
get
kind
accuracy
run
method
large
enough
data
take
tens
hundreds
ticks
milliseconds
run
method
data
size
enough
required
number
ticks
size
2n
size
4n
size
8n
algorithms
simple
complexity
classes
able
recognize
pattern
will
approximate
exact
sequence
values
1
0
seconds
2
03
seconds
3
98
seconds
8
2
seconds
method
seems
doubling
approximately
doubled
time
method
ran
sequence
values
1
0
seconds
3
8
second
17
3
seconds
70
3
seconds
method
seems
n2
doubling
approximately
quadrupled
time
method
ran
course
things
get
bit
subtle
complexity
class
like
nlog2n
see
always
bit
worse
linear
nowhere
near
quadratic
course
nlog22n
behave
simlarly
must
apply
process
bit
skepticism
computing
perfect
answers
searching
log2n
algorithms
linear
seaching
whether
array
linked
list
worst
case
value
searched
data
structure
value
data
structure
must
examined
inner
statement
must
executed
times
public
static
int
linearsearch
int
int
value
int
0
length
value
return
return
1
linear
searching
ordered
array
better
still
worst
case
value
searched
bigger
value
data
structure
value
data
structure
must
examined
way
search
ordered
array
much
faster
algorithm
reasons
will
become
clear
soon
called
binary
searching
explore
algorithm
first
physical
context
suppose
1
000
000
names
alphabetical
sorted
order
phone
book
one
name
phone
number
per
page
front
page
back
algorithm
find
person's
name
related
phone
number
phone
book
find
middle
page
remaining
book
contains
name
looking
done
otherwise
rip
page
tear
remaining
phone
book
half
name
looking
comes
page
ripped
throw
away
second
half
phone
book
name
looking
comes
page
ripped
throw
away
first
half
phone
book
repeat
process
find
name
pages
left
phone
book
method
called
binary
search
iteration
divides
problem
size
phone
book
half
bi
means
two
bicycle
original
phone
book
1
000
000
pages
first
iteration
assuming
name
looking
right
middle
remaining
book
500
000
pages
actually
499
999
algorithm
first
comparison
eliminates
500
000
pages
second
comparison
phone
book
containing
250
000
pages
one
comparison
eliminates
250
000
pages
good
first
comparison
still
much
better
linear
searching
comparison
eliminates
just
one
page
keep
going
ll
either
find
name
20
comparisons
phone
book
will
reduced
pages
critical
method
fact
phone
book
alphabetized
ordered
also
critical
able
find
middle
phone
book
quickly
method
work
linked
lists
determine
complexity
class
algorithm
operating
sorted
array
notice
comparison
cuts
remaining
array
size
half
actually
midpoint
also
eliminated
comparison
size
cut
bit
half
page
book
maximum
number
iterations
log2
number
times
can
divide
2
reduced
1
number
times
can
double
1
reaching
notice
algorithm
array
size
doubles
number
iterations
increases
just
1
first
comparison
cut
doubled
array
size
back
original
array
size
important
facts
logarithms
memorize
210
1
024
log2
1
000
10
log2
x2
2
log2
log2
1
000
000
log2
10002
2
log2
1000
20
calculator
compute
log2
ln
ln
2
ln
logarithm
base
provided
calculators
math
log
method
10
binary
search
3
iterations
iteration
complicated
linear
search
1
000
000
binary
search
20
iterations
50
000
times
fewer
iterations
worst
case
linear
search
practically
even
arrays
size
1
000
000
algorithms
run
quickly
binary
search
runs
50
000
times
faster
repeatedly
searching
big
array
binary
search
much
much
better
seconds
vs
hours
method
implementing
binary
search
algorithm
arrays
public
static
int
binarysearch
int
int
value
int
low
0
int
high
length
1
low
high
low
high
bounds
inverted
return
1
value
array
int
mid
low
high
2
find
middle
array
mid
value
found
value
looking
return
mid
return
index
otherwise
else
value
mid
determine
half
high
mid
1
array
potential
stores
else
value
continue
seraching
low
mid
1
part
array
following
illustration
shows
method
executes
situation
finds
value
searching
notice
converges
indexes
array
might
store
searched
value
following
illustration
shows
method
executes
situation
find
value
searching
iteration
loop
reduces
part
array
looked
factor
two
many
times
can
reduce
size
array
left
single
value
log2
number
times
can
double
size
array
1
value
finally
note
perform
binary
searching
efficiently
linked
lists
quickly
find
middle
linked
list
fact
another
self
referential
data
structure
trees
can
used
perform
efficient
searches
sorting
n2
log2n
algorithms
sorting
one
common
operations
performed
array
data
saw
previous
section
sorting
array
allows
searched
much
efficiently
sorting
algorithms
often
divided
two
complexity
classes
simple
understand
algorithms
whose
complexity
class
n2
complicated
algorithms
whose
complexity
class
log2
latter
much
faster
former
large
arrays
see
time
estimation
section
discussed
two
sorting
algorithms
example
fast
one
arrays
sort
method
sorts
array
objects
efficiently
implements
nlog2n
algorithm
small
constant
brief
description
three
n2
sorting
algorithms
bubble
sort
next
position
fill
compared
later
positions
swapping
order
values
selection
sort
smallest
value
remaining
positions
computed
swapped
value
next
position
insertion
sort
next
value
moved
backward
swapped
value
previous
position
region
sorted
values
reaches
correct
position
algorithms
arranged
simplest
complicated
order
well
slowest
fastest
order
large
brief
description
three
log2
sorting
algorithms
merge
sort
pairs
small
adjacent
ordered
arrays
smallest
1
member
arrays
merged
repeated
larger
ordered
arrays
result
just
one
ordered
array
containing
values
heap
sort
values
added
removed
special
kind
tree
data
structure
called
heap
will
study
later
add
remove
operations
log2
adding
removing
values
nxo
log2
nxo
log2
log2
total
quick
sort
pivot
value
chosen
array
partitioned
three
regions
left
values
less
pivot
middle
equal
pivot
right
values
greater
pivot
process
repeated
left
right
regions
contain
one
value
heap
sort
slower
merge
sort
takes
extra
space
merge
sort
requires
another
array
big
array
sorted
technically
quick
sort
n2
arrays
itis
fastest
requires
extra
space
pathologicallyh
bad
arrays
rare
can
take
much
longer
execute
methods
sorting
algorithms
defined
static
methods
sort
class
method
exactly
prototype
can
easily
interchanged
public
static
void
bubble
object
int
size
comparator
includes
array
object
references
sorted
int
specifying
many
references
stored
array
can
length
array
filled
object
class
implementing
comparator
decides
objects
belong
others
sorted
array
driver
testing
performance
sorting
methods
sorting
demo
application
application
includes
source
code
testing
sorting
methods
well
arrays
sort
actually
runs
slower
fastest
method
quicksort
expect
finely
tuned
system
code
slow
can
examine
source
code
method
compare
fast
sorting
methods
clarity
performance
going
finally
proven
using
comparisons
sort
values
algorithms
require
least
log2
comparisons
thus
general
sorting
algorithms
complexity
class
smaller
log
linear
although
better
algorithms
ones
smaller
constants
may
exist
analyzing
collection
classes
analyzing
collection
class
bit
art
accurately
need
understand
often
methods
called
can
however
make
one
reasonable
simplifying
assumption
simple
collection
classes
assume
values
added
collection
values
removed
collection
always
happen
reasonable
case
simple
array
implementations
stack
queue
add
methods
push
enqueue
1
assuming
new
memory
must
allocated
pop
remove
method
1
dequeue
remove
method
nxo
1
adding
removing
values
stack
collection
classes
nxo
n2
n2
n2
adding
removing
values
queue
collection
classes
n2
another
example
look
array
implementation
simple
priority
queue
keeping
array
sorted
enqueue
operation
method
scans
array
trying
find
correct
position
based
priority
highest
priority
rear
added
value
worst
case
priority
lower
value
entire
array
must
moved
backward
put
value
front
dequeue
operation
just
1
just
removes
value
rear
array
requiring
data
movement
nxo
n2
nxo
1
n2
n2
adding
removing
values
implementation
priority
queue
also
complexity
class
n2
instead
enqueued
value
rear
dequeued
searching
array
highest
priority
value
still
one
term
one
n2
term
leading
n2
overall
complexity
class
later
will
learn
implement
priority
queues
heaps
enqueue
dequeue
log2n
worse
1
better
thus
adding
removing
values
implementation
priority
queue
nxo
log2n
nxo
log2n
nlog2n
nlog2n
nlog2n
balancing
add
remove
operations
yields
lower
complexity
class
operations
occur
times
finally
use
array
store
collection
time
double
array
must
copy
values
doubling
size
log2
times
adding
values
total
nlog2n
copies
therefore
can
think
addition
requiring
log2n
copies
called
amortized
cost
operation
really
occur
every
add
averaged
adds
correct
case
array
implementation
stack
queue
add
methods
actually
log2
nxo
log2
log2
nxo
1
nxo
n2
stack
class
actually
log2
pushes
pops
stack
class
actually
n2
enqueues
dequeues
calculation
array
implementations
slightly
higher
complexity
class
using
linked
lists
linked
lists
allocated
new
object
every
value
put
linked
list
running
time
collections
using
linked
lists
can
actually
higher
will
address
problem
cover
linked
lists
efficiency
pragmatics
generally
programmers
address
efficiency
concerns
program
written
clearly
correctly
first
get
right
make
fast
sometimes
see
need
make
program
run
faster
times
program
must
made
run
faster
just
test
tests
performed
quickly
enough
debugging
program
programs
run
fast
necessary
making
program
run
faster
often
requires
making
complicated
difficult
generalize
etc
example
many
scientific
programs
run
just
seconds
pragmatic
reason
work
run
faster
typically
takes
days
collect
data
program
component
entire
task
program
part
already
fast
enough
likewise
programs
require
lots
user
interaction
need
made
efficient
computer
spends
less
tenth
second
user
entering
data
program
prompting
fast
enough
finally
pinball
animation
program
model
can
update
show
less
tenth
second
reason
make
run
faster
animation
will
slowed
reason
improve
performance
famous
rules
thumb
efficiency
rule
90
10
states
90
time
program
takes
run
result
executing
just
10
code
time
program's
execution
spent
small
amount
code
modifying
code
way
achieve
significant
speedup
example
suppose
10
000
line
program
runs
1
minute
rule
90
10
executing
1
000
lines
program
accounts
54
seconds
executing
remaining
9
000
lines
account
6
seconds
locate
study
1
000
lines
small
part
program
get
execute
half
time
total
program
run
27
6
33
seconds
reduces
execution
time
entire
program
almost
50
instead
study
9
000
lines
get
execute
instantaneously
admittedly
difficult
feat
total
program
run
54
0
54
seconds
reduced
execution
time
entire
program
ony
10
note
randomly
change
code
improve
efficiency
90
time
will
making
changes
resulting
significant
improvement
thus
corollary
90
10
rule
90
code
program
make
clearer
less
efficient
will
affect
total
execution
time
program
much
program
rewrote
9
000
lines
make
clear
simple
possible
regard
efficiency
increased
running
time
50
6
9
seconds
total
program
run
54
9
63
seconds
5
increase
total
execution
time
profiling
one
go
locating
10
program
accounting
90
execution
time
large
programs
empirical
studies
show
programmers
good
intuition
hot
code
located
instead
use
tool
computes
information
us
profiler
just
tool
runs
program
us
greatly
reduced
speed
keeps
track
either
many
times
line
executed
much
time
spent
executing
line
method
profilers
can
collect
kinds
information
often
collecting
information
slows
program
larger
factor
can
examine
results
produced
running
program
using
profiler
learn
code
executing
time
focus
improve
speed
entire
program
java
simple
useful
built
profiler
use
select
edit
metrowerks
codewarrior
toolbar
select
java
application
release
setting
target
settings
panel
click
java
target
vm
arguments
text
field
enter
xrunhprof
cpu
times
illustrated
run
program
will
get
output
file
called
java
hprof
txt
contains
useful
performance
information
beyond
scope
lecture
explain
commercial
products
available
evaluate
display
information
collected
profiler
much
sophisticated
ways
typically
one
can
speed
program
factor
3
10
quickly
gains
slow
unless
algorithms
lower
complexity
classes
can
found
problem
set
ensure
understand
material
lecture
please
solve
announced
problems
read
lecture
get
stumped
problem
go
back
read
relevant
part
lecture
still
questions
please
get
help
instructor
ta
student
say
algorithm
1
mean
complexity
class
sqrt
fit
hierarchy
shown
lecture
suppose
actual
time
taken
execute
n2
sorting
algorithm
fast
machine
2
2x10
8n2
seconds
now
suppose
actual
time
taken
execute
log2
sorting
algorithm
slow
machine
7
2x10
4
log2
seconds
slow
machine
10
000
slower
fast
one
size
arrays
will
slower
machine
running
faster
algorithm
sort
arrays
faster
faster
machine
running
slower
algorithm
suppose
sort
class
two
methods
public
static
void
sortbymethod1
object
comparator
public
static
void
sortbymethod2
object
comparator
testing
methods
exhaustively
find
first
method
works
faster
second
arrays
whose
length
less
13
second
works
faster
bigger
arrays
write
method
name
supersort
prototype
always
runs
fast
fastest
two
methods
rexamine
code
first
example
computing
maximum
value
stored
array
one
value
hint
final
recomputed
never
changes
instead
write
code
bit
verbose
executes
fewer
machine
language
instructions
identify
redundancy
write
java
code
fix
determine
iaw
new
program
might
check
result
using
mixed
mode
debugger
body
loop
longer
improvement
bigger
lesser
effect
overall
write
program
fills
array
length
random
values
run
maximum
code
incrementing
counter
whenever
new
maximum
found
run
program
large
values
try
infer
formula
approximates
many
times
happens
run
program
large
double
size
quadruple
size
etc
test
formula
