ics 180 april 24 1997 
hashing move ordering 
ics
180a
spring
1997
strategy
board
game
programming
lecture
notes
april
24
1997
hashing
move
ordering
really
finish
describing
alpha
beta
pseudocode
included
mysterious
sort
list
moves
step
explain
continue
leave
dangling
talk
hashing
connect
little
idea
hashing
simple
many
games
allow
transpositions
moves
meaning
different
sequences
moves
end
leading
position
instance
chess
opening
moves
1
d4
nf6
2
c4
1
c4
nf6
2
d4
give
position
known
indian
defense
white's
two
pawn
moves
made
either
order
without
changing
result
example
complicated
transposition
moves
1
e4
c6
2
d4
d5
3
ed
qxd5
4
nc3
qd6
caro
kann
defense
1
e4
d5
2
ed
qxd5
3
nc3
qd6
4
d4
c6
scandinavian
opening
1
e4
nf6
2
e5
ng8
3
d4
d6
4
ed
qxd6
5
nc3
c6
alekhine
defense
lead
position
different
numbers
moves
transpositions
positions
can
show
many
places
alpha
beta
search
tree
store
data
structure
remembers
results
searching
position
can
look
rather
searching
enough
memory
store
positions
search
lookups
must
fast
make
save
time
just
searching
fortunately
one
advantage
ok
sometimes
find
results
position
already
searched
search
position
long
happen
often
answer
hash
tables
make
big
array
large
possible
without
blowing
physical
memory
want
eat
virtual
memory
will
slow
struct
long
checksum
long
long
might
even
better
int
depth
enum
exact
lower
bound
upper
bound
entry
type
double
eval
hashtable
hash
table
size
position
search
compute
hash
value
indexing
hash
table
another
hash
value
checking
whether
found
right
position
searching
position
lookup
hashtable
hashtable
checksum
hashtable
entry
type
exact
hashtable
depth
least
depth
currently
searching
return
eval
stored
searching
position
store
current
depth
eval
just
computed
hashtable
compute
hash
values
zobrist
hashing
technique
already
mentioned
re
repetition
detection
playing
game
maybe
hardcode
source
code
make
array
square
piecetype
random
numbers
hash
board
just
sum
summed
pieces
currently
board
combined
extra
information
might
castling
ability
often
sum
replaced
bitwise
exclusive
uparrow
little
faster
easier
work
arithmetic
addition
probably
work
just
well
move
new
position
recompute
hash
scratch
instead
can
update
hash
really
quickly
subtracting
old
piece
square
value
moved
piece
adding
new
value
new
location
use
technique
different
random
numbers
hash
value
checksum
tips
using
hashing
effectively
clean
array
making
move
wastes
time
hashed
positions
might
actually
still
useful
move
position
occurs
different
levels
tree
second
transposition
example
listed
can
actually
give
deeper
searches
originally
asked
ok
hash
positions
near
leaves
search
tree
many
take
away
hash
table
space
valuable
positions
saving
much
time
avoiding
searching
hashing
interact
alpha
beta
large
fraction
chess
program
bugs
related
hashing
partly
interacts
confusing
ways
alpha
beta
search
avoid
dealing
issue
need
hashing
alpha
beta
efficient
searcher
recall
call
alphabeta
depth
alpha
beta
position
one
three
things
can
happen
fail
high
know
eval
least
beta
exactly
fail
low
know
eval
alpha
exactly
exact
result
alpha
eva
beta
can
store
exact
result
hash
table
know
exact
result
fail
high
fail
low
result
still
help
us
prune
later
along
exact
evals
store
two
kinds
eval
hash
table
lower
bound
stating
eval
least
beta
upper
bound
stating
eval
alpha
use
entry
type
field
hash
table
entry
specify
kind
eval
stored
hash
lookup
comes
back
one
need
see
whether
useful
enough
prune
immediately
without
searching
node
return
otherwise
search
node
pseudocode
alpha
beta
search
hashing
maintain
hashtable
index
checksum
global
variables
updated
part
process
making
unmaking
moves
double
alphabeta
int
depth
double
alpha
double
beta
depth
0
game
return
evaluation
hashtable
checksum
hashtable
depth
depth
switch
hashtable
entry
type
case
exact
return
hashtable
eval
case
lower
bound
hashtable
eval
beta
return
hashtable
eval
else
break
case
upper
bound
hashtable
eval
alpha
return
hashtable
eval
else
break
int
eval
exact
0
generate
sort
list
moves
available
position
move
make
move
double
val
alphabeta
depth
1
beta
alpha
unmake
move
val
beta
hashtable
checksum
hashtable
depth
depth
hashtable
entry
type
lower
bound
hashtable
eval
val
return
val
val
alpha
alpha
val
eval
exact
1
hashtable
checksum
hashtable
depth
depth
eval
exact
hashtable
entry
type
exact
else
hashtable
entry
type
upper
bound
hashtable
eval
alpha
return
alpha
alpha
beta
move
ordering
said
return
alpha
beta
optimistic
analysis
last
time
alpha
beta
showing
can
double
search
depth
prunes
whenever
can
condition
prunes
whenever
can
can
expressed
simply
good
moves
searched
bad
ones
moves
completely
sorted
best
one
first
least
one
best
one
first
happens
pruning
search
deeply
classify
nodes
type
children
get
searched
type
prune
finding
good
child
move
ordering
important
cases
type
want
start
child
will
let
prune
rest
type
want
choose
first
child
good
enough
let
children
type
course
finding
good
moves
hard
whole
reason
search
first
place
clues
1
may
hashtable
entries
previous
iterations
iterated
deepening
give
approximations
search
values
positions
searched
less
deeply
2
may
game
specific
information
chess
captures
often
good
moves
try
first
3
killer
heuristic
move
best
sibling
valid
try
searching
children
add
step
sort
expected
quality
search
sorted
order
sometimes
can
modify
move
generator
output
moves
roughly
sorted
order
captures
first
save
explicit
sort
one
additional
trick
think
going
prune
need
sort
everything
just
need
output
first
items
sorted
order
may
want
use
sort
can
take
items
one
one
stop
early
selection
sort
heapsort
david
eppstein
dept
information
computer
science
uc
irvine
thursday
28
oct
1999
11
42
22
pdt
