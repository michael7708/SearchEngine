black white assignment 2 
lab assignment 2 black white 
black
white
assignment
2
introduction
othello
well
known
two
player
strategy
game
project
will
develop
portions
intelligent
program
plays
othello
ve
provided
user
interface
game
logic
code
implements
rules
game
will
allow
two
human
players
play
game
will
write
search
strategy
routines
will
allow
computer
play
game
othello
also
known
reversi
played
square
board
divided
8x8
grid
rules
game
along
good
ideas
sound
strategy
play
described
wikipedia
entry
reversi
read
sure
know
play
game
attempting
complete
program
will
save
much
time
effort
since
provided
program
allows
play
two
human
players
can
play
get
feel
game
rules
strategy
provided
game
will
allow
play
computer
player
create
ai
class
write
necessary
othelloaifactory
class
code
see
starting
point
code
ll
need
complete
assignment
included
zipped
blackandwhile
project
folder
download
file
unzip
add
workspace
much
code
provided
compiled
class
files
lib
folder
provided
java
source
code
java
files
heavily
commented
add
project
23
workspace
move
blackandwhite
folder
folder
containing
ics
23
workspace
start
eclipse
select
workspace
file
menu
select
import
will
pop
dialog
box
general
select
existing
projects
workspace
click
next
next
select
root
directory
click
browse
button
find
blackandwhite
folder
copied
workspace
folder
select
click
ok
finally
click
finish
now
see
project
called
blackandwhite
package
explorer
problems
window
may
show
warnings
warnings
indicates
part
program
yet
built
ll
need
work
two
classes
first
need
create
new
class
implements
othelloai
interface
class
name
must
begin
othelloai
followed
eight
digit
student
id
student
id
12345678
class
called
othelloai12345678
access
student
use
id
number
access
provided
removed
many
leading
zeroes
needed
added
make
number
8
digits
second
write
one
line
code
othelloaifactory
class
see
class
comments
details
leave
everything
else
particular
change
names
files
classes
interfaces
methods
provide
run
program
othello
class
contains
main
method
run
program
execute
othello
class
run
othello
window
will
appear
green
area
label
click
start
game
click
green
area
ll
asked
specify
whether
player
controlled
human
computer
now
specify
human
haven
implemented
ai
yet
clicking
ok
starts
game
human
controlled
player
makes
move
double
clicking
empty
square
grid
squares
constitute
valid
moves
mouse
cursor
will
turn
hand
square
valid
one
much
like
hover
link
browser
note
place
cursor
rather
precisely
square
cursor
change
move
mouse
within
square
bit
square
think
legal
use
cursor
hand
computer
simply
moves
turn
gui
animates
placing
flipping
tiles
can
see
moves
action
status
messages
display
score
remind
whose
move
necessary
terminology
will
building
rudimentary
artificial
intelligence
ai
computer
can
play
game
othello
another
instance
artificial
intelligence
task
project
fairly
narrow
can
disregard
vast
majority
code
gave
implements
either
gui
game
logic
fact
code
provided
compiled
form
rather
source
code
reason
three
main
abstractions
need
understand
order
write
code
required
project
contents
grid
cell
represented
enumeration
othellocell
three
possible
values
othellocell
none
empty
cell
othellocell
black
cell
containing
black
tile
othellocell
white
cell
containing
white
tile
cells
locations
denoted
ordered
pairs
row
column
customary
two
dimensional
arrays
java
row
numbers
column
numbers
begin
0
range
possible
locations
0
0
7
7
ai
analyzes
possibilities
will
necessary
evaluate
current
game
situation
collectively
call
description
current
situation
game
state
tersely
state
game
state
comprised
contents
grid
cell
score
game
flag
indicating
whose
turn
flag
indicating
whether
game
ended
since
possible
two
ai
playing
makes
sense
encapsulate
ai
class
two
objects
class
created
play
one
another
implement
ai
class
implements
othelloai
interface
consists
method
called
choosemove
analyzes
possible
moves
picks
ai
next
move
since
move
denoted
square
new
tile
placed
choosemove
returns
object
type
othellomove
contains
row
number
column
number
game
trees
can
think
possible
game
states
arranged
conceptually
kind
search
tree
called
game
tree
node
tree
contains
particular
game
state
children
game
states
can
result
making
valid
move
state
root
tree
initial
game
state
state
othello
game
first
move
made
children
initial
state
possible
states
can
arise
black
player
moves
first
making
valid
opening
move
four
states
corresponding
four
possible
moves
black
player
permitted
make
opening
moves
illegal
considered
take
look
partial
othello
game
tree
initial
state
root
tree
four
possibilities
black
player
can
choose
initial
move
root
four
children
first
moves
left
child
root
three
possible
moves
white
player
can
make
response
three
children
node
moves
legal
moves
exist
appear
children
node
moves
pictured
tree
continues
grow
fashion
new
move
producing
children
surprisingly
game
tree
can
grow
large
quickly
game
ends
legal
moves
board
reach
final
state
point
one
player
won
game
since
legal
moves
boards
nodes
representing
will
children
final
states
leaves
game
tree
exhaustively
searching
possibilities
time
player
chooses
move
wants
pick
one
will
lead
winning
game
state
assuming
complete
game
tree
disposal
determine
best
move
three
steps
choose
final
state
gives
best
win
typically
done
applying
evaluation
function
final
game
state
function
typically
returns
number
higher
numbers
considered
better
choose
state
highest
value
determine
path
current
game
state
final
state
chose
make
move
takes
current
game
state
path
toward
chosen
final
state
sadly
practical
limitations
make
easy
implement
approach
impossible
first
number
game
states
level
tree
grows
exponentially
work
way
tree
since
typically
large
number
possible
moves
can
taken
particular
game
state
simply
won
enough
memory
store
entire
game
tree
can
imagine
build
game
tree
20
levels
deep
four
possible
moves
can
made
particular
state
number
nodes
tree
greater
420
large
number
indeed
besides
even
enough
memory
available
store
tree
processing
time
create
entire
game
tree
prohibitive
ll
need
find
compromise
approach
perhaps
doesn
always
find
best
possible
outcome
makes
good
decision
reasonable
amount
time
using
reasonable
amount
memory
heuristic
search
study
artificial
intelligence
much
say
good
ways
search
toward
goal
impractical
check
possible
paths
toward
can
first
make
use
following
observation
suppose
black
made
move
game
white
wants
figure
best
move
make
using
search
tree
approach
ve
discussing
white
need
concern
subtree
current
game
state
root
move
made
moves
made
can
ignored
now
possible
take
paths
tree
thus
analyzing
next
move
make
need
generate
part
search
tree
originates
current
game
state
approach
reduces
storage
needs
significantly
don
waste
time
memory
processing
parts
tree
can
longer
reach
even
generate
part
tree
need
part
will
still
much
large
store
re
nearing
end
game
heuristic
search
comes
play
heuristic
search
generate
much
relevant
subtree
practical
using
resulting
game
states
guide
us
selecting
move
hope
will
best
several
strategies
use
heart
strategy
using
evaluation
function
rate
particular
game
state
way
can
decide
large
number
game
states
best
outcome
us
simple
approach
though
one
ignores
aspects
game
following
eval
state
number
tiles
belonging
number
tiles
belonging
opponent
also
important
note
need
actually
build
game
tree
memory
algorithm
will
perform
sort
depth
first
search
game
tree
meaning
can
use
parameters
recursive
method
stored
run
time
stack
perform
search
negating
need
actually
build
store
game
tree
will
dramatically
reduce
amount
memory
needed
choose
move
since
one
path
tree
will
need
stored
run
time
stack
one
time
putting
ideas
together
can
develop
search
algorithm
will
look
move
leads
game
state
evaluates
highest
value
algorithm
looks
like
int
search
othellogamestate
int
depth
depth
0
reached
final
state
return
evaluation
else
turn
move
valid
move
can
make
make
move
yielding
state
s'
search
s'
depth
1
return
maximum
value
returned
recursive
search
calls
else
valid
move
opponent
can
make
make
move
yielding
state
s'
search
s'
depth
1
return
minimum
value
returned
recursive
search
calls
things
need
discuss
algorithm
first
notice
two
cases
recursion
either
computer
player
turn
currently
making
decision
opponent
turn
case
algorithm
almost
except
computer
player
turn
maximum
value
returned
words
computer
player
wants
make
best
possible
move
can
opponent
turn
minimum
value
returned
assumed
opponent
will
also
make
move
best
interest
move
computer
worst
interest
either
black
white
player
might
computer
player
deciding
whether
turn
opponent
turn
ll
exercise
caution
ensure
re
making
right
decision
second
notice
depth
parameter
used
limit
depth
search
make
sure
search
manageable
length
time
recurse
one
level
deeper
depth
reduced
one
stop
recursing
reaches
zero
experiment
find
depth
can
compute
move
fairly
quickly
still
gives
computer
player
look
ahead
feasible
hint
game
progresses
number
possible
moves
changes
point
number
moves
might
become
small
enough
can
increase
search
depth
might
also
decrease
search
depth
number
moves
increases
adjusting
depth
game
progresses
can
make
computer
much
smarter
without
unduly
delaying
game
third
observe
one
player
makes
move
isn
necessarily
case
player
will
making
next
move
occasionally
othello
player
gets
move
twice
row
care
must
taken
deciding
whose
turn
easiest
way
deal
problem
remember
current
game
state
keeps
track
whose
turn
query
game
state
need
information
lastly
note
algorithm
returns
evaluation
best
move
state
best
state
return
evaluation
state
reachable
example
one
s'
states
calling
search
10
state
asks
following
question
looking
ten
moves
future
assuming
opponent
best
can
well
will
state
turn
ll
need
exercise
care
actually
implementing
algorithm
choosemove
will
able
call
search
use
result
help
choose
right
move
sure
test
program
correct
play
reasonable
play
good
way
play
program
friends
classmates
play
see
can
broken
beaten
obviously
playing
breaks
program
need
fix
people
routinely
beat
computer
consider
fine
tuning
program
search
depth
better
may
also
wish
change
evaluation
function
game
tree
search
algorithm
discussed
optional
work
couple
technical
points
othelloid
class
must
write
system
otherwise
write
console
certainly
confuse
game
player
supposed
interacting
othello
board
wish
use
system
statements
debugging
work
fine
sure
comment
remove
turning
work
don
require
use
additional
classe
