closest pair methods 
methods summary results 
closest
pair
data
structures
methods
designed
analyzed
implemented
several
different
closest
pair
data
structures
see
papers
source
code
detail
analyze
times
terms
two
parameters
number
objects
set
time
per
operation
perform
insertions
deletions
nearest
neighbor
queries
dynamic
set
objects
implementations
use
trivial
nearest
neighbor
searching
just
examine
distances
objects
previously
known
brute
force
simply
maintains
list
objects
finds
closest
pairs
examining
pairs
objects
insertions
deletions
easy
space
linear
queries
take
time
nq
neighbor
heuristic
store
nearest
neighbor
object
insertion
takes
linear
time
deletions
require
recomputing
neighbors
object
deleted
object
neighbor
may
take
much
nq
time
space
linear
many
applications
deleted
objects
unlikely
high
degree
empirically
observed
time
per
operation
linear
close
linear
priority
queue
implemented
store
priority
queue
data
structure
binary
heap
containing
entries
distance
matrix
space
quadratic
worst
case
time
per
update
log
new
closest
pair
data
structures
quadtree
group
entries
adjacency
matrix
2x2
squares
compute
maximum
square
interpret
maxima
distances
smaller
set
2
objects
continue
recursively
space
quadratic
worst
case
time
per
operation
linear
optimal
unless
one
assumes
knowledge
distance
function
likely
method
choice
relatively
objects
expensive
distance
computations
conga
line
partition
objects
log
subsets
maintain
graph
subset
closest
pair
guaranteed
correspond
edge
graph
insertion
creates
new
subset
new
object
deletion
may
move
object
existing
subset
new
subset
case
necessary
pair
subsets
merged
maintain
desired
number
subsets
amortized
time
per
insertion
log
amortized
time
per
deletion
log2
space
linear
multiconga
simplification
conga
line
data
structure
allow
number
subsets
grow
arbitrarily
never
merge
pairs
subsets
time
per
insertion
amortized
time
per
deletion
sqrt
practice
faster
conga
lines
factor
three
usually
roughly
comparible
neighbor
heuristic
fast
even
problems
cause
neighbor
heuristic
blow
fastpair
simplify
conga
lines
making
separate
singleton
subsets
objects
moved
new
subsets
deletion
can
alternately
viewed
modification
neighbor
heuristic
initial
construction
nearest
neighbors
replaced
conga
line
computation
insertion
update
previously
computed
neighbors
time
theoretically
practice
qualitatively
similar
neighbor
heuristic
typically
runs
30
faster
david
eppstein
information
computer
science
uc
irvine
03
sep
2003
19
45
59
pdt
