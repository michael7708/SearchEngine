h23 homeworks 
homework details 
h23
homeworks
typicallyl
homeworks
theory
portion
design
coding
portion
warning
homework
next
assigment
guaranteed
correct
complete
look
assignment
early
ask
questions
understand
supposed
note
due
time
coding
assignments
due
need
deposited
10pm
tuesday
week
homework
due
work
handed
due
beginning
class
wednesday
week
homework
due
late
homeworks
will
marked
20
day
late
regrades
regrade
must
resubmit
homework
within
1
week
receiving
score
also
must
explain
part
homework
needs
regraded
entire
assigment
will
regraded
possible
lower
score
regrade
special
homework
0
due
wednesday
5pm
email
answers
kibler
ics
uci
edu
cc
ta
li
zhang
lzhang1
uci
edu
restrict
answer
maximum
paragraph
1
tell
program
written
purely
fun
class
assignment
none
say
2
tell
program
like
write
homework
1
goal
review
practice
object
oriented
design
simple
gui
interface
read
chapter
1
chapter
1
useful
program
examples
well
review
basic
mathematical
techniques
1
finite
induction
problem
prove
sum
1
2
1
2
2
part
requires
coding
design
suppose
coding
limited
banking
systems
customers
can
open
savings
account
close
savings
account
add
money
account
withdrawn
money
account
may
assume
new
bank
begins
customers
style
lectures
define
appropriate
objects
methods
turn
final
design
steps
used
create
design
also
include
driver
program
ie
program
puts
objects
together
look
like
code
execute
since
needed
objects
defined
people
like
start
writing
driver
program
guessing
objects
might
need
3
part
assigment
involves
writing
simple
gui
interface
user
get
file
name
file
will
use
wm
txt
class
folder
xx
program
will
display
total
number
letters
characters
letter
number
times
occurs
graphical
plot
frequency
letter
specifically
plot
th
letter
frequency
th
letter
upper
case
letters
normalized
lower
case
letters
can
conveniently
done
transforming
every
read
string
string
lower
case
letter
via
string
method
homework
2
goal
reinforce
familiarity
notation
proofs
read
chapter
5
1
problem
5
14
part
6
code
fragments
analyze
2
suppose
prove
prove
3
definition
set
convex
whenever
points
belong
set
0
1
point
1
belongs
prove
s1
s2
convex
s1
intersect
s2
convex
proof
straightforward
long
lose
head
attempt
geometric
proof
although
might
provide
insight
confidence
result
algebraic
proofs
usually
easier
know
might
true
homework
3
goal
use
gui
interface
standard
collection
classes
assignment
somewhat
similar
assignment
1
adds
uses
collection
classes
assignment
will
build
gui
interface
performs
simple
statistical
analysis
text
document
use
swing
classes
awt
library
deprecated
using
borderlayout
north
panel
ask
user
file
processed
west
panel
display
sorted
order
frequency
words
document
center
panel
display
graph
100
frequent
words
sorted
order
axis
measures
frequency
occurrence
percentage
th
frequent
word
plot
points
th
word
frequences
th
word
north
panel
display
total
number
words
total
number
different
words
will
read
file
wm
txt
one
important
question
constitutes
word
purposes
assignment
word
sequence
characters
surrounded
white
space
first
last
characters
letters
also
need
remove
final
internal
punctuation
hence
jackson7
word
counted
use
stringtokenizer
identify
candidate
words
use
hashtable
hashmap
provided
collections
package
keep
track
number
occurences
every
word
use
treeset
also
provided
collections
package
sort
words
will
sort
words
frequency
need
define
comparator
start
assignment
early
write
one
fell
swoop
instead
start
writing
simplest
throw
away
programs
can
imagine
develop
understanding
confidence
individual
features
java
language
help
assignment
giving
class
wrote
called
filetokenizer
might
find
useful
conceptually
much
like
stringtokenizer
file
basically
provides
iterator
make
implement
iterator
find
errors
improvements
code
please
let
know
import
java
util
class
filetokenizer
bufferedreader
br
string
line
stringtokenizer
stok
filetokenizer
string
try
br
new
bufferedreader
new
filereader
line
br
readline
stok
new
stringtokenizer
line
catch
ioexception
ioe
string
nextword
return
stok
nexttoken
boolean
hasword
try
stok
hasmoreelements
return
true
line
br
readline
line
null
return
false
stok
new
stringtokenizer
line
misses
blank
lines
stok
hasmoreelements
line
br
readline
line
null
return
false
stok
new
stringtokenizer
line
return
true
catch
ioexception
ioe
return
false
homework
4
goal
review
compare
use
lists
stacks
arrays
due
date
extended
may
8
10pm
read
chapter
3
4
3
chapter
3
lists
stacks
queues
4
3
covers
binary
trees
also
read
handout
collections
assignment
will
implement
cache
inteface
will
defined
5
different
ways
namely
array
linked
list
ordered
tree
linked
list
collections
package
java
util
tree
collections
package
implementation
give
notation
analysis
additional
compare
implementation
generating
1
000
000
random
numbers
putting
cache
size
1000
numbers
small
depends
computer
may
increase
run
experiment
multiple
times
implementation
cache
performs
best
can
say
memory
use
much
memory
technique
require
give
analysis
cache
bounded
ordered
container
objects
since
stores
objects
will
actually
store
double
objects
concrete
cache
single
constructor
cache
int
bound
bound
number
elements
stored
objects
comparable
allowed
entered
cache
duplicated
objects
case
doubles
stored
interface
cache
one
required
method
void
add
object
may
store
comparable
object
object
added
either
cache
full
object
greater
object
currently
stored
constructor
cache
int
bound
bound
maximum
number
elements
stored
suggested
also
define
iterator
iterator
will
allow
view
see
stored
define
remove
nothing
trivial
define
iterator
trees
import
java
util
interface
cache
void
add
comparable
note
wrappers
double
integer
string
class
implement
comparable
may
defined
additional
methods
isfull
remove
object
whatever
find
useful
may
use
cache
class
later
assignments
note
one
homework
cancelled
homework
5
goals
processing
files
using
hashtables
cache
different
data
structures
different
goals
read
chapter
5
chapter
hashing
program
finds
interesting
kmers
kmer
contiguous
string
exactly
letters
program
will
read
two
files
size
file
consists
characters
alphabet
first
file
will
call
family
second
file
will
call
background
create
filereader
masterhit
directory
use
new
file
masterhit
instructional
ics
h23
files
nit
txt
may
think
background
dna
strings
normal
population
family
file
dna
people
genetic
disease
program
goal
find
unusual
really
statistically
significant
kmers
occur
suprisingly
often
family
respect
background
purposes
homework
define
unusualness
kmer
family
number
times
kmer
occurs
family
number
times
kmer
occurs
background
size
family
size
background
difference
actual
number
occurrences
expected
number
occurrences
appropriate
statistical
founded
definitions
involve
work
arrive
nearly
results
value
defines
kmers
compared
count
number
times
every
kmer
family
occurs
use
hashtable
part
collections
package
java
util
computing
background
counts
count
kmers
occur
family
hashtable
suitable
define
properly
can
use
hashtable
example
entry
hashtable
consist
pair
integers
family
count
background
count
real
values
score
unusualness
three
major
steps
task
plus
minor
ones
need
read
memory
two
files
store
strings
entirely
necessary
otherwise
will
worry
substrings
wrapping
around
end
one
line
beginning
next
line
files
masterhit
instructional
icsh23
files
family
file
nit
txt
file
standard
fasta
format
form
molecular
biologists
use
store
information
genes
surrounding
regions
process
file
need
skip
comment
lines
net
effect
read
file
form
single
long
string
3500
characters
second
file
complete
chromosome
yeast
16
chromosomes
called
chri
230203
txt
can
guess
many
characters
need
read
file
single
long
string
can
define
reader
class
process
either
file
will
provide
little
bit
code
computing
number
times
kmer
occurs
family
use
hashtable
hashmap
need
define
class
call
entry
goes
hashtable
key
entry
kmer
string
since
string
good
predefined
hashcode
need
define
anything
special
class
entry
require
least
two
fields
int
family
count
int
background
count
process
family
file
consider
kmer
turn
either
enter
hashtable
update
family
count
already
process
family
file
family
count
will
hold
number
occurrences
family
background
count
will
zero
complexity
linear
general
rule
also
avoid
processing
file
twice
file
many
entry
hashtable
might
fields
string
kmer
int
familycount
int
backgroundcount
double
score
computing
number
times
kmers
family
occur
background
use
hashtable
processing
file
little
different
kmer
file
check
see
occurs
hashtable
care
otherwise
update
background
count
computing
unusualness
sorting
kmers
value
luckily
hashtables
enumerators
hashmaps
iterators
associated
now
go
thru
hashtable
enter
best
scoring
kmers
cache
sorted
bounded
previous
assignment
finally
print
top
20
kmers
cache
kmersize
6
minor
step
instead
using
cache
class
may
use
treeset
collections
package
actually
print
entry
associated
kmers
output
look
something
like
kmer
times
family
times
background
score
aaaaaa
13
121
real
answer
etc
code
follow
code
will
concatenate
upstream
regions
single
string
write
br
readline
will
huge
unacceptable
cost
overhead
instead
fact
better
just
read
process
upstream
region
code
worked
guarantees
errorfree
complaints
improvements
welcomed
import
java
io
class
fastareader
string
data
fastareader
string
filename
try
file
file
new
file
filename
bufferedreader
bf
new
bufferedreader
new
filereader
file
stringbuffer
sbuf
new
stringbuffer
int
file
length
string
line
bf
readline
line
null
line
charat
0
'
'
sbuf
append
line
line
bf
readline
data
new
string
sbuf
bf
close
catch
ioexception
system
println
bad
file
something
homework
6
goal
dynamic
programming
needleman
wunsch
algorithm
read
chapter
10
3
covered
depth
either
text
needleman
wunsch
algorithm
many
applications
famous
application
helping
discover
function
proteins
finding
similar
proteins
known
function
also
applied
spelling
correction
basis
time
warping
algorithms
speech
recognition
task
also
includes
extending
algorithm
also
produces
alignment
can
either
graphical
interface
command
line
interface
using
terminal
io
input
program
consists
two
strings
output
needleman
wunsch
similarity
score
alignment
alignment
can
illustrated
via
dashes
following
example
using
graphics
use
fixed
size
font
example
input
string1
heagawghee
input
string2
pawheae
output
score
1
heagawghe
aw
heae
dash
indicates
character
skipped
final
score
unique
may
several
alignments
achieve
score
needleman
wunsch
algorithm
will
discussed
class
compute
alignment
suggest
using
separate
two
dimensional
array
record
backpointers
although
necessary
one
can
also
implement
algorithm
use
linear
space
takes
effort
care
last
assignment
due
june
5
two
week
assignment
competition
top
5
performers
scored
length
path
produced
will
get
double
grades
grade
will
also
replace
another
homework
score
assuming
better
grade
homework
7
goal
use
local
improvements
algorithm
traveling
salesman
problem
graphics
read
chapter
10
1
10
2
topic
greedy
algorithms
assigment
requires
graphical
display
inputs
program
two
integers
first
integer
seed
random
number
generator
second
integer
number
cities
code
generate
2
points
provided
point
will
values
range
0
100
program
display
initial
path
together
length
number
local
improvements
methods
might
try
minimum
implement
uncrossing
heuristic
may
add
operators
approaches
choose
code
will
evaluated
random
set
40
cities
best
operator
found
improving
tour
remove
crosses
operators
also
useful
swapping
pair
cities
moving
single
city
new
point
tour
need
implement
remove
crosses
heuristic
formula
detecting
crosses
fairly
simple
let
represent
distance
city
city
convenience
let
i'
j'
next
city
tour
need
worry
wrap
around
cross
exists
i'
j'
i'
j'
i'
j'
implement
doubly
linked
lists
can
uncross
path
pointer
moves
use
array
store
cities
will
need
swap
number
cities
may
use
collection
class
performance
measure
length
tour
program
finds
program
constrained
take
long
say
2
cpu
minutes
either
problem
note
grade
assignment
determined
standard
way
code
correct
clean
however
competition
holds
bar
thing
counts
length
tour
find
however
want
double
poor
grade
code
generating
array
points
note
like
math
functions
really
just
long
name
function
may
code
guarantees
city
unique
coordinates
code
import
java
util
class
random
import
java
awt
class
point
class
pointgenerator
point
pts
pointgenerator
int
seed
int
size
pts
new
point
size
int
xcoord
shuffle
new
random
seed
int
ycoord
shuffle
new
random
seed
1
int
0
size
pts
new
point
xcoord
ycoord
int
shuffle
random
returns
100
random
integers
repeats
0
99
int
ans
new
int
100
int
0
100
ans
int
99
bound
100
0
bound
swap
ans
modulo
nextint
bound
return
ans
int
modulo
int
int
compute
modulo
correctly
int
temp
temp
0
return
temp
return
temp
void
swap
int
int
int
int
temp
temp
point
getpoints
return
pts
end
code
final
exam
june
11
quiz
2
gives
reasonable
idea
form
final
except
will
longer
cover
entire
course
material
homework
read
chapter
10
1
10
2
topic
greedy
algorithms
assigment
requires
graphical
display
input
program
number
cities
city
will
placed
randomly
0
100
display
random
path
together
length
implement
two
ways
solving
problem
exhaustive
method
local
improvement
method
user
able
specify
method
time
method
improves
path
show
new
path
new
length
compare
effectiveness
method
problems
size
10
run
method
10
problems
course
exhaustive
method
will
find
best
solution
good
heuristic
approach
also
record
amount
time
method
makes
also
try
methods
larger
problems
exhaustive
approach
fail
unable
solve
problem
reasonable
amount
time
reasonable
1
minute
run
heuristic
10
times
problem
size
50
randomize
initial
ordering
cities
run
best
operator
found
improving
tour
remove
crosses
operators
also
useful
swapping
pair
cities
moving
single
city
new
point
tour
need
implement
remove
crosses
heuristic
formula
detecting
fairly
simple
let
represent
distance
city
city
convenience
let
i'
j'
next
city
tour
need
worrry
wrapping
around
cross
exists
i'
j'
i'
j'
i'
j'
implement
doubly
linked
lists
can
uncross
path
pointer
moves
use
array
store
cities
will
need
swap
number
cities
homework
queens
problem
assignment
requires
graphics
optionally
may
let
user
choose
board
size
can
set
reasonable
number
20
100
display
board
random
placement
queens
implement
greedy
local
improvement
algorithm
cycle
algorithm
display
number
queen
moves
provide
appropriate
summary
information
solution
reached
homework
goals
graphics
binary
search
read
appropriate
chapter
assignment
will
implement
gui
interface
displays
polynomial
information
polynomial
input
program
line
like
2
3
5
3
pair
real
numbers
say
3
1
6
1
constructor
polynomial
class
polynomial
string
define
method
double
evaluate
double
evaluates
polynomial
given
real
number
clever
way
evaluate
polynomial
program
will
graph
function
range
provided
finally
program
will
display
solution
problem
polynomial
0
part
problem
need
assume
solution
exists
solve
use
binary
search
order
apply
binary
search
will
need
two
values
x1
x2
domain
poly
x1
0
poly
x2
0
vice
versa
find
values
suggest
simple
linear
search
domain
test
poly
poly
1
's
break
domain
100
equal
sized
parts
values
found
use
binary
search
yield
approximate
solution
poly
0
following
possible
simple
layout
gui
interface
interface
contains
three
text
fields
inputting
polynomial
string
left
right
bound
button
causes
graphing
polynomial
somejpanel
polynomial
drawn
solution
0
solution
indicated
graphically
numerically
jtextfield
always
provide
time
space
analysis
appropraite
