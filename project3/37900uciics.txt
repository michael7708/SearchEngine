ics 180 april 22 1997 
alpha beta pruning 
ics
180a
spring
1997
strategy
board
game
programming
lecture
notes
april
22
1997
alpha
beta
search
shallow
pruning
suppose
minimax
search
described
last
time
following
tree
searched
found
children's
evaluations
11
12
7
9
level
search
first
player
move
expect
choose
best
values
12
minimax
value
12
now
start
searching
first
child
returns
value
15
happens
know
g's
value
will
least
15
possibly
even
higher
another
children
even
better
implies
expect
second
player
move
second
player's
point
view
f's
value
12
always
better
g's
value
15
higher
know
principal
variation
can
prune
remaining
children
evaluate
return
immediately
searching
since
work
evaluating
descendants
just
wasted
general
can
prune
like
node
one
children
returns
value
better
point
view
player
whose
turn
node
previously
computed
evaluation
one
g's
siblings
deep
pruning
complicated
forms
pruning
possible
well
example
suppose
search
tree
evaluated
better
12
12
total
evaluation
node
now
search
node
two
levels
see
evaluation
10
node
can
use
complicated
line
reasoning
prune
know
will
return
10
smaller
second
player
move
wants
choose
small
numbers
know
whether
value
10
smaller
will
returned
well
whether
one
children
will
better
value
10
smaller
returned
can
prune
better
sibling
case
exploration
children
pointless
case
child
returns
better
value
10
case
exploration
pointless
soon
see
10
can
safely
return
alpha
beta
pseudocode
general
returned
value
better
value
sibling
even
number
levels
tree
can
return
immediately
pass
minimum
value
siblings
parameter
beta
search
can
pruning
efficiently
also
use
another
parameter
alpha
keep
track
siblings
odd
levels
tree
pruning
using
two
values
simple
code
listed
like
last
time
use
negamax
formulation
evaluations
alternate
levels
trees
negated
double
alphabeta
int
depth
double
alpha
double
beta
depth
0
game
return
evaluation
generate
sort
list
moves
available
position
move
make
move
double
val
alphabeta
depth
1
beta
alpha
unmake
move
val
beta
return
val
val
alpha
alpha
val
return
alpha
explain
thursday
sorting
step
important
aspiration
search
supply
initial
values
alpha
beta
root
tree
alpha
beta
define
interval
real
number
line
alpha
beta
evaluations
consider
interesting
value
greater
beta
prune
immediately
return
know
part
principal
variation
really
care
exact
value
greater
beta
value
less
alpha
prune
still
consider
interesting
know
better
move
somewhere
else
tree
root
tree
know
range
evaluation
values
likely
interesting
want
sure
accidentally
pruning
something
important
just
set
alpha
infinity
beta
infinity
however
especially
using
iterated
deepening
likely
pretty
good
idea
principal
variation
going
look
like
suppose
guess
value
going
just
let
value
found
previously
searched
depth
1
let
epsilon
small
number
representing
amount
expect
depth
search
vary
depth
1
search
can
try
calling
alphabeta
epsilon
epsilon
three
different
things
can
happen
result
search
might
return
value
within
interval
epsilon
epsilon
case
know
returned
correct
value
can
safely
choose
move
search
tree
leading
node
value
search
might
return
value
epsilon
case
know
true
search
value
also
epsilon
know
correct
principal
variation
might
pruned
soon
saw
move
value
greater
beta
adjust
guess
higher
value
try
probably
also
larger
value
epsilon
condition
known
fail
high
search
might
return
value
epsilon
case
know
true
search
value
also
epsilon
know
adjust
guess
smaller
value
try
probably
also
larger
value
epsilon
condition
known
fail
low
even
though
can
fail
two
ways
using
aspiration
search
initial
interval
alpha
beta
smaller
infinity
infinity
usually
improvement
overall
much
pruning
analysis
analysis
alpha
beta
search
see
useful
idea
unlike
usual
kind
analysis
algorithms
best
case
analysis
assume
alpha
beta
prunes
often
possibly
can
see
next
time
need
make
alpha
beta
search
behave
way
consistent
analysis
class
analysis
considering
shallow
cuts
lecture
notes
include
deep
cuts
well
makes
analysis
much
simpler
best
case
node
depth
1
will
examine
one
child
depth
pruning
except
one
node
principal
variation
will
prune
overall
algorithm
will
end
failing
high
failing
low
certainly
best
case
depth
2
however
nobody
can
prune
children
returned
values
greater
equal
values
beta
passed
depth
2
negated
become
less
equal
alpha
continuing
tree
depth
3
everyone
except
principal
variation
prunes
depth
4
nobody
prunes
etc
branching
factor
tree
number
nodes
increases
factor
half
levels
tree
stays
pretty
much
constant
ignoring
principal
variation
half
levels
total
size
part
tree
gets
searched
ends
roughly
bd
2
sqrt
effectively
alpha
beta
search
ends
reducing
branching
factor
square
root
original
value
lets
one
search
twice
deeply
reason
essential
part
minimax
based
game
playing
program
david
eppstein
dept
information
computer
science
uc
irvine
wednesday
07
may
1997
14
57
17
pdt
