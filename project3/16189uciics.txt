longest common subsequences 
common substrings dynamic programming 
ics
161
design
analysis
algorithms
lecture
notes
february
29
1996
longest
common
subsequences
lecture
examine
another
string
matching
problem
finding
longest
common
subsequence
two
strings
good
example
technique
dynamic
programming
following
simple
idea
start
recursive
algorithm
problem
may
inefficient
calls
repeatedly
small
number
subproblems
simply
remember
solution
subproblem
first
time
compute
look
instead
recomputing
overall
time
bound
becomes
typically
proportional
number
distinct
subproblems
rather
larger
number
recursive
calls
already
saw
idea
briefly
first
lecture
see
two
ways
dynamic
programming
top
bottom
top
memoizing
method
closer
original
recursive
algorithm
easier
understand
bottom
method
usually
little
efficient
subsequence
testing
define
longest
common
subsequence
problem
start
easy
warmup
suppose
given
short
string
pattern
long
string
text
string
matching
problem
now
want
know
letters
pattern
appear
order
possibly
separated
text
say
pattern
subsequence
text
example
nano
subsequence
nematode
knowledge
yes
one
way
easiest
way
see
example
capitalize
subsequence
nematode
knowledge
general
can
test
using
finite
state
machine
draw
circles
arrows
corresponding
partial
subsequences
prefixes
pattern
now
need
backtracking
equivalently
easy
write
code
pseudo
code
subseq
char
char
'
0'
'
0'
return
true
return
false
longest
common
subsequence
problem
pattern
occur
text
still
makes
sense
find
longest
subsequence
occurs
pattern
text
longest
common
subsequence
problem
since
pattern
text
symmetric
roles
now
give
different
names
just
call
strings
use
denote
length
denote
length
note
automata
theoretic
method
solve
problem
instead
gives
longest
prefix
subsequence
longest
common
subsequence
always
prefix
might
want
solve
longest
common
subsequence
problem
several
motivating
applications
molecular
biology
dna
sequences
genes
can
represented
sequences
four
letters
acgt
corresponding
four
submolecules
forming
dna
biologists
find
new
sequences
typically
want
know
sequences
similar
one
way
computing
similar
two
sequences
find
length
longest
common
subsequence
file
comparison
unix
program
diff
used
compare
two
different
versions
file
determine
changes
made
file
works
finding
longest
common
subsequence
lines
two
files
line
subsequence
changed
displays
remaining
set
lines
changed
instance
problem
think
line
file
single
complicated
character
string
screen
redisplay
many
text
editors
like
emacs
display
part
file
screen
updating
screen
image
file
changed
slow
dial
terminals
programs
want
send
terminal
characters
possible
cause
update
display
correctly
possible
view
computation
minimum
length
sequence
characters
needed
update
terminal
sort
common
subsequence
problem
common
subsequence
tells
parts
display
already
correct
need
changed
aside
natural
define
similar
longest
common
substring
problem
asking
longest
substring
appears
two
input
strings
problem
can
solved
linear
time
using
data
structure
known
suffix
tree
solution
extremely
complicated
recursive
solution
want
solve
longest
common
subsequence
problem
dynamic
programming
first
need
recursive
solution
dynamic
programming
idea
tell
us
find
just
gives
us
way
making
solution
efficient
start
simple
observations
lcs
problem
two
strings
say
nematode
knowledge
empty
bottle
can
represent
subsequence
way
writing
two
certain
letters
line
draw
lines
connecting
letters
first
string
corresponding
letters
second
two
lines
cross
top
bottom
endpoints
occur
order
order
letters
subsequence
conversely
set
lines
drawn
like
without
crossings
represents
subsequence
can
observe
following
simple
fact
two
strings
start
letter
always
safe
choose
starting
letter
first
character
subsequence
subsequence
represented
collection
lines
drawn
can
push
leftmost
line
start
two
strings
without
causing
crossings
get
representation
equally
long
subsequence
start
way
hand
suppose
like
example
two
first
characters
differ
possible
part
common
subsequence
one
maybe
will
removed
finally
observe
decided
first
characters
strings
remaining
subproblem
longest
common
subsequence
problem
two
shorter
strings
therefore
can
solve
recursively
rather
finding
subsequence
turns
efficient
find
length
longest
subsequence
case
first
characters
differ
can
determine
subproblem
gives
correct
solution
solving
taking
max
resulting
subsequence
lengths
turn
dynamic
program
will
see
get
sequence
observations
give
us
following
inefficient
recursive
algorithm
recursive
lcs
int
lcs
length
char
char
'
0'
'
0'
return
0
else
return
1
lcs
length
1
1
else
return
max
lcs
length
1
lcs
length
1
correct
solution
time
consuming
example
two
strings
matching
characters
last
line
always
gets
executed
time
bounds
binomial
coefficients
close
2
memoization
problem
recursive
solution
subproblems
get
called
many
different
times
subproblem
consists
call
lcs
length
arguments
two
suffixes
exactly
1
1
possible
subproblems
relatively
small
number
nearly
2
recursive
calls
subproblems
must
solved
dynamic
programming
solution
check
whenever
want
solve
subproblem
whether
already
done
look
solution
instead
recomputing
implemented
direct
way
just
add
code
recursive
algorithm
look
top
recursive
version
dynamic
programming
known
memoization
lcs
problem
subproblems
consist
pair
suffixes
two
input
strings
make
easier
store
look
subproblem
solutions
represent
starting
positions
strings
rather
wrote
character
pointers
recursive
lcs
indices
char
char
int
lcs
length
char
aa
char
bb
aa
bb
return
subproblem
0
0
int
subproblem
int
int
'
0'
'
0'
return
0
else
return
1
subproblem
1
1
else
return
max
subproblem
1
subproblem
1
now
turn
dynamic
programming
algorithm
need
use
array
store
subproblem
results
want
solution
subproblem
first
look
array
check
already
solution
return
otherwise
perform
computation
store
result
lcs
problem
result
negative
use
1
flag
tell
algorithm
nothing
stored
yet
memoizing
lcs
char
char
array
int
lcs
length
char
aa
char
bb
aa
bb
allocate
storage
0
0
1
return
subproblem
0
0
int
subproblem
int
int
0
'
0'
'
0'
0
else
1
subproblem
1
1
else
max
subproblem
1
subproblem
1
return
time
analysis
call
subproblem
takes
constant
time
call
main
routine
twice
every
time
fill
entry
array
1
1
entries
total
number
calls
2
1
1
1
time
mn
usual
worst
case
analysis
time
might
sometimes
better
array
entries
get
filled
instance
two
strings
match
exactly
fill
diagonal
entries
algorithm
will
fast
bottom
dynamic
programming
can
view
code
just
slightly
smarter
way
original
recursive
algorithm
saving
work
repeating
subproblem
computations
can
also
thought
way
computing
entries
array
recursive
algorithm
controls
order
fill
get
results
filled
order
might
well
use
something
simpler
like
nested
loop
visits
array
systematically
thing
worry
fill
cell
need
already
know
values
depends
namely
case
1
1
1
1
reason
traverse
array
backwards
last
row
working
first
last
column
working
first
iterative
uses
nested
loops
instead
recursion
bottom
order
fill
array
smaller
simpler
subproblems
bigger
complicated
ones
iterative
lcs
int
lcs
length
char
char
allocate
storage
array
0
0
'
0'
'
0'
0
else
1
1
1
else
max
1
1
return
0
0
advantages
method
include
fact
iteration
usually
faster
recursion
need
initialize
matrix
1's
save
three
statements
per
iteration
since
need
test
whether
1
1
already
computed
know
advance
answers
will
yes
yes
one
disadvantage
memoizing
fills
entire
array
even
might
possible
solve
problem
looking
fraction
array's
cells
subsequence
want
subsequence
just
length
important
applications
mentioned
filled
array
described
can
find
sequence
working
forwards
array
sequence
empty
0
0
add
end
else
1
1
else
see
example
array
earlier
example
7
7
6
5
5
5
5
5
4
3
3
3
2
2
2
1
1
1
0
6
6
6
5
5
4
4
4
4
3
3
3
2
2
1
1
1
1
0
5
5
5
5
5
4
4
4
4
3
3
3
2
2
1
1
1
1
0
5
5
5
5
5
4
4
4
4
3
3
3
2
2
1
1
1
1
0
4
4
4
4
4
4
4
4
4
3
3
3
2
2
1
1
1
1
0
4
4
4
4
4
4
4
4
4
3
3
3
2
2
1
1
1
1
0
3
3
3
3
3
3
3
3
3
3
3
3
2
2
1
1
1
1
0
3
3
3
3
3
3
3
3
3
3
3
3
2
2
1
1
1
1
0
3
3
3
3
3
2
2
2
2
2
2
2
2
2
1
1
1
1
0
3
3
3
3
3
2
2
2
2
2
2
2
2
2
1
1
1
1
0
2
2
2
2
2
2
2
2
2
2
2
2
2
2
1
1
1
1
0
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
can
check
entry
computed
correctly
entries
right
find
longest
common
subsequence
look
first
entry
0
0
7
telling
us
sequence
seven
characters
0
0
computed
max
0
1
1
0
corresponding
subproblems
formed
deleting
either
first
string
second
deleting
gives
subsequence
length
0
1
7
deleting
gives
1
0
6
can
delete
now
look
entry
0
1
coming
deletion
0
1
can
safely
include
part
subsequence
move
1
2
6
similarly
entry
gives
us
sequence
continuing
way
breaking
ties
algorithm
moving
instead
across
gives
common
subsequence
emt
ole
can
find
longest
common
subsequences
time
mn
actually
look
matrix
can
tell
lot
structure
numbers
matrix
form
large
blocks
value
constant
small
number
corners
value
changes
turns
one
can
take
advantage
corners
speed
computation
current
theoretically
fastest
algorithm
longest
common
subsequences
due
co
authors
runs
time
log
log
log
min
mn
number
corners
number
characters
appearing
two
strings
relation
paths
graphs
draw
directed
graph
vertices
corresponding
entries
array
edge
connecting
entry
one
depends
either
one
edge
1
1
two
edges
1
1
otherwise
draw
edges
bottom
right
fringe
array
since
entries
depend
others
look
path
graph
diagonal
edges
form
subsequence
two
strings
conversely
define
horizontal
vertical
edges
length
zero
diagonal
edges
length
one
longest
common
subsequence
corresponds
longest
path
top
left
corner
one
bottom
right
vertices
graph
acyclic
can
compute
longest
paths
time
linear
size
graph
mn
edge
lengths
come
just
amount
lcs
length
increases
compared
length
corresponding
subproblem
1
1
1
use
last
1
edge
length
otherwise
max
1
1
0
use
zero
edge
length
sort
phenomenon
dynamic
programming
problem
turns
equivalent
shortest
longest
path
problem
always
happen
problems
reasonably
common
idea
really
help
compute
single
longest
common
subsequence
one
papers
uses
similar
graph
theoretic
ideas
find
multiple
long
common
subsequences
multiple
solutions
many
problems
reduced
space
complexity
one
disadvantage
dynamic
programming
methods
described
compared
original
recursion
use
lot
space
mn
array
recursion
uses
iterative
version
can
easily
modified
use
less
space
observation
computed
row
array
longer
need
values
row
1
space
efficient
lcs
int
lcs
length
char
char
allocate
storage
one
dimensional
arrays
0
0
'
0'
'
0'
0
else
1
1
else
max
1
return
0
takes
roughly
amount
time
mn
uses
little
time
copy
increases
time
constant
can
avoided
care
space
either
whichever
smaller
switch
two
strings
necessary
rows
columns
unfortunately
solution
leave
enough
information
find
subsequence
just
length
1975
dan
hirschberg
showed
find
just
length
longest
common
subsequence
linear
space
mn
time
idea
use
one
dimensional
arrays
store
rows
larger
two
dimensional
array
hirschberg's
method
treats
middle
row
array
specially
2
stores
along
numbers
place
path
corresponding
subsequence
many
characters
crosses
middle
row
crossing
places
can
updated
along
array
values
copying
1
1
appropriate
algorithm
finished
lcs
length
0
hirschberg
finds
corresponding
crossing
place
2
solves
recursively
two
lcs
problems
one
0
2
1
0
1
one
2
longest
common
subsequence
concatenation
sequences
found
two
recursive
calls
hard
see
method
uses
linear
space
time
complexity
recursive
algorithm
time
recurrence
mn
2
2
can
think
sort
like
quicksort
breaking
strings
parts
unlike
quicksort
matter
second
string
can
broken
unequally
matter
recurrence
solves
mn
easiest
way
see
think
array
main
part
algorithm
visits
whole
array
two
calls
visit
two
subarrays
one
left
2
right
matter
total
size
two
subarrays
roughly
mn
2
instead
can
write
simplified
recurrence
mn
mn
mn
2
solves
mn
time
total
ics
161
dept
information
computer
science
uc
irvine
last
update
21
aug
2011
08
47
13
pdt
