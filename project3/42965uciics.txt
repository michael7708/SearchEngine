abstract classes 

abstract
classes
introduction
computer
science
iii
ics
21
22
23
introduction
lecture
will
continue
discussion
inheritance
features
examing
abstract
classes
many
ways
abstract
classes
simple
concept
involving
one
new
keyword
can
used
two
places
deep
ramifications
designing
complex
class
hierarchies
will
discuss
java
language
feature
context
positional
shape
inheritance
demo
download
run
examine
lecture
will
compare
abstract
classes
interfaces
seem
closely
related
example
can
extend
interfaces
via
inheritance
see
multiple
ways
accomplish
approximate
result
compare
finally
will
examine
general
principles
designing
classes
inheritance
hierarchies
defining
abstract
methods
classes
sometimes
class
define
method
logically
belongs
class
class
specify
implement
method
example
shape
class
used
superclass
2
dimensional
shapes
like
circles
rectangles
etc
logically
every
shape
getarea
method
every
shape
area
every
shape
compute
area
using
different
formula
way
specify
one
getarea
method
shape
class
correct
possible
subclasses
application
might
want
declare
shape
array
fill
references
objects
constructed
actual
shapes
subclasses
shape
ask
shape
return
area
like
java
call
correct
getshape
method
object
compute
result
correctly
illustrate
java
implements
polymorphism
solve
problem
accomplish
java
defining
getarea
method
shape
class
specfying
abstract
keyword
list
access
modifiers
syntax
constraint
keyword
can
used
defining
classes
methods
specifying
implementation
method
body
just
like
interface
specify
shape
class
follows
public
abstract
double
getarea
defining
method
telling
java
compiler
allows
us
call
getarea
method
using
variable
declared
type
shape
declared
class
subclass
shape
definition
getarea
will
really
appear
example
can
define
tostring
method
shape
class
public
string
tostring
return
shape
id
id
area
getarea
method
calls
getarea
returns
string
area
shape
first
big
rule
using
abstract
concerns
abstract
methods
can
called
method
class
can
declared
abstract
method
body
replaced
just
interfaces
can
called
methods
defined
class
called
methods
defined
subclasses
called
using
variables
whose
type
class
subclasses
second
big
rule
using
abstract
concerns
relationship
abstract
method
classes
defined
class
defines
abstract
methods
will
see
inherits
abstract
methods
override
class
must
defined
using
abstract
keyword
access
modifiers
second
rule
violated
java
compiler
will
detect
report
error
forget
make
class
abstract
java
will
just
remind
us
harm
caused
fact
will
define
shape
class
using
id
instance
variable
constructor
throughout
examples
lecture
public
abstract
class
shape
public
shape
string
id
id
id
abstract
method
must
defined
concrete
subclass
note
called
class
tostring
method
public
abstract
double
getarea
public
string
getid
return
id
public
string
tostring
return
shape
id
id
area
getarea
private
string
id
generally
abstract
classes
can
specify
standard
class
components
constructors
methods
instance
variables
class
must
defined
keyword
abstract
case
methods
defined
keyword
abstract
case
note
can
call
abstract
method
methods
defined
class
even
body
defined
yet
logically
method
belongs
class
even
written
shape
high
hierarchy
using
abstract
classes
superclasses
now
obvious
make
sense
write
shape
new
shape
s1
system
println
although
allowed
call
getarea
method
java
knows
prototype
method
implementation
specified
java
idea
code
execute
compute
getarea
inside
tostring
problem
method
call
construction
issue
brings
us
third
big
rule
using
abstract
classes
concerning
restriction
calling
constructors
subclasses
class
defined
keyword
abstract
may
call
constructor
via
super
class
extends
via
new
operator
explicitly
construct
object
using
abstract
class
can
use
help
construct
object
subclass
thus
java
compiler
detect
report
error
statement
shape
new
shape
s1
never
even
get
compiling
call
getarea
method
construct
object
abstract
class
can
one
can
definine
subclass
extends
subclass
overrides
every
abstract
method
inherits
subclass
abstract
inherits
abstract
methods
override
subclass
also
abstract
methods
must
also
defined
abstract
call
non
abstract
class
concrete
although
keyword
name
example
can
define
concrete
circle
subclass
extending
shape
follows
public
class
circle
extends
shape
public
circle
string
name
double
super
name
radius
overide
abstract
method
declared
shape
public
double
getarea
return
math
pi
radius
radius
public
double
getradius
return
radius
public
void
setradius
double
newradius
radius
newradius
public
string
tostring
return
circle
radius
radius
super
tostring
private
double
radius
circle
subclass
override
one
abstract
method
inherits
shape
defines
new
methods
none
abstract
concrete
class
therefore
defined
abstract
keyword
also
notice
constructor
must
supplied
radius
stored
instance
variable
class
used
compute
area
described
although
constuct
new
object
class
shape
can
call
constructor
class
inside
constructor
subclass
circle
class
call
super
name
constructor
circle
class
concrete
can
construct
new
objects
class
can
write
circle
new
circle
c1
1
0
system
println
tostring
just
will
print
circle
radius
1
0
shape
id
c1
area
3
141592653589793
fact
can
even
write
shape
new
circle
c1
1
0
note
type
system
println
tostring
just
prints
exactly
thing
reasoning
shape
circle
define
tostring
methods
java
allows
us
call
tostring
variables
cases
object
refer
constructed
circle
class
method
defined
class
called
stop
think
hard
many
students
reason
since
defined
type
shape
calling
tostring
calls
tostring
method
defined
shape
class
incorrect
thinking
recall
java's
rule
say
type
determines
methods
can
called
class
object
determines
method
called
polymorphism
action
course
wrote
shape
new
circle
c1
1
0
call
setradius
2
0
type
shape
defines
setradius
method
wrote
circle
new
circle
c1
1
0
call
setradius
2
0
type
circle
define
method
finally
learn
fourth
last
big
rule
using
abstract
can
treat
abstract
class
superclass
extend
subclasses
can
override
inherited
abstract
methods
overriding
subclass
contains
abstract
methods
class
concrete
can
construct
objects
directly
still
abstract
can
used
superclass
eventually
subclass
subclass
concrete
can
also
easily
define
simlar
subclass
rectangles
public
class
rectangle
extends
shape
public
rectangle
string
name
double
double
super
name
width
height
overide
abstract
method
declared
shape
public
double
getarea
return
width
height
public
double
getwidth
return
width
public
double
getheight
return
height
public
void
setwidthheight
double
newwidth
double
newheight
width
newwidth
height
newheight
public
string
tostring
return
rectangle
width
width
height
height
super
tostring
private
double
width
height
rectangle
class
also
concrete
can
construct
new
objects
class
can
write
example
shape
new
rectangle
r1
2
0
3
0
note
type
system
println
will
print
rectangle
width
2
0
height
3
0
shape
id
r1
area
6
0
can
picture
object
using
standard
notation
course
simple
add
shapes
square
triangle
etc
hierarchy
extending
shape
class
neither
shape
class
circle
rectangle
need
know
information
newly
added
shapes
now
lets
look
complicated
example
writing
parts
model
class
uses
arrays
abstract
classes
interfaces
suppose
wanted
store
array
ten
object
constructed
subclasses
shape
declare
shape
allshapes
new
shape
10
initialize
array
member
migh
index
circles
rectangles
now
assume
want
find
two
shapes
similar
area
can
first
sorting
shapes
array
areas
smallest
biggest
can
call
arrays
sort
using
allshapes
array
following
anonymous
class
implements
correct
comparator
arrays
sort
allshapes
new
comparator
public
int
compare
object
o1
object
o2
double
areadiff
shape
o1
getarea
shape
o2
getarea
areadiff
0
return
1
else
areadiff
0
return
1
else
return
0
now
can
scan
array
find
adjacent
shapes
similar
areas
int
bestindex
1
double
mindist
double
max
value
int
0
allshapes
length
1
double
newdist
allshapes
1
getarea
allshapes
getarea
newdist
mindist
bestindex
mindist
newdist
now
minimum
distance
bestindex
bestindex
1
without
abstract
methods
classes
can
get
close
effect
declaring
abstract
methods
classes
following
remove
word
abstract
method
class
implement
formerly
abstract
method
stub
method
void
body
just
method
returns
primitive
value
return
0
0
0
'
'
false
method
returns
reference
object
return
null
just
method
throw
unsupportedoperationexception
either
case
method
nothing
useful
leave
unchanged
methods
subclass
overrides
formerly
abstract
method
compiling
working
classes
will
still
compile
work
changes
will
execute
identically
good
things
can
also
happen
can
construct
objects
formerly
abstract
class
calling
stub
methods
bad
results
returned
can
extend
formerly
abstract
class
forget
override
stub
methods
calling
methods
usefuless
results
also
returned
latter
case
easy
mistake
omission
even
one
misspelling
used
abstract
methods
java
compiler
detect
inform
us
subclass
must
defined
abstract
abstract
method
overridden
typically
message
really
says
normally
fix
problem
defining
class
abstract
adding
fixing
appropriate
method
designers
java
felt
possiblity
messing
way
big
introduced
keyword
abstract
language
purposes
explained
purpose
much
like
final
variables
can
provide
compiler
extra
information
intent
something
inconsistant
intent
receive
error
message
java
compiler
positional
shape
hierarchy
now
deal
complicated
example
positional
shape
inheritance
hierarchy
illustrated
graphically
superscript
used
denote
classes
abstract
root
inheritance
hierarchy
shown
concrete
object
class
shape
subclass
defined
exactly
shown
extends
concrete
superclass
introduces
abstract
method
getarea
becomes
abstract
positionalshape
subclass
extends
abstract
shape
superclass
defines
constructor
initializes
one
new
instance
variable
point
read
javadoc
standard
java
library
specifies
position
center
shape
coordinate
2
dimensional
plane
class
adds
new
methods
manipulate
position
adds
one
additional
abstract
method
returns
bounding
box
shape
smallest
rectangle
shape
can
enclosed
note
class
full
name
java
awt
rectange
rectangle
class
will
define
read
javadoc
standard
java
library
finally
adds
one
additional
method
detects
whether
two
shapes
may
overlap
checking
intersection
bounding
boxes
bounding
boxes
intersect
possibility
overlap
class
must
abstract
contains
two
abstract
methods
specifies
getboundingbox
also
inherits
override
getarea
complete
class
public
abstract
class
positionalshape
extends
shape
public
positionalshape
string
id
int
centerx
int
centery
super
id
center
new
point
centerx
centery
abstract
methods
must
defined
concrete
subclass
public
abstract
rectangle
getboundingbox
public
point
getcenter
return
center
public
double
distanceto
positionalshape
return
center
distance
center
public
void
movecenterto
point
newcenter
center
newcenter
center
newcenter
public
void
movecenterby
int
dx
int
dy
center
dx
center
dy
public
boolean
mayoverlap
positionalshape
return
getboundingbox
intersects
getboundingbox
public
string
tostring
return
positionalshape
center
center
super
tostring
fields
private
point
center
notice
although
class
know
bounding
boxes
constructed
positionalshape
objects
method
abstract
defines
concrete
mayoverlap
method
knows
getboundingbox
method
concrete
subclass
positionalshape
defined
concretely
thus
just
concrete
tostring
method
shape
class
called
abstract
method
getarea
concrete
mayoverlap
method
positionalshape
class
calls
abstract
method
getboundingbox
finally
can
define
circle
subclass
follows
note
concrete
extends
abstract
positionalshape
class
overrides
getarea
getboundingbox
methods
public
class
circle
extends
positionalshape
public
circle
string
name
int
centerx
int
centery
double
super
name
centerx
centery
radius
overide
abstract
method
declared
shape
public
double
getarea
return
math
pi
radius
radius
overide
abstract
method
declared
positionalshapee
public
rectangle
getboundingbox
return
new
rectangle
int
getcenter
radius
int
getcenter
radius
int
2
radius
int
2
radius
public
double
getradius
return
radius
public
void
setradius
double
newradius
radius
newradius
public
string
tostring
return
circle
radius
radius
super
tostring
fields
private
double
radius
bounding
boxes
specified
coordinate
shapes
upper
left
corner
width
height
circel
picture
bounding
box
bounding
boxes
can
detect
whether
two
shapes
may
overlap
checking
intersection
bounding
boxes
intersect
possibility
overlap
intersect
shapes
must
examined
closely
property
illustrated
given
intheritance
can
picture
result
calling
new
circle
c1
100
150
1
0
following
picture
already
done
download
positional
shape
inheritance
demonstration
run
driver
program
contains
code
well
defintion
rectangle
class
notice
rectangle
class
differentiate
rectangle
class
defining
java
awt
rectangle
class
using
help
define
import
full
class
name
prefixed
package
name
finally
notice
shape
class
defines
concrete
promptforinformation
method
overridden
called
via
super
positionalshape
class
overridden
called
via
super
circle
rectangle
class
lot
like
tostring
overridden
called
classes
result
checking
instanceof
casting
application
absence
always
desired
ensures
add
subclasses
positionalshape
will
work
application
must
change
get
application
allow
return
subclasses
writing
instanceof
probably
defining
classes
correctly
making
appropriate
use
polymorphism
example
need
know
whether
object
drawn
straight
lines
square
rectangle
polygon
circle
elipse
use
instanceof
pick
right
classes
instead
define
public
abstract
boolean
drawnwithlines
inside
shape
class
override
method
subclass
inheritance
interfaces
another
interesting
way
design
circle
rectangle
classes
use
inheritance
interfaces
combined
inheritance
classes
abstract
classes
must
first
learn
can
use
keyword
extends
specify
one
interface
extends
another
fact
unlike
classes
interface
can
extend
multiple
interfaces
much
like
way
class
can
implement
multiple
interfaces
recall
class
can
extend
one
class
use
subinterfaces
superinterfaces
will
appear
immediately
including
specification
subinterface
extend
multiple
superinterfaces
will
start
specifying
two
interfaces
separately
shape
position
one
interface
properties
positionshape
notice
interfaces
include
abstract
concrete
methods
defined
shape
positionalshape
classes
except
tostring
needed
every
class
whether
implements
interfaces
inherits
tostring
method
can
override
public
interface
shape
public
double
getarea
public
string
getid
public
interface
position
public
point
getcenter
public
double
distanceto
position
public
void
movecenterto
point
newcenter
public
void
movecenterby
int
dx
int
dy
public
interface
positionalshape
extends
position
shape
public
rectangle
getboundingbox
public
boolean
mayoverlap
positionalshape
positionalshape
sub
interface
inherits
methods
specified
position
shape
super
interfaces
specifies
two
new
methods
methods
new
inherited
interfaces
make
sense
specify
getboundingbox
mayoverlap
either
individual
interface
concepts
bounding
boxes
overlaping
shapes
make
sense
applied
just
shapes
without
positions
just
positions
without
shapes
makes
sense
specify
methods
within
interfaces
combining
shape
position
properities
declare
variable
using
positionalshape
interface
java
allows
us
use
variable
call
methods
shape
position
positionalshape
interfaces
guess
also
call
interfaces
shapelyposition
begins
get
point
obvious
reason
shape
superclass
extend
positionalshape
position
superclass
extend
shapelypositional
original
design
needed
make
arbitrary
choice
subclass
superclass
design
avoid
making
choice
developing
part
can
combining
equal
terms
define
interfaces
can
define
three
simple
classes
implement
last
classes
implemented
using
first
two
will
extended
defining
circle
rectangle
classes
first
define
class
implements
basic
part
shape
interface
abstract
method
say
implements
shape
defines
getarea
method
public
class
shapebasics
public
shapebasics
string
id
id
id
public
string
getid
return
id
public
string
tostring
return
shapebasics
id
id
private
string
id
next
similarly
define
positionbasics
class
can
say
implements
position
defines
specified
methods
formerly
abstract
getboundingbox
method
specified
position
interface
positionalshape
can
specify
implements
position
public
class
positionbasics
implements
position
public
positionbasics
int
centerx
int
centery
center
new
point
centerx
centery
public
point
getcenter
return
center
public
double
distanceto
position
return
center
distance
getcenter
public
void
movecenterto
point
newcenter
center
newcenter
center
newcenter
public
void
movecenterby
int
dx
int
dy
center
dx
center
dy
public
string
tostring
return
positionbasic
center
center
fields
private
point
center
note
one
small
change
distanceto
method
now
implemented
via
return
center
distance
getcenter
instead
return
center
distance
center
position
parameter
interface
stores
instance
variables
method
access
finally
define
abstract
class
implements
basic
part
positionalshape
interface
abstract
class
concrete
circle
rectangle
classes
will
extend
positionshapebasics
class
constructs
objects
shapebasics
positionbasics
classes
uses
objects
whenever
one
methods
needed
called
delegation
one
object
uses
another
implement
method
thus
class
defines
many
methods
shape
position
positionalshape
interfaces
concrete
also
two
first
design
abstract
methods
getarea
getboundingbox
concrete
methods
implemented
delegation
one
line
bodies
delegate
call
right
object
note
mayoverap
can
defined
concretely
knowing
getboundingbox
method
will
eventually
defined
concrete
subclass
public
abstract
class
positionalshapebasics
implements
positionalshape
public
positionalshapebasics
string
name
int
centerx
int
centery
new
shapebasics
name
new
positionbasics
centerx
centery
abstracts
method
must
defined
concrete
subclass
public
abstract
double
getarea
public
abstract
rectangle
getboundingbox
public
string
getid
return
getid
public
double
distanceto
position
return
distanceto
public
point
getcenter
return
getcenter
public
void
movecenterto
point
newcenter
movecenterto
newcenter
public
void
movecenterby
int
dx
int
dy
movecenterby
dx
dy
public
boolean
mayoverlap
positionalshape
return
getboundingbox
intersects
getboundingbox
public
string
tostring
return
positionalshapebasics
fields
private
shapebasics
private
positionbasics
class
extending
positionalshapebasics
class
design
can
jobs
class
subclassing
positionalshape
class
previous
design
class
like
circle
defined
almostly
identically
difference
name
class
extends
comments
class
recall
knowing
circle
extends
positionalshapebasics
positionalshapebasics
implements
positionalshape
java
deduces
write
circle
implements
positionalshape
public
class
circle
extends
positionalshapebasics
public
circle
string
name
int
centerx
int
centery
double
super
name
centerx
centery
radius
implement
getarea
method
specified
shape
interface
public
double
getarea
return
math
pi
radius
radius
implement
getboundingbox
method
specified
inthe
positionalshape
interface
public
rectangle
getboundingbox
return
new
rectangle
int
getcenter
radius
int
getcenter
radius
int
2
radius
int
2
radius
public
double
getradius
return
radius
public
void
setradius
double
newradius
radius
newradius
public
string
tostring
return
circle
radius
radius
super
tostring
fields
private
double
radius
hierarchy
picture
circle
object
follows
recall
positionalshapebasics
abstract
class
delegates
methods
objects
referred
either
instance
variables
advantage
design
given
time
construct
circle
rectangle
subclasses
similar
ones
identically
stated
second
design
bit
symmetrical
first
design
certainly
easier
understand
2
abstract
classes
2
concrete
ones
vs
3
interfaces
4
concrete
classes
1
abstract
one
general
design
rule
says
prefer
delegation
inheritance
can
delegate
using
many
classes
directly
inherit
one
interfaces
classes
can
easily
constructed
use
properties
interfaces
classes
others
like
fact
pattern
used
second
solution
although
complicated
can
used
often
solve
similar
similar
problems
think
bottom
line
good
design
hard
goal
class
can
design
elegant
inheritance
hierarchies
goal
given
inheritance
hierarchy
can
quickly
read
understand
use
extend
classes
contains
can
download
alternative
code
positional
shape
inheritance
demonstration
2
run
driver
identical
first
one
contains
code
well
rectangle
class
general
comments
inheritance
next
lecture
will
apply
inheritance
acheive
perfect
understanding
exceptions
will
introduce
new
material
section
like
make
just
observations
classes
good
design
hard
reread
last
part
previous
section
try
fix
poor
design
hacking
implementation
fix
design
two
important
relationships
classes
must
able
recognize
understand
differentiate
extends
mechanism
also
know
mechanism
appropriate
use
subclass
slightly
different
extended
class
superclass
delegation
mechanism
known
mechanism
appropriate
use
object
one
class
object
another
class
help
work
remember
state
implement
behavior
second
object
stored
instance
variable
first
liskov
subsitution
rule
object
o1
type
object
o2
type
programs
defined
terms
behavior
unchanged
o1
substituted
o2
subtype
paraphrased
subclass
everything
can
object
class
also
make
sense
effect
object
class
example
often
dragged
circles
elipses
mathematicians
want
say
circle
just
special
kind
elipse
setaxes
double
double
method
elipses
makes
sense
apply
circle
since
one
radius
major
minor
axis
likewise
elipse
just
special
kind
circle
relationship
radius
circle
area
makes
sense
speaking
elipses
fundamental
level
appealing
may
circle
elipses
related
one
example
define
circle
elipses
classes
separately
implement
circle
class
delegating
behavior
elipse
stored
instance
variable
ensuring
major
minor
axes
always
implementation
technique
delegation
common
asserted
inheritance
problems
boil
variant
circle
elipses
scenario
smart
enough
spot
truly
understand
reasoning
will
able
apply
everywhere
example
sortedlist
extend
list
can
perform
many
operations
list
make
sense
sortedlist
can
call
insertfront
insertrear
list
inserted
value
becomes
first
last
value
respectively
list
sortedlist
put
values
places
can
put
values
move
naturally
sorted
place
one
example
specify
list
sortedlist
class
separately
implement
sortedlist
delegating
behavior
list
see
delegation
relationships
common
inheritance
relationships
classes
generally
classes
closed
modification
open
extension
means
specification
implementation
class
stabilizes
never
change
instead
can
extend
subclasses
behave
similarly
identically
need
different
state
behavior
relationships
among
classes
large
system
quite
advanced
topic
need
lots
experience
reading
classes
noticing
designs
learning
use
effectively
can
start
creating
complicated
designs
finally
final
access
modifier
class
methods
classes
method
class
prefaced
final
access
modifier
means
overridden
likewise
class
prefaced
final
access
modifier
means
extended
thus
none
methods
can
overridden
string
class
defined
final
abstract
rules
review
review
four
rules
using
abstract
keyword
collected
one
place
method
class
can
declared
abstract
method
body
replaced
just
interfaces
can
called
methods
defined
class
called
methods
defined
subclasses
called
using
variables
whose
type
class
subclasses
class
defines
abstract
methods
will
see
inherits
abstract
methods
override
class
must
defined
using
abstract
keyword
access
modifiers
class
defined
keyword
abstract
may
call
constructor
via
super
class
extends
via
new
operator
explicitly
construct
object
using
abstract
class
can
use
help
construct
object
subclass
can
treat
abstract
class
superclass
extend
subclasses
can
override
inherited
abstract
methods
overriding
subclass
contains
abstract
methods
class
concrete
can
construct
objects
directly
still
abstract
can
used
superclass
eventually
subclass
subclass
concrete
problem
set
ensure
understand
material
lecture
please
solve
announced
problems
read
lecture
get
stumped
problem
go
back
read
relevant
part
lecture
still
questions
please
get
help
instructor
ta
student
java
allow
us
declare
class
abstract
even
define
inherits
abstract
methods
expect
properties
class
make
sense
define
final
abstract
method
use
two
access
modifiers
together
write
modularcounter
class
previous
lecture
implement
counter
subclassing
intcounter
instead
store
intcounter
delegate
methods
operate
explain
subclass
can
overload
inherited
method
override
think
abstract
class
can
say
implements
interface
even
one
methods
interface
declared
abstract
class
explain
answer
reasonable
