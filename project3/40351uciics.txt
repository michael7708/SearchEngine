eighth homework 
fsas grammars sentence generation 
assignment
due
wednesday
march
12
much
coding
except
last
part
may
pairs
code
implements
finite
state
machine
final
int
secret1
35
final
int
secret2
127
final
int
secret3
33
string
statelist
init
gotfirst
gotsecond
success
int
number
int
count
1
string
state
void
main
state
init
state
equals
success
count
3
number
getnext
state
equals
init
number
secret1
state
gotfirst
else
state
init
else
state
equals
gotfirst
number
secret2
state
gotsecond
else
state
init
else
state
equals
gotsecond
number
secret3
state
success
else
state
init
count
state
equals
success
system
println
input
accepted
else
system
println
input
rejected
1
draw
state
transition
diagram
represents
fsa
program
implements
input
tokens
whole
integers
individual
characters
2
describe
one
brief
english
sentence
fsa
try
think
simple
real
world
non
computer
related
object
fsa
models
intermezzo
state
transition
diagrams
one
way
describe
fsas
another
way
easier
represent
computer
transition
table
transition
table
row
state
column
input
value
position
table
tells
state
go
read
given
input
given
state
transition
table
program
secret1
secret2
secret3
init
gotfirst
init
init
init
gotfirst
init
gotsecond
init
init
gotsecond
init
init
success
init
success
table
says
just
program
state
transition
diagram
say
init
read
secret1
go
state
gotfirst
state
init
read
anything
else
stay
init
state
gotfirst
read
secret2
go
state
gotsecond
read
anything
else
state
gotfirst
go
state
init
finally
state
gotsecond
read
secret3
go
state
success
otherwise
go
init
state
success
machine
stops
make
transitions
state
accept
state
noted
transition
tables
make
fsas
easy
represent
computer
fact
can
write
simple
general
fsa
simulator
according
following
pseudocode
initialize
transitiontable
state
initial
state
tokens
get
token
state
transitiontable
state
token
state
accept
state
accept
else
reject
code
simple
preferred
way
implement
fsas
programs
tricky
part
finding
data
type
will
represent
range
tokens
will
time
acceptable
array
index
programming
language
scheme
example
handles
symbolic
names
easily
java
code
array
four
columns
labeled
35
127
33
'other'
cleanest
way
deal
routine
translate
token
category
tokens
corresponding
column
transition
table
effectively
switch
statement
sequence
statements
map
tokens
token
categories
range
0
3
think
task
extracting
words
stream
text
java
stringtokenizer
sometimes
need
specify
words
idiosyncratically
dvd
information
can
kind
input
parsing
task
much
easily
using
state
machines
writing
code
directly
1
draw
state
transition
diagram
accepts
words
defined
follows
sequence
non
separator
characters
whose
end
marked
separator
separators
symbols
separate
english
words
space
comma
semicolon
colon
note
hyphen
apostrophe
'
percent
sign
separators
treat
mother
law
23
single
words
end
line
separator
unless
last
word
line
ends
hyphen
way
word
like
mother
law
hyphenated
across
two
lines
will
still
count
one
word
will
assume
input
words
always
hyphenated
will
hyphenated
end
line
expect
normally
unhyphenated
words
broken
across
two
lines
watch
multiple
separators
row
example
comma
followed
space
two
separators
word
code
fsa
method
called
getnextword
call
parse
stream
input
coding
required
part
assignment
though
2
write
transition
table
state
machine
drew
part
1
now
time
think
finite
state
machines
dvd
information
fields
defined
sixth
homework
1
draw
state
transition
diagram
accepts
dvd
information
design
machine
accept
single
field
maybe
quoted
string
maybe
integer
maybe
date
go
back
initial
state
encounters
comma
quoted
course
makes
processing
quite
simple
long
willing
forego
checking
field
type
correct
number
fields
coding
easily
add
actions
transitions
maintain
field
count
might
also
help
assume
input
token
character
called
eos
end
string
character
reading
routine
return
machine
check
2
extra
credit
recode
dvd
parsing
program
implement
fsa
designed
part
optional
stop
subsequent
parts
homework
required
available
web
program
called
jflap
written
duke
university
http
www
cs
duke
edu
rodger
tools
jflaptmp
can
download
java
application
use
build
test
simple
fsas
well
formal
language
activities
state
machine
simulators
available
web
can
find
using
search
strings
like
state
machine
applet
fsa
animation
like
work
building
enhancing
tools
like
especially
allow
graphical
construction
useful
fsas
regular
expressions
transitions
come
talk
time
programming
language
lisp
whose
name
contraction
words
list
processing
invented
john
mccarthy
1958
advanced
language
time
existing
machines
run
efficiently
early
use
mostly
limited
researchers
artificial
intelligence
today
however
computers
thousands
times
faster
1950s
lisp's
power
practical
wide
range
programming
tasks
scheme
common
lisp
two
modern
members
lisp
family
programming
languages
one
scheme's
attractions
syntax
simple
unlike
java
dozen
different
statements
grammar
punctuation
rules
every
program
expression
scheme
just
list
words
surrounded
parentheses
provides
rich
variety
expression
word
can
sequence
characters
delimited
separated
words
white
space
parenthesized
list
words
nested
within
outside
list
following
valid
scheme
expressions
one
line
long
except
last
starts
word
define
fee
fie
fo
fum
3
14159
1776
45
quantity
equal
2
2
3
1
define
square
lambda
novice
scheme
programmers
sometimes
worry
keeping
parentheses
balanced
scheme
systems
syntax
based
text
editors
automatically
keep
track
parentheses
time
type
right
parenthesis
automatically
flashes
left
parenthesis
matches
way
can
see
effortlessly
matches
idea
found
way
program
editors
java
languages
also
useful
suppose
decide
write
syntax
based
editor
scheme
first
task
want
write
code
checks
whether
parentheses
balanced
scheme
expression
astutely
start
designing
fsa
make
truly
finite
state
machine
put
upper
limit
depth
parentheses
can
nested
example
shows
fsa
upper
limit
three
deep
nesting
diagram
means
input
symbol
open
close
parenthesis
1
scanning
entire
scheme
expression
state
machine
parentheses
correctly
balanced
2
fsa
works
fine
theory
realistic
nesting
depth
dozen
diagram
tediously
repetitious
decide
simplify
things
encapsulate
state
information
simple
integer
counter
can
single
state
page
action
happens
transition
steps
increment
counter
left
parenthesis
decrement
right
parenthesis
variable
may
appear
violate
definition
finite
state
machine
whose
information
encapsulated
finite
number
states
since
integer
variables
computers
opposed
integers
mathematics
always
finite
upper
bound
technically
safe
machine
used
stack
keep
track
unbalanced
parentheses
integer
counter
modeling
longer
fsa
pda
push
automaton
can
accept
broader
class
languages
modified
augmented
machine
appears
augmented
machine
stop
state
enough
know
scheme
program
balanced
parentheses
value
counter
must
considered
well
counter's
value
machine
accepts
scheme
source
parentheses
correctly
balanced
must
happened
machine
end
error
state
3
things
never
quite
simple
first
seem
comments
scheme
programs
start
semicolon
extend
end
line
thus
following
valid
scheme
expression
everything
right
semicolon
line
comment
course
contents
comments
ignored
checking
balanced
parentheses
define
print
routine
lambda
accept
parameter
display
display
newline
hit
carriage
return
draw
new
fsa
like
machine
similar
one
account
comments
correctly
will
add
states
4
one
wrinkle
literal
character
strings
scheme
enclosed
double
quote
marks
java
contents
literal
strings
ignored
analyzing
syntax
program
following
three
expressions
valid
scheme
display
oh
really
list
let
delims
extra
'
'
quotes
draw
new
fsa
like
machine
handle
strings
comments
correctly
5
write
transition
table
state
machine
designed
part
4
note
transitions
conditions
will
also
increment
decrement
count
parentheses
6
test
fsa
part
4
thoroughly
paper
devise
thorough
test
plan
work
test
fsa
grammar
set
rules
can
generate
strings
formal
language
right
form
grammar
programming
language
can
used
software
produce
automatically
part
compiler
language
grammar
backus
naur
form
bnf
notation
describes
arithmetic
expressions
expression
real
variable
expression
expression
operator
expression
variable
expression
real
positive
real
positive
real
positive
real
integer
part
integer
part
integer
part
integer
part
digit
digit
integer
part
variable
letter
digit
0
1
2
3
4
5
6
7
8
9
letter
operator
1
following
expressions
can
generated
grammar
others
can
indicate
valid
expressions
easiest
way
might
photocopy
page
print
line
version
circle
valid
expressions
2
using
grammar
generate
four
expressions
list
expression
involve
applying
least
ten
rules
expression
show
derivation
tree
expression
root
terminal
symbols
without
angle
brackets
leaves
3
give
three
arithmetic
expressions
syntactically
valid
java
generated
grammar
4
modify
grammar
allow
multi
letter
variable
names
requires
changing
one
existing
rules
write
regular
expressions
match
following
patterns
note
natural
language
descriptions
will
certainly
ambiguous
disambiguate
see
fit
note
decisions
made
cases
may
able
match
described
set
perfectly
obsess
comma
separated
dollars
cents
amounts
1
234
56
17
lines
empty
blanks
caret
matches
start
line
dollar
sign
matches
end
line
email
addresses
urls
html
anchor
tags
href
http
www
ics
uci
edu
kay
lines
containing
exactly
one
integer
perhaps
surrounded
non
numeric
characters
write
program
generates
random
sentences
according
user
supplied
grammar
specified
final
product
require
lot
code
require
careful
thoughtful
design
advance
may
assignment
pairs
member
pair
turn
identical
program
via
checkmate
source
code
file
comment
top
says
something
like
joint
work
carl
coder
petra
programmer
1
get
idea
assignment
can
trying
applet
http
www
cs
faculty
stanford
edu
zelenski
rsg
extension
request
grammar
default
pretty
funny
also
try
cs
assignment
programming
bug
math
expression
along
others
strike
fancy
2
follow
directory
collected
grammar
files
link
bottom
page
pick
grammars
chose
part
1
math
expression
easiest
follow
look
get
idea
program's
input
grammar
file
input
program
contains
one
rules
following
form
rule
starts
left
brace
line
ends
right
brace
line
opening
brace
first
line
rule
left
hand
side
non
terminal
string
delimited
angle
brackets
subsequent
lines
rule
alternative
productions
different
ways
rewriting
left
hand
side
production
consists
non
terminals
enclosed
angle
brackets
terminals
characters
combination
ending
semicolon
may
lines
text
outside
braces
delimit
rules
lines
ignored
program
thus
can
serve
comments
grammar
may
assume
grammar
files
take
form
check
errors
3
write
code
read
grammar
files
store
grammars
use
symbol
table
either
hash
table
bst
keyed
non
terminals
value
entry
table
contains
non
terminal's
alternative
productions
4
now
write
code
generate
sentences
grammar
grammar
contains
one
non
terminal
symbol
named
start
obviously
enough
start
symbol
derivation
program
expands
non
terminal
chooses
random
one
non
terminal's
alternative
productions
recursively
every
non
terminal
expanded
may
assume
every
non
terminal
grammar
will
appear
left
side
exactly
one
rule
check
undefined
multiply
defined
non
terminals
though
bit
extra
credit
may
check
handle
issues
missing
start
symbol
output
include
hierarchical
description
derivation
process
well
final
sentence
shown
following
example
simple
grammar
output
showing
final
generated
sentence
bottom
first
level
indentation
shows
first
production
taken
second
level
shows
expansion
cool
start
really
cool
really
cool
5
design
build
interface
simplest
console
interface
prompts
user
name
grammar
file
generates
sentence
grammar
enhancements
include
letting
user
request
new
sentences
repeatedly
specify
new
grammar
file
building
applet
gui
application
another
alternative
6
make
grammar
tiny
subset
java
see
kinds
programs
generates
copy
random
program
output
java
environment
like
drjava
run
get
automatically
formatted
make
readable
7
make
least
one
grammar
choice
generate
sentences
8
last
day
class
bring
printed
copy
best
cleverest
funniest
grammar
sentences
generates
can
share
anonymously
like
gui
may
built
extra
credit
suggested
sixth
homework
due
time
assignment
due
turn
parts
involve
many
diagrams
tables
will
probably
find
easiest
produce
submit
work
paper
clearly
marked
name
course
turn
section
checkmate
will
accept
word
document
parts
please
use
checkmate
parts
everything
including
diagrams
included
electronic
copy
course
may
use
word
produce
printed
copy
onto
draw
answers
hand
need
everything
one
place
split
checkmate
paper
part
turn
via
checkmate
java
code
grammar
partial
java
grammars
designed
fsa
exercises
written
david
kay
winter
1991
based
materials
1990
earlier
revised
joe
hummel
norman
jacobson
theresa
millette
brian
pitterle
alex
thornton
rasheed
baqai
li
wei
gary
chen
david
kay
1992
1999
revised
include
bnf
grammars
david
kay
spring
1999
revised
consolidated
david
kay
winter
2000
revised
add
dvd
information
winter
2003
random
sentence
generator
original
concept
mike
cleron
stanford
university
modified
allison
hansen
julie
zelenski
others
revised
adapted
david
kay
winter
2000
winter
2003
