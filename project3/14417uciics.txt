decentralized software evolution 
decentralized software evolution 
back
peyman
oreizy's
home
page
appeared
proceedings
international
conference
principles
software
evolution
iwpse
1
kyoto
japan
april
20
21
1998
decentralized
software
evolution
peyman
oreizy
http
www
ics
uci
edu
peymano
information
computer
science
university
california
irvine
irvine
ca
92697
3425
usa
1
949
824
8438
peymano
ics
uci
edu
introduction
developers
frequently
confront
dilemma
may
characterized
following
``90
functionality
requested
customer
available
existing
shelf
application
missing
10
vital
customer
unfortunately
customize
adapt
existing
application
meet
customer's
needs
choice
buid
custom
solution
scratch
''
result
relatively
small
change
functionality
necessitates
disproportionately
large
amount
effort
curtails
opportunity
software
reuse
undesirable
outcome
may
avoided
shelf
application
supported
decentralized
software
evolution
define
ability
evolve
software
independent
original
software
vendor
decentralized
software
evolution
hereafter
abbreviated
dse
provides
means
third
party
software
vendors
customize
existing
applications
particular
domains
customers
capability
benefits
everyone
involved
original
application
vendor
sells
product
since
customization
constitutes
use
third
party
developer
delivers
product
less
time
lower
cost
reusing
software
instead
starting
scratch
customer
receives
higher
quality
product
less
time
lower
cost
although
reliable
rapid
cost
effective
software
evolution
principal
concern
software
research
since
1970's
results
date
directly
address
dse
principles
techniques
software
evolution
anticipation
change
separation
concerns
modularity
information
hiding
13
object
oriented
design
2
mediator
based
design
17
adaptive
object
oriented
design
10
design
patterns
7
aspect
oriented
design
9
etc
help
design
evolvable
software
systems
unfortunately
flexibility
attained
using
techniques
lost
application
compiled
use
compilation
process
solidifies
plasticity
design
making
exceedingly
difficult
accommodate
change
otherwise
easy
make
objective
dse
preserve
design's
plasticity
deployed
system
thereby
enabling
third
party
evolution
rest
paper
organized
follows
section
2
characterizes
dse
within
broader
context
software
evolution
section
3
surveys
existing
techniques
supporting
dse
section
4
presents
approach
dse
section
5
summarizes
experience
applying
approach
several
example
applications
section
6
discusses
open
issues
software
evolution
table
1
categorizes
common
software
evolution
technologies
based
can
applied
software
can
either
evolved
centralized
authority
software
vendor
top
row
decentralized
group
multiple
independent
software
vendors
bottom
row
software
can
also
evolved
design
phase
left
column
deployed
customers
right
column
design
time
evolutionpost
deployment
evolutionwhocentralized
authority
design
notations
methods
tools
process
systems
group
communication
collaboration
tools
configuration
management
tools
release
management
systems
software
patch
files
decentralized
group
emphasis
distributed
development
software
plug
ins
scripting
languages
developer
apis
table
1
2x2
matrix
categorizes
different
techniques
used
support
software
evolution
based
can
evolve
system
evolution
can
take
place
centralized
design
time
evolution
large
majority
available
techniques
tools
support
category
software
evolution
example
design
notations
methods
booch
rumbaugh
object
oriented
methodologies
provide
guidelines
system
design
diagrammatic
notations
design
capture
design
tools
rational
rose
automate
diagramming
process
provide
analysis
support
group
communication
collaboration
tools
mail
revision
control
tools
configuration
management
systems
help
teams
members
coordinate
manage
software
changes
decentralized
design
time
evolutionlarger
teams
geographic
distribution
differentiate
decentralized
design
time
evolution
centralized
counterpart
impact
large
teams
software
engineering
environments
discussed
perry
kaiser
14
argue
project
grows
approximately
20
people
number
complexity
interactions
increases
consequence
additional
rules
mechanisms
enforce
cooperation
among
personnel
needed
less
well
understood
impact
geographic
distribution
software
development
fielding
kaiser
5
describe
processes
tools
adopted
one
particular
globally
distributed
team
develops
apache
web
server
identify
importance
mail
communication
archival
mail
communication
means
support
group
memory
shared
information
space
accessible
project
members
coordination
tools
cutkosky
et
al
4
report
similar
experiences
using
internet
manufacturing
domain
centralized
post
deployment
evolutionsoftware
vendors
evolving
upgrading
deployed
applications
represented
category
since
evolution
done
single
authority
change
conflicts
arise
result
technologies
concerned
efficient
distribution
upgrades
common
technology
use
today
binary
patch
file
encodes
byte
level
changes
necessary
upgrade
application
subsequent
release
sophisticated
tools
tivoli's
tme
10
20
softwaredock
8
use
software
dependency
information
guide
software
upgrades
decentralized
post
deployment
evolutionmultiple
software
vendors
independently
evolving
deployed
application
represented
category
popular
techniques
include
software
plug
ins
used
netscape's
communicator
support
new
content
types
scripting
languages
host
issues
consequences
inherent
supporting
type
evolution
example
configuration
management
becomes
necessary
conflicts
independently
developed
software
add
ons
can
occur
since
applications
evolved
field
anomalies
may
arise
unforeseen
interactions
independently
developed
add
ons
consequentially
application
consistency
must
verified
whenever
application
modified
add
ons
installed
removed
software
add
vendors
must
also
use
standard
formats
packaging
distributing
add
ons
furthermore
decentralized
control
software
evolution
complicates
product
support
documentation
since
single
authority
represents
application
evolved
multiple
vendors
end
user
installation
software
add
ons
necessitates
configuration
management
analysis
robust
accessible
non
technical
users
focus
class
evolution
remainder
paper
existing
techniques
supporting
decentralized
software
evolution
degree
flexibility
afforded
different
approaches
dse
depicted
figure
1
figure
1
trade
flexibility
left
application
consistency
right
made
different
decentralized
software
evolution
mechanisms
extreme
left
spectrum
software
vendor
deploys
application's
source
code
enabling
anyone
sufficient
expertise
modify
aspect
application's
functionality
although
rare
commercial
software
market
numerous
free
ware
applications
adopt
approach
including
linux
os
apache
web
server
gnu
tools
gcc
emacs
netscape's
communicator
among
first
commercial
products
distribute
source
code
independent
extension
although
types
changes
can
made
unrestricted
extremely
difficult
combine
independently
developed
add
ons
determining
whether
two
changes
conflict
requires
careful
analysis
source
code
automated
problem
analogous
merging
several
branches
software
revision
tree
software
configuration
management
system
extreme
right
spectrum
software
vendor
deploys
application
monolithic
entity
fixed
set
user
selection
options
large
majority
commercial
software
applications
adopt
approach
1
application
consistency
may
assured
since
single
software
vendor
exclusive
control
evolution
2
software
vendor
can
protect
intellectual
property
rights
making
extraordinarily
difficult
others
reverse
engineer
application
applications
two
extremes
support
form
software
evolution
trading
assured
consistency
right
end
flexibility
left
end
systems
enable
end
users
third
party
software
vendors
customize
extend
application's
functionality
independent
original
application
vendor
relatively
small
growing
number
software
applications
lay
two
extremes
examples
include
microsoft's
office
suite
adobe
photoshop
qualcomm's
eudora
common
techniques
supporting
dse
briefly
described
application
programming
interfaces
apis
api
set
functions
application
provides
applications
apis
commonly
used
tool
integration
mechanisms
since
enable
applications
invoke
services
host
application
without
user
involvement
apis
provide
limited
subset
operations
necessary
support
evolution
example
api
based
software
add
ons
replace
remove
existing
functionality
interpose
new
functionality
existing
parts
consequence
host
application's
predetermined
api
circumscribes
class
possible
changes
software
plug
insthe
plug
mechanism
provides
place
holder
third
party
components
host
application
specifies
requirements
functional
interface
plug
ins
must
adhere
provides
mechanism
new
plug
ins
register
host
netscape's
communicator
example
registers
plug
ins
placing
special
file
system
directory
queried
startup
host
application
selects
among
plug
ins
invokes
necessary
plug
based
software
add
ons
can
provide
alternative
implementations
behaviors
anticipated
original
developers
interposition
removal
functionality
supported
since
dependency
information
plug
ins
determined
scripting
languages
macrosa
scripting
language
provides
domain
specific
language
specifying
behavior
using
language
primitives
library
functions
scripting
language
based
mechanisms
provide
essentially
flexibility
api
mechanism
except
scripting
language
provides
domain
specific
language
constructs
can
facilitate
implementation
add
ons
built
compiler
interpreter
lower
entry
barrier
developing
add
ons
dynamic
link
libraries
dlls
dynamic
link
libraries
provide
late
binding
mechanism
whereby
application
can
load
link
external
software
module
runtime
applications
employ
dlls
reduce
runtime
memory
use
share
common
functionality
software
add
can
augment
replace
remove
functionality
masquerading
application
dll
replacing
file
representing
dll
file
system
balzer's
instrumented
connector
technology
1
use
technique
alter
netscape's
communicator
browser
support
browsing
virtual
encrypted
file
systems
although
dll
based
software
add
ons
unique
can
used
evolve
application
manner
unanticipated
developers
two
limitations
one
dll
add
ons
can
use
place
existing
dlls
circumscribes
class
changes
two
unexpected
side
effects
may
result
add
dll
violates
unstated
assumption
application
dll
component
based
applicationscomponent
based
applications
built
using
component
object
model
com
3
corba
11
applications
composed
separately
compiled
modules
called
components
linked
one
another
runtime
since
application
component
exposes
interface
component
based
applications
expose
richer
structured
api
increasing
potential
supporting
unanticipated
changes
since
existing
technologies
try
separation
application
functionality
component
communication
components
tend
riddled
hard
coded
references
components
makes
component
replacement
removal
interposition
behavior
difficult
techniques
except
source
code
generally
preserve
small
portion
design's
flexibility
deployed
system
restrict
set
potential
changes
precludes
changes
unanticipated
original
developers
composition
software
add
ons
also
poorly
supported
existing
techniques
existing
techniques
circumvent
composition
problem
preventing
interaction
add
ons
indeed
approach
advocated
szyperski
18
approach
approach
decentralized
post
deployment
software
evolution
overcomes
many
limitations
exhibited
previous
approaches
approach
based
evolving
applications
software
architectural
level
15
16
approach
dse
unique
following
ways
augment
abstractions
provided
architectural
level
stylist
rules
facilitate
dse
require
components
communicate
connectors
preserved
explicit
entities
implementation
act
communication
routers
furthermore
connectors
encapsulate
localize
binding
decisions
components
makes
possible
change
binding
decisions
without
altering
components
include
application's
architectural
model
mechanism
maintain
consistency
model
implementation
deployed
system
deployed
architectural
model
describes
interconnections
components
connectors
mappings
implementation
modules
mapping
enables
changes
specified
terms
architectural
model
effect
corresponding
changes
implementation
deploy
architecture
evolution
manager
aem
application
aem
maintains
correspondence
architectural
model
implementation
changes
made
change
violates
application
consistency
aem
can
reject
change
approach
enables
software
add
ons
leverage
architectural
model's
rich
semantics
guide
changes
avoids
many
accidental
difficulties
incurred
existing
approaches
since
application's
entire
architecture
exposed
remains
malleable
deployed
system
design's
plasticity
preserved
made
accessibly
third
party
add
vendors
overcomes
limited
scope
change
exhibited
existing
approaches
software
add
ons
can
inspect
modify
system's
architectural
model
order
achieve
necessary
semantics
example
greatly
simplifies
problem
interposing
new
component
two
existing
components
since
architectural
model
can
queried
locate
affected
components
connectors
independently
developed
software
add
ons
installed
removed
architectural
model
can
analyzed
detect
inconsistencies
availability
architectural
model
can
also
used
detect
conflicts
independently
developed
add
ons
results
date
implemented
prototype
tool
suite
called
archstudio
implements
approach
applications
implemented
c2
architectural
style
19
archstudio's
conceptual
architecture
depicted
briefly
described
figure
2
figure
2
conceptual
architecture
archstudio
tool
suite
software
add
ons
evolve
application
inspecting
changing
architectural
model
changes
may
include
addition
removal
replacement
components
connectors
changes
configuration
components
connectors
architecture
evolution
manager
notified
changes
opportunity
revoke
changes
violate
system
integrity
architecture
evolution
manager
may
utilize
external
analysis
tools
determine
changes
acceptable
lower
portion
archstudio
deployed
application
user
downloads
new
software
add
using
web
browser
add
installation
script
located
executed
used
archstudio
implement
two
applications
several
add
ons
details
regarding
archstudio
sample
application
implemented
using
described
12
implemented
simple
end
user
tool
installing
removing
software
add
ons
called
extension
wizard
also
deployed
application
end
users
use
web
browser
display
list
downloadable
software
add
ons
provided
software
vendor
web
site
user
selects
file
representing
add
web
browser
downloads
file
invokes
extension
wizard
software
add
file
compressed
archive
containing
new
implementation
modules
installation
script
extension
wizard
uncompresses
file
locates
installation
script
contains
executes
software
add
on's
installation
script
may
query
modify
architectural
model
necessary
installation
script
exception
aem
detects
violation
application
invariants
installation
succeeds
extension
wizard
notifies
end
user
provides
option
un
install
add
conclusions
results
date
encouraging
several
difficult
issues
remain
general
framework
ensuring
application
consistency
needed
current
architecture
evolution
manager
enforces
c2
style
rules
guarantee
changes
will
leave
application
consistent
state
aspects
style
facilitate
type
field
analysis
currently
investigating
suitability
graph
grammars
architectural
constraints
event
based
resource
models
representing
application
invariants
techniques
hope
address
software
compositionality
new
techniques
needed
address
problems
``composing''
documentation
product
support
decentralized
environment
references
balzer
instrumenting
monitoring
debugging
software
architectures
http
www
isi
edu
software
sciences
papers
instrumenting
software
architectures
doc
january
28
1998
booch
object
oriented
analysis
design
second
edition
benjamin
cummings
publishing
company
inc
1994
brockschmidt
inside
ole
2
microsoft
press
1994
cutkosky
tenenbaum
glicksman
madefast
collaborative
engineering
internet
communications
acm
vol
39
9
september
1996
fielding
kaiser
apache
http
server
project
ieee
internet
computing
july
august
1997
free
software
foundation
categories
free
non
free
software
http
www
gnu
org
philosophy
categories
html
january
28
1998
gamma
helm
johnson
vlissides
design
patterns
addison
wesley
1995
hall
heimbigner
van
der
hoek
wolf
architecture
post
development
configuration
management
wide
area
network
17th
international
conference
distributed
computing
systems
baltimore
maryland
may
1997
kiczales
lamping
mendhekar
maeda
lopes
loingtier
irwin
aspect
oriented
programming
parc
technical
report
spl97
008
p9710042
february
1997
lieberherr
adaptive
object
oriented
software
demeter
method
pws
publishing
company
1996
object
management
group
common
object
request
broker
architecture
specification
revision
2
0
july
1996
http
www
omg
org
corba
corbiiop
htmp
oreizy
medvidovic
taylor
architecture
based
runtime
software
evolution
appear
international
conference
software
engineering
1998
kyoto
japan
april
1998
parnas
criteria
used
decomposing
systems
modules
communications
acm
vol
15
12
december
1972
perry
kaiser
models
software
development
environments
ieee
transactions
software
engineering
vol
17
3
pp
283
295
march
1991
perry
wolf
foundations
study
software
architecture
software
engineering
notes
vol
17
4
october
1992
shaw
garlan
software
architecture
perspectives
emerging
discipline
prentice
hall
1996
sullivan
notkin
reconciling
environment
integration
software
evolution
acm
transactions
software
engineering
methodology
vol
1
3
july
1992
szyperski
independently
extensible
systems
software
engineering
potential
challenges
proceedings
19th
australasian
computer
science
conference
melbourne
australia
january
31
february
2
1996
taylor
medvidovic
anderson
whitehead
robbins
nies
oreizy
dubrow
component
message
based
architectural
style
gui
software
ieee
transactions
software
engineering
june
1996
tivoli
systems
inc
applications
management
specification
http
www
tivoli
com
wirth
program
development
stepwise
refinement
communications
acm
vol
14
4
april
1971
