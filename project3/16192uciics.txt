np completeness 
np completeness 
ics
161
design
analysis
algorithms
lecture
notes
march
12
1996
np
completeness
far
seen
lot
good
news
problem
can
solved
quickly
close
linear
time
least
time
small
polynomial
function
input
size
np
completeness
form
bad
news
evidence
many
important
problems
solved
quickly
care
np
complete
problems
really
come
time
knowing
hard
lets
stop
beating
head
wall
trying
solve
something
better
use
heuristic
quickly
solve
problem
good
worst
case
time
maybe
can
come
method
solving
reasonable
fraction
common
cases
solve
problem
approximately
instead
exactly
lot
time
possible
come
provably
fast
algorithm
solve
problem
exactly
comes
solution
can
prove
close
right
use
exponential
time
solution
anyway
really
solve
problem
exactly
can
settle
writing
exponential
time
algorithm
stop
worrying
finding
better
solution
choose
better
abstraction
np
complete
abstract
problem
trying
solve
presumably
comes
ignoring
seemingly
unimportant
details
complicated
real
world
problem
perhaps
details
ignored
make
difference
can
solve
classification
problems
subject
computational
complexity
theory
dedicated
classifying
problems
hard
many
different
classifications
common
useful
following
one
technical
point
really
defined
terms
yes
problems
certain
structure
exist
rather
find
structure
problems
can
solved
polynomial
time
stands
polynomial
problems
formed
main
material
course
np
stands
nondeterministic
polynomial
time
nondeterministic
just
fancy
way
talking
guessing
solution
problem
np
can
quickly
polynomial
time
test
whether
solution
correct
without
worrying
hard
might
find
solution
problems
np
still
relatively
easy
guess
right
solution
quickly
test
np
stand
non
polynomial
many
complexity
classes
much
harder
np
pspace
problems
can
solved
using
reasonable
amount
memory
defined
formally
polynomial
input
size
without
regard
much
time
solution
takes
exptime
problems
can
solved
exponential
time
class
contains
problems
likely
run
including
everything
previous
three
classes
may
surprising
class
inclusive
problems
best
algorithms
take
even
exponential
time
undecidable
problems
can
prove
algorithm
always
solves
matter
much
time
space
allowed
one
uninformative
proof
based
fact
many
problems
real
numbers
many
programs
integers
enough
programs
solve
problems
can
also
define
explicit
useful
problems
solved
although
defined
theoretically
many
classes
practical
implications
instance
good
approximation
class
problems
can
solved
quickly
practice
usually
true
can
prove
polynomial
worst
case
time
bound
conversely
polynomial
time
bounds
can
prove
usually
small
enough
corresponding
algorithms
really
practical
np
completeness
theory
concerned
distinction
first
two
classes
np
examples
problems
different
classes
example
1
long
simple
paths
simple
path
graph
just
one
without
repeated
edges
vertices
describe
problem
finding
long
paths
terms
complexity
theory
need
formalize
yes
question
given
graph
vertices
number
exist
simple
path
least
edges
solution
problem
consist
path
np
given
path
can
quickly
look
add
length
double
checking
really
path
length
least
can
done
linear
time
certainly
can
done
polynomial
time
however
know
whether
problem
told
good
way
finding
path
time
polynomial
fact
problem
np
complete
believe
algorithm
exists
algorithms
solve
problem
instance
list
2
subsets
edges
check
whether
solves
problem
far
know
algorithm
runs
polynomial
time
example
2
cryptography
suppose
encryption
function
code
rsa
key
text
rsa
encryption
works
performing
simple
integer
arithmetic
code
key
consists
pair
large
prime
numbers
one
can
perform
encryption
knowing
product
pq
decrypt
code
instead
need
know
different
product
1
1
standard
assumption
cryptography
known
plaintext
attack
code
message
know
can
guess
text
message
want
use
information
discover
key
can
decrypt
messages
sent
using
key
formalized
np
problem
simply
want
find
key
code
rsa
key
text
given
key
can
test
encryption
np
hard
question
find
key
code
strong
hope
possible
much
better
brute
force
search
another
common
use
rsa
involves
public
key
cryptography
user
system
publishes
product
pq
publish
1
1
way
anyone
can
send
message
user
using
rsa
encryption
user
can
decrypt
breaking
scheme
can
also
thought
different
np
problem
given
composite
number
pq
find
factorization
smaller
numbers
one
can
test
factorization
quickly
just
multiply
factors
back
together
problem
np
finding
factorization
seems
difficult
think
may
however
strong
evidence
np
complete
either
seems
one
rare
examples
problems
np
complete
difficulty
example
3
chess
seen
news
recently
match
world
chess
champion
gary
kasparov
fast
chess
computer
deep
blue
computer
lost
match
won
one
game
tied
others
involved
chess
programming
essentially
sequences
possible
moves
form
tree
first
player
choice
20
different
moves
good
second
player
choice
many
responses
chess
playing
programs
work
traversing
tree
finding
possible
consequences
different
move
tree
moves
deep
typical
chess
game
might
last
40
moves
rare
one
reach
200
moves
since
move
involves
step
player
400
positions
involved
games
traversed
tree
chess
positions
depth
need
enough
memory
store
400
positions
single
path
time
much
memory
easily
available
smallest
computers
likely
use
perfect
chess
playing
problem
pspace
actually
one
must
careful
definitions
finite
number
positions
chess
principle
write
solution
constant
time
constant
large
generalized
versions
chess
larger
boards
pspace
reason
deep
game
tree
search
method
used
practice
tree
moves
bushy
even
though
deep
enormous
number
vertices
run
space
try
traverse
will
run
time
get
even
small
fraction
way
pruning
methods
notably
alpha
beta
search
can
help
reduce
portion
tree
needs
examined
enough
solve
difficulty
reason
actual
chess
programs
instead
search
much
smaller
depth
7
moves
point
enough
information
evaluate
true
consequences
moves
forced
guess
using
heuristic
evaluation
functions
measure
simple
quantities
total
number
pieces
left
example
4
knots
give
three
dimensional
polygon
sequence
vertex
coordinate
triples
way
twisting
bending
polygon
around
becomes
flat
knotted
algorithm
solving
problem
complicated
really
adequately
analyzed
however
runs
least
exponential
time
one
way
proving
certain
polygons
knots
find
collection
triangles
forming
surface
polygon
boundary
however
always
possible
without
adding
exponentially
many
new
vertices
even
possible
np
complete
find
triangles
also
heuristics
based
finding
non
euclidean
geometry
space
outside
knot
work
well
many
knots
known
work
knots
one
rare
examples
problem
can
often
solved
efficiently
practice
even
though
theoretically
known
certain
related
problems
higher
dimensions
four
dimensional
surface
equivalent
four
dimensional
sphere
provably
undecidable
example
5
halting
problem
suppose
working
lab
programming
class
written
program
start
run
five
minutes
still
going
mean
infinite
loop
just
slow
convenient
compiler
tell
program
infinite
loop
however
undecidable
problem
program
will
always
correctly
detect
infinite
loops
people
used
idea
evidence
people
inherently
smarter
computers
since
shows
problems
computers
solve
however
clear
people
can
solve
either
example
main
int
3
int
1
int
1
int
1
int
3
pow
pow
pow
exit
program
searches
solutions
fermat's
last
theorem
halt
can
assume
using
multiple
precision
integer
package
instead
built
integers
worry
arithmetic
overflow
complications
able
answer
understand
recent
proof
fermat's
last
theorem
many
similar
problems
proof
known
clueless
whether
corresponding
programs
halt
problems
complexity
theory
famous
open
problem
theoretical
science
whether
np
words
always
easy
check
solution
also
easy
find
solution
reason
believe
true
expectation
among
theoreticians
false
also
proof
nice
construction
complexity
classes
np
even
say
one
problem
np
good
theory
tell
us
hard
particular
problem
solve
np
completeness
theory
np
completeness
solution
practical
problem
applying
complexity
theory
individual
problems
np
complete
problems
defined
precise
sense
hardest
problems
even
though
know
whether
problem
np
can
point
np
complete
problem
say
hard
problems
np
problems
one
hard
ones
conversely
everything
np
easy
problems
easy
np
completeness
can
thought
way
making
big
np
question
equivalent
smaller
questions
hardness
individual
problems
believe
np
unequal
prove
problem
np
complete
believe
fast
algorithm
unknown
reasons
problems
looked
np
turn
either
np
complete
theory
np
completeness
turns
good
way
showing
problem
likely
hard
applies
lot
problems
problems
np
known
likely
np
complete
instance
code
breaking
example
gave
earlier
reduction
formally
np
completeness
defined
terms
reduction
just
complicated
way
saying
one
problem
easier
another
say
easier
write
can
write
algorithm
solving
uses
small
number
calls
subroutine
everything
outside
subroutine
calls
fast
polynomial
time
several
minor
variations
definition
depending
detailed
meaning
small
may
polynomial
number
calls
fixed
constant
number
just
one
call
can
write
polynomial
algorithm
expanding
subroutine
calls
use
fast
algorithm
easier
context
means
one
problem
can
solved
polynomial
time
can
possible
algorithms
slower
even
though
example
consider
hamiltonian
cycle
problem
given
graph
cycle
visiting
vertex
exactly
solution
using
longest
path
subroutine
edge
simple
path
length
1
return
yes
path
edge
form
cycle
return
algorithm
makes
calls
longest
path
subroutine
work
outside
subroutine
calls
shows
hamiltonian
cycle
longest
path
show
hamiltonian
cycle
know
solve
longest
path
subproblems
quickly
second
example
consider
polynomial
time
problem
minimum
spanning
tree
every
problem
minimum
spanning
tree
since
fast
algorithm
minimum
spanning
trees
using
subroutine
actually
call
subroutine
can
call
ignore
results
cook's
theorem
now
ready
formally
define
np
completeness
say
problem
np
np
complete
every
problem
np
seems
like
strong
definition
notion
reduction
defined
seems
imply
two
problems
closely
related
instance
hamiltonian
cycle
longest
path
finding
similar
structures
graphs
problem
closely
related
different
problems
np
theorem
np
complete
problem
exists
prove
example
one
np
complete
problem
can
found
modifying
halting
problem
without
modification
undecidable
bounded
halting
problem
takes
input
program
number
problem
find
data
given
input
causes
stop
steps
precise
needs
careful
definition
language
written
constitutes
single
step
also
technical
reasons
specified
unary
notation
length
part
input
rather
log
reasonable
ways
filling
details
np
test
data
correct
solution
just
simulate
program
steps
takes
time
polynomial
length
program
one
point
need
careful
program
can
perform
unreasonable
operations
arithmetic
large
integers
able
simulate
quickly
enough
finish
proof
np
complete
need
show
harder
anything
else
np
suppose
problem
np
means
can
write
program
pa
tests
solutions
halts
within
polynomial
time
yes
answer
depending
whether
given
solution
really
solution
given
problem
can
easily
form
modified
program
pa'
enter
infinite
loop
whenever
halt
answer
solve
bounded
halting
solve
passing
pa'
arguments
subroutine
bounded
halting
bounded
halting
argument
works
every
problem
np
bounded
halting
np
complete
prove
np
completeness
practice
proof
np
completeness
bounded
halting
great
theory
np
completeness
help
us
understand
abstract
problems
hamiltonian
cycle
problem
proofs
np
completeness
look
like
one
difficult
prove
anything
else
way
instead
based
observation
recall
relations
defined
terms
existence
algorithm
calls
subroutines
given
algorithm
solves
subroutine
algorithm
solves
subroutine
can
just
use
second
algorithm
expand
subroutine
calls
first
algorithm
get
algorithm
solves
subroutine
consequence
observation
np
complete
np
np
complete
practice
prove
np
completeness
start
one
specific
problem
prove
np
complete
prove
easier
lots
others
must
therefore
also
np
complete
since
hamiltonian
cycle
known
np
complete
hamiltonian
cycle
longest
path
can
deduce
longest
path
also
np
complete
starting
bounded
halting
problem
can
show
reducible
problem
simulating
circuits
know
computers
can
built
circuits
problem
involving
simulating
computers
can
translated
one
simulating
circuits
various
circuit
simulation
problems
np
complete
particular
satisfiability
asks
whether
input
boolean
circuit
causes
output
one
circuits
look
lot
like
graphs
another
easy
step
proving
many
graph
problems
np
complete
proofs
rely
constructing
gadgets
small
subgraphs
act
context
graph
problem
consideration
like
boolean
gates
components
circuits
many
problems
already
known
np
complete
listed
bible
subject
computers
intractibility
guide
theory
np
completeness
michael
garey
david
johnson
freeman
1979
suspect
problem
looking
np
complete
first
step
look
garey
johnson
second
step
find
similar
problem
can
garey
johnson
prove
reduction
showing
similar
problem
easier
one
want
solve
neither
works
always
go
back
methods
described
rest
class
try
find
efficient
algorithm
ics
161
dept
information
computer
science
uc
irvine
last
update
02
may
2000
20
17
39
pdt
