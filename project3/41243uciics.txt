asst 1 scheme introduction 
scheme introduction 
assignments
ics
141
course
teaches
new
concepts
also
new
ways
thinking
learning
think
new
ways
usually
requires
practice
actually
new
things
times
homeworks
opportunity
get
practice
just
say
let
just
get
answer
turn
learn
later
keep
working
instructor
tas
classmates
can
produce
answers
without
help
secret
problems
assign
quarter
assigned
last
quarter
entirely
possible
find
answers
someone
took
course
just
copy
turn
besides
academically
dishonest
also
prepare
similar
problems
exams
course
grade
will
suffer
give
assignments
time
attention
require
enjoy
stretching
mental
muscles
due
date
assignment
due
monday
january
24
3
00
pm
deposit
assignment
locking
drop
box
room
cs
189
due
date
closer
seems
sure
get
started
week
can
ask
questions
discussion
friday
summary
assignment
will
become
acquainted
running
scheme
interpreter
basic
patterns
recursive
list
processing
code
scheme
problems
will
seem
familiar
took
ics
22
apologize
repetition
work
back
will
pay
now
part
readings
review
questions
chapter
sebesta
ends
two
sets
exercises
one
called
review
questions
one
called
problem
set
set
numbered
starting
1
careful
verify
set
asking
assignment
know
answers
review
questions
listed
turn
list
help
identify
important
concepts
text
hand
infer
topics
skip
omit
entirely
unimportant
chapter
1
1
11
13
15
17
19
25
27
32
come
back
questions
end
course
review
final
chapter
2
8
14
17
21
26
30
35
38
42
43
46
chapter
14
1
4
6
9
14
part
ii
chapter
2
sebesta
answer
one
two
brief
sentences
following
questions
problem
set
page
104
6
7
8
9
14
note
questions
problem
set
review
questions
feel
free
try
exercises
assign
get
stuck
ask
us
spending
much
time
problem
address
issues
will
important
us
part
iii
cover
scheme
ics
141
two
main
reasons
illustrate
concepts
functional
programming
including
higher
order
functions
give
experience
learning
new
language
significantly
different
already
know
learning
think
new
way
easy
frustration
inevitable
stretch
mind
new
directions
middle
school
high
school
students
learn
material
see
www
schemers
com
www
cs
rice
edu
cs
plt
teaching
can
scheme
language
details
writing
textbooks
hard
work
maybe
can
forgive
sebesta
missing
details
current
status
scheme
language
standard
two
boolean
constants
nil
longer
used
empty
list
counts
false
bad
programming
practice
use
way
many
scheme
implementations
allow
first
rest
place
historically
interesting
hopelessly
non
mnemonic
car
cdr
can
just
say
define
first
car
define
rest
cdr
scheme
implementations
allow
curly
braces
square
brackets
instead
parentheses
visual
aid
matching
pairs
standard
just
use
parentheses
let
environment
matching
two
equivalent
styles
defining
functions
call
prototype
form
lambda
form
sebesta
uses
prototype
form
shorter
illustrates
call
might
look
like
define
cube
prefer
lambda
form
hide
underlying
lambda
expression
consistent
form
uses
define
define
cube
lambda
scheme
implementations
nt
machines
labs
implementation
scheme
called
edscheme
use
home
can
download
limited
time
version
edscheme
free
www
schemers
com
can
also
purchase
copy
50
see
us
details
also
recommend
drscheme
another
implementation
rice
university
available
entirely
free
every
platform
www
cs
rice
edu
cs
plt
packages
drscheme
problems
problems
ask
print
transcript
window
showing
interaction
scheme
interpreter
probably
want
produce
separate
transcript
turning
rather
printing
pages
pages
showing
experimentation
worry
transcript
contains
typos
get
used
scheme
environment
try
expressions
like
123
456
expt
2
100
3
14159265
2
type
definitions
symbols
global
environment
like
define
pi
3
14159265
try
pi
2
type
function
definition
like
one
define
fact
compute
factorial
lambda
0
1
definition
cond
extra
horizontal
space
0
1
needed
just
lines
else
fact
1
cond
clause
parts
notice
environment
indents
highlights
blocks
code
get
parentheses
confused
make
sure
know
save
code
file
load
file
scheme
evaluation
edscheme
automatically
re
evaluate
changes
make
code
visual
recompile
try
compound
expressions
like
gcd
fact
100
expt
2
1000
fact
fact
5
first
rest
'
huey
dewey
louie
value
produced
fact
5
expt
7
2
result
called
exact
representation
looks
unusual
us
useful
calculations
nothing
lost
rounding
decimal
representation
hand
evaluate
output
fixed
point
fact
5
expt
7
2
15
10
15
total
size
characters
result
10
number
digits
right
decimal
point
code
output
fixed
point
available
masterhit
nt
lab
server
happens
evaluate
fact
fact
500
play
around
edscheme
trying
expressions
experiment
list
operators
cons
first
rest
list
append
null
comfortable
work
can
look
online
help
available
help
menu
question
mark
button
information
understand
function
sure
understand
kinds
data
expects
arguments
atoms
lists
numbers
kind
data
returns
function
cons
example
takes
expression
first
argument
list
second
argument
returns
list
turn
anything
part
iii
lab
course
short
change
time
spend
building
familiarity
much
trouble
later
function
called
ackerman's
function
grows
really
fast
define
lambda
cond
0
1
0
1
1
else
1
1
1
type
try
small
arguments
print
transcript
window
showing
print
results
show
pages
pages
solid
digits
2
rewrite
ackerman's
function
paper
using
standard
mathematical
notation
longest
number
can
generate
scheme
using
without
running
memory
taking
60
seconds
processor
time
generating
big
numbers
one
part
question
counting
digits
another
1
try
using
string
length
number
string
big
number
2
try
approximate
using
log
base
10
3
try
using
tool
scheme
programming
language
4
using
wristwatch
slow
measured
counting
time
long
takes
scheme
calculate
display
big
number
now
time
long
takes
calculate
big
number
length
nesting
expression
generate
big
number
inside
length
calculating
expression
part
1
2
expect
second
take
longer
scheme
systems
system
might
generate
calculate
length
task
take
less
time
5
type
answers
questions
print
transcript
showing
print
page
two
solid
digits
write
following
functions
scheme
pay
attention
type
value
returned
list
single
item
number
boolean
new
recursive
thinking
will
take
start
seeing
patterns
many
exercises
even
many
may
enough
go
back
read
course
reference
sheet
says
collaboration
good
work
classmates
remember
goal
able
write
routines
like
independently
member
returns
true
occurs
list
false
sebesta
solves
text
try
first
member
'a
'
returns
member
'a
'
returns
member
'
'
returns
member
'
'
returns
find
evens
takes
list
numbers
returns
list
containing
numbers
original
list
even
predefined
predicate
even
useful
find
evens
'
returns
find
evens
'
3
9
7
returns
find
evens
'
1
2
3
4
5
returns
2
4
find
evens
'
3
2
7
2
6
returns
2
2
6
even
takes
list
numbers
returns
even
otherwise
even
'
returns
even
'
3
5
7
2
6
returns
even
'
2
8
0
4
88
returns
count
matches
returns
number
times
occurs
list
count
matches
'a
'
returns
0
count
matches
'a
'
returns
3
count
matches
'a
'
returns
1
count
matches
'
'
returns
2
subst
returns
occurrences
changed
subst
'x
'y
'
returns
subst
'a
'b
'
returns
subst
'a
'b
'
returns
subst
'a
'
'
returns
subst
'
'abc
'
returns
abc
abc
first
atom
returns
first
atom
list
matter
deeply
nested
use
predefined
predicates
pair
null
test
whether
something
atom
first
atom
'
returns
first
atom
'
returns
first
atom
'
returns
first
atom
'
returns
easy
atom
'
atomize
returns
list
atoms
matter
deeply
nested
hint
use
predefined
function
append
l1
l2
join
atoms
first
atoms
rest
atomize
'
returns
atomize
'
returns
atomize
'
returns
atomize
'
returns
print
transcript
showing
definitions
tests
indicating
right
