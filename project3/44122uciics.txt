simplification 

simplification
introduction
computer
science
iii
ics
21
22
23
introduction
lecture
will
discuss
variety
general
issues
program
simplification
introduces
new
java
programming
features
instead
steps
back
provide
perspective
one
important
programming
skill
competent
programmers
must
acquire
sometimes
simplifying
program
way
comprehend
hence
debug
finally
lecture
shows
programs
can
studied
manipulated
formal
way
just
expressions
manipulated
algebra
simplification
can
use
laws
algebra
tell
whether
two
forms
equivalent
using
either
one
produces
result
thus
equivalence
mathematical
topic
programmers
must
judge
form
simpler
one
use
programs
simplest
program
one
easiest
read
debug
maintain
thus
simplicity
psychological
topic
rule
thumb
smaller
forms
often
easier
understand
although
sometimes
bit
redundancy
makes
forms
easier
understand
smtms
lss
nt
mr
section
will
examine
three
kinds
algebras
proving
equivalences
boolean
algebra
relational
algebra
control
structure
algebra
will
learn
prove
equivalences
algebra
discuss
gauge
simplicity
well
show
lots
examples
simplifictions
boolean
algebra
boolean
algebra
concerns
equivalences
involving
boolean
type
logical
operators
following
list
useful
laws
theorems
will
boolean
algebra
practical
law
demorgan's
law
one
form
explains
simplify
negation
conjunction
form
explains
simplify
negaion
disjunction
can
easily
prove
laws
boolean
algebra
trying
every
combination
true
false
values
variables
example
prove
conjunctive
version
demorgan's
law
can
start
following
table
values
called
truth
table
list
variables
leftmost
columns
two
expressions
hope
prove
equivalent
rightmost
columns
ab
btruetrue
truefalse
falsetrue
falsefalse
fill
column
just
computing
values
expressions
using
semantics
operators
knowledge
evaluating
expressions
operator
precedence
associativity
ab
btruetruefalsefalsetruefalsetruetruefalsetruetruetruefalsefalsetruetrue
law
proved
columns
two
expressions
always
contain
pair
values
line
means
every
pair
values
expressions
compute
result
expression
equivalent
thus
interchangable
code
approach
also
illustrates
divide
conquer
strategy
proofs
divide
complicated
proof
four
different
parts
line
truth
table
line
easy
verify
pure
calculation
verify
lines
verified
entire
proof
relational
algebra
relational
algebra
concerns
equivalances
mostly
involving
int
double
types
numeric
relational
operators
based
law
trichotomy
law
trichotomy
given
two
values
first
either
less
equal
greater
second
one
exactly
one
relationships
must
always
hold
can
use
law
trichotomy
divide
conquer
method
break
one
hard
proof
many
simpler
ones
unlike
using
boolean
values
billions
different
int
values
infinite
number
integer
value
mathematics
sense
first
example
will
prove
math
max
1
equivalent
math
max
1
1
can
factor
additive
constants
calls
math
max
ymath
max
1math
max
1
1
yy
1y
1x
yx
1
1x
1
1x
yx
1x
1
knowing
relationship
allows
us
compute
answer
expression
example
know
lty
know
math
max
evaluates
math
max
1
evaluates
1
likewise
know
lty
know
1
lty
1
math
max
1
1
evaluates
1
two
cases
can
simplified
similarly
law
proved
columns
two
expressions
always
pair
values
line
means
every
pair
values
expressions
compute
result
expressions
interchangable
another
example
can
prove
expression
equivalent
0
0
true
sign
assuming
sign
0
considered
positive
need
list
possibilities
compare
0
0y
0x
0
0
xytruetruexy
0falsefalsexy
0falsefalsex
0yfalsefalsex
0y
0truetruex
0y
0truetruex
0yfalsefalsex
0y
0truetruex
0y
0truetrue
equivalence
proven
interesting
case
smaller
simpler
efficient
code
necessarily
easier
understand
students
believe
larger
expression
easier
understand
intensely
study
meaning
applied
boolean
values
generated
relational
operators
actual
code
suggest
using
simpler
form
include
larger
easier
understand
form
comment
even
include
proof
part
comment
finally
can
use
law
trichotomy
prove
simplify
negation
relational
operators
careful
recall
law
trichotomy
true
less
two
possiblities
left
equal
greater
beginning
programmers
make
mistake
negating
correct
equivalent
expression
yx
yfalsefalsex
ytruetruex
ytruetrue
fact
can
use
kinds
proofs
show
simplify
negation
every
relational
operator
negated
formsimplified
form
form
yy
yx
yx
also
notice
relational
operators
equivalent
expression
includes
relational
operator
along
sone
logical
operators
although
need
five
relational
operators
write
java
programs
mathematical
sense
provided
programmers
aware
can
use
write
simpler
programs
psychological
sense
thus
java
language
made
larger
operators
make
easier
human
minds
use
value
judgements
better
smaller
language
language
easier
humans
use
required
programming
language
designers
finally
can
often
simplify
negatate
relational
operators
demorgan's
laws
simplifications
example
can
simplify
0
10
0
10
actually
bit
larger
can
simplified
0
truly
simpler
control
structure
algebra
now
will
explore
richest
algebra
algebra
control
structures
first
will
examine
changing
order
sequence
statements
change
results
executing
sequence
second
will
discuss
transformations
statements
finally
will
discuss
transformations
loops
containing
break
statements
sequence
equivalences
start
examining
orderings
statements
defining
two
important
terms
statement
stores
variable
state
variable
can
changed
executing
statement
stores
statement
examines
variable
statements
needs
retrieve
value
stored
variable
examines
interestingly
enough
expression
statement
stores
examines
first
examines
value
stored
computes
value
one
higher
stores
value
back
equivalent
expression
statement
1
illustrates
assertion
clearly
entire
statement
examines
stores
examines
else
stores
examines
say
stores
examines
note
will
also
say
system
println
stores
console
method
causes
new
information
appear
inside
console
window
changing
state
armed
terminology
can
define
indepdendent
statements
sequence
two
statements
independent
can
exchange
order
still
always
compute
equivalent
results
two
statements
s1
s2
independent
s1
stores
examines
variables
s2
stores
s2
stores
examines
variables
s1
stores
example
can
exchange
order
1
system
println
satisfy
property
also
just
think
whether
either
statement
affects
exchange
order
1
system
println
second
statement
examines
first
statement
stores
value
printed
depends
whether
assigned
value
1
print
statement
likewise
can
exchange
order
1
0
satisfy
property
exchange
order
1
second
statement
stores
first
statement
also
stores
obviously
changing
order
two
statements
simplify
anything
will
learn
exchanges
can
sometimes
enable
real
simplifications
equivalences
now
onto
statements
can
use
modified
truth
table
prove
equivalence
two
statements
statement
test
statement1
else
statement2
following
modified
truth
table
note
although
test
can
arbitrarily
complicated
expression
ultimately
value
either
true
false
testcode
executedtruestatement1falsestatement2
boolean
assignment
examine
various
pairs
statements
can
prove
equivalent
using
modified
truth
tables
first
involves
storing
value
boolean
variable
assume
declared
boolean
two
statements
test
test
true
else
false
following
modified
truth
table
testleft
code
executedright
code
executedtrueb
true
true
becaue
test
true
falseb
false
false
becaue
test
false
columns
show
statements
executed
regardless
value
test
else
statement
left
expression
statement
right
equivalent
test
reversal
equivalence
shows
can
reverse
test
order
two
statements
inside
else
resulting
statement
equivalent
first
test
test
statement1
statement2
else
else
statement2
statement1
following
modified
truth
table
testleft
code
executedright
code
executedtruestatement1statement1
falsestatement2
statement2
means
following
two
else
statements
equivalent
argue
one
right
simpler
easier
understand
easier
see
else
statement
eyes
can
see
loking
just
top
three
lines
version
left
small
else
clause
almost
hidden
bottom
test
test
statementt1
statementf
statementt2
else
statementt1
statementtn
statementt2
else
statementf
statementtn
course
might
able
use
demorgan's
law
simplify
test
bottom
factoring
equivalence
shows
can
always
remove
factor
common
statement
bottom
else
statement
similar
algebraically
factoring
ax
bx
test
test
statement1
statement1
statementc
else
else
statement2
statement2
statementc
statementc
prove
equivalence
use
following
modified
truth
table
testleft
code
executedright
code
executedtruestatement1
statementc
statement1
statementcfalsestatement2
statementc
statement2
statementc
example
code
top
equivalent
code
bottom
zcc
0
system
println
zcc
0
zcc
1
else
system
println
zcc
0
zcc
1
zcc
0
system
println
zcc
0
else
system
println
zcc
0
zcc
1
note
one
extra
constraint
simplification
statement
factored
block
use
variables
declared
block
variables
new
scope
statement
moved
outside
either
block
constraint
typically
problem
local
variables
declared
blocks
following
else
top
factoring
equivalence
shows
can
often
remove
common
statement
front
else
statement
similar
algebraically
factoring
xa
xb
test
statementc
statementc
test
statement1
statement1
else
else
statementc
statement2
statement2
prove
equivalence
use
following
modified
truth
table
testleft
code
executedright
code
executedtruestatementc
statement1
statementc
statement1falsestatementc
statement2
statementc
statement2
one
detail
take
care
now
executing
statementc
else
means
executed
test
expression
evaluated
guaranteed
work
statement
test
independent
defined
early
example
code
top
equivalent
code
bottom
zcc
0
zcc
1
system
println
zcc
0
else
zcc
1
system
println
zcc
0
zcc
1
zcc
0
system
println
zcc
0
else
system
println
zcc
0
code
bottom
can
never
test
zcc
0
succeed
test
zcc
0
independent
statements
zcc
1
examines
accesses
variable
stored
statement
hand
sometimes
even
expression
statement
independent
can
modify
test
account
statement
always
executing
else
statement
code
top
equivalent
code
bottom
can
prove
using
law
trichotomy
zcc
0
zcc
0
zcc
system
println
zcc
0
else
zcc
system
println
zcc
0
zcc
zcc
1
system
println
zcc
0
else
system
println
zcc
0
fact
another
way
simplify
code
exchange
two
statements
block
independent
just
bottom
factor
zcc
yielding
zcc
0
system
println
zcc
0
else
system
println
zcc
0
zcc
bottom
factoring
statement
factored
block
contain
variables
declared
block
case
often
declaration
can
top
factored
block
equivalences
finally
look
three
loop
equivalences
else
removal
equivalence
involves
removal
unnecessary
else
controlling
break
statements1
statements1
test
test
break
break
else
statements2
statements2
loops
test
true
java
executes
break
test
false
loop
executes
statements2
next
re
executes
loop
left
statements2
else
right
finishes
java
executes
next
statement
loop's
body
executing
statements2
bodies
loops
finished
executing
loop
causes
java
execute
typically
code
simpler
nested
deeply
loop
factoring
second
loop
equivalence
involves
factoring
statements
statements1
statements1
test
test
statementsa
break
break
statements2
statements2
statementsa
loops
test
false
executes
statements2
bodies
loops
executed
left
loop
test
true
executes
statementsa
terminates
loop
right
terminates
loop
afterward
executes
statementsa
order
operations
makes
difference
except
variables
declared
inside
block
block
body
statement
stored
examined
outside
block
loop
terminates
typically
loop
statements
complex
understand
terms
removing
statementsa
body
loop
simplify
loop
rerolling
third
loop
equivalence
involves
moving
statements
repeated
bottom
loop
completely
inside
loop
statements1
statements1
test
test
break
break
statements2
statements2
statements1
code
fragment
first
executes
statements1
left
loop
right
first
statement
loop's
body
tests
termination
test
true
executes
statements2
followed
statements1
left
bottom
loop
right
top
th
loop
followed
testing
termination
typically
want
avoid
duplicating
statements
inside
outside
loops
using
break
allows
termination
test
middle
loop
can
remove
redundancy
pragmatics
formal
techniques
presented
illustrated
allow
us
prove
two
programming
forms
equivalent
us
determine
form
simpler
use
programs
rule
thumb
smaller
code
simpler
also
code
fewer
nested
statements
generally
simpler
generally
try
distribute
complexity
decidiing
two
equivalences
choose
one
whose
complicated
statement
simplest
ever
find
duplicating
code
excellent
chance
simplification
will
remove
redundancy
beginners
especially
prone
duplicating
large
chunks
code
missing
important
simplification
aggressively
simplify
code
programming
will
amply
rewarded
easier
add
code
completing
phases
enhancements
already
simplified
program
wait
program
finished
simplifying
well
many
never
finish
program
become
complex
finish
context
perform
simplification
will
much
bigger
complex
making
harder
simplify
excessive
complexity
one
biggest
problems
software
engineer
faces
generally
try
get
distracted
writing
code
one
times
will
stop
writing
code
see
simplification
know
long
run
taking
time
simplification
immediately
will
likely
allow
finish
program
faster
problem
set
ensure
understand
material
lecture
please
solve
announced
problems
read
lecture
get
stumped
problem
go
back
read
relevant
part
lecture
still
questions
please
get
help
instructor
ca
student
prove
expressions
10
10
true
equivalent
prove
expressions
10
10
false
equivalent
case
judge
simpler
expression
use
law
trichotomy
prove
math
abs
2
math
min
compute
value
following
statements
identify
variabes
stored
variables
examined
1
system
println
0
0
0
break
prove
following
two
statements
equivalent
assume
declared
boolean
test
test
false
else
true
code
left
equivalent
code
right
top
factored
equivalent
if's
test
statements
independent
rewrite
if's
test
code
right
left
right
equivalent
10
10
system
println
system
println
else
else
suppose
comparing
aspirin
a1
a2
a3
a4
efficacy
suppose
company
making
a1
goes
tv
advertisement
aspirin
better
a1
companies
also
run
ads
saying
exact
thing
products
question
relate
material
lecture
relate
mathematical
vs
perceptual
psychological
truths
advertising
programmer
whose
code
read
people
well
java
compiler
implications
audience
writing
code
