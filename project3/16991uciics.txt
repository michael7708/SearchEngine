compsci 141 cse 141 informatics 101 fall 2009 final exam study guide 
final exam study guide 
compsci
141
cse
141
informatics
101
fall
2009
news
course
reference
schedule
lab
manual
code
examples
alex
compsci
141
cse
141
informatics
101
fall
2009
final
exam
study
guide
introduction
study
guide
summary
material
covered
lecture
since
midterm
final
exam
cumulative
also
worth
checking
midterm
study
guide
prepare
final
exam
best
general
advice
can
give
preparing
exam
aim
understanding
memorization
fair
say
will
need
memorize
bit
new
syntax
able
apply
important
syntax
particular
able
answer
question
requires
take
additional
step
beyond
something
seen
class
appropriate
context
explained
combines
two
things
discussed
short
try
pay
attention
bigger
picture
focusing
also
point
study
guide
intended
replacement
lectures
possible
something
discussed
class
will
left
study
guide
still
fair
game
exam
trying
cheat
purpose
study
guide
guide
enjoy
non
lecture
reading
aware
non
lecture
reading
specified
schedule
fair
game
exam
intending
find
tiny
details
reading
test
familiar
broad
concepts
covered
able
answer
questions
object
oriented
programming
abstract
data
type
set
hidden
data
packaged
operations
cleanly
safely
manipulate
data
class
java
abstract
data
type
provided
fields
public
provided
operations
provided
public
methods
abstract
data
types
can
also
implemented
languages
support
object
oriented
programming
see
provided
code
example
object
oriented
programming
characterized
three
features
classes
inheritance
polymorphism
polymorphism
necessarily
automatic
java
calls
non
final
non
static
methods
polymorphic
meaning
type
object
determines
version
method
called
polymorphic
behavior
turned
default
can
turned
declaring
function
virtual
know
difference
public
private
inheritance
understand
layout
objects
use
virtual
method
tables
including
effect
single
inheritance
implementation
subprograms
detailed
explanation
necessary
concepts
appears
first
three
sections
chapter
8
pay
attention
section
describes
passing
subprograms
parameters
subprograms
test
term
subprogram
refers
collectively
often
called
procedures
functions
subroutines
methods
member
functions
various
programming
languages
words
chunk
code
takes
set
parameters
work
optionally
returns
value
say
subprogram
active
time
called
time
returns
naturally
one
subprogram
may
active
given
time
since
subprograms
may
call
subprograms
execution
subprogram
active
information
relevant
activation
must
stored
memory
somewhere
information
typically
stored
activation
record
language
whose
local
variables
allocated
statically
compile
time
can
recursion
one
activation
given
subprogram
can
exist
given
time
languages
activation
records
allocated
statically
one
activation
record
allocated
compile
time
subprogram
will
clear
compile
time
activation
record
will
located
means
accesses
information
fast
information
stored
activation
record
situation
execution
state
comprised
information
values
stored
registers
time
call
return
address
address
instruction
follows
call
subprogram
actual
parameters
depending
parameter
passing
mode
use
values
parameters
may
stored
pointers
values
may
stored
instead
local
variables
values
local
variables
stored
activation
record
language
stack
dynamic
local
variables
many
activations
subprogram
may
exist
one
time
rendering
strategy
inadequate
instead
activation
records
stored
run
time
stack
subprogram
called
activation
record
subprogram
pushed
run
time
stack
caller
callee
share
burden
initializing
subprogram
returns
activation
record
popped
run
time
stack
information
stored
activation
record
situation
execution
state
caller's
job
store
information
since
comprised
caller's
execution
state
return
address
address
instruction
follows
call
subprogram
initialized
caller
actual
parameters
also
initialized
caller
dynamic
link
link
next
activation
record
stack
initialized
caller
local
variables
initialized
callee
parameter
passing
modes
understand
parameter
passing
modes
covered
chapter
8
test
pass
name
like
understand
others
concurrency
modern
operating
system
running
single
processor
machine
can
give
illusion
performing
many
tasks
illusion
created
rapidly
switching
one
program
another
giving
one
tiny
slice
processor
time
switching
next
one
long
program
given
enough
slices
programs
will
appear
making
progress
simultaneously
multi
processor
machine
technique
used
allow
programs
run
number
available
processors
single
program
can
consist
multiple
tasks
also
appear
operate
simultaneously
different
programming
languages
provide
different
mechanisms
prevalent
mechanism
provided
java
well
libraries
variety
languages
use
threads
simply
stated
thread
java
program
counter
run
time
stack
threads
program
share
static
memory
heap
since
threads
essentially
share
set
objects
mechanisms
must
put
place
ensure
step
other's
toes
analogy
ten
people
working
one
office
office
one
tall
file
cabinet
four
drawers
workers
will
need
make
agreement
share
one
possible
agreement
synchronize
access
entire
cabinet
worker
standing
front
cabinet
accessing
drawers
worker
will
allowed
use
file
cabinet
another
possible
agreement
synchronize
access
drawer
separately
one
worker
accessing
top
drawer
another
can
access
bottom
drawer
will
allow
workers
use
file
cabinet
simultaneously
though
will
somewhat
difficult
use
drawers
since
workers
will
stand
side
squat
funny
positions
order
use
trade
increasing
efficiency
cost
complexity
multi
threaded
java
programs
three
basic
problems
need
addressed
synchronizing
access
shared
objects
one
thread
will
changing
piece
data
another
reading
two
threads
will
attempt
simultaneously
change
piece
data
minimizing
amount
time
thread
spends
waiting
access
object
accessed
another
thread
ensuring
whenever
thread
able
make
progress
whatever
reason
consumes
resources
possible
first
problem
can
solved
using
synchronization
two
forms
synchronization
synchronized
blocks
synchronized
methods
every
object
java
program
contains
monitor
monitor
among
things
consists
lock
can
possessed
one
thread
time
synchronized
block
looks
like
synchronized
myobject
body
block
thread
reaches
block
will
first
attempt
acquire
myobject's
lock
thread
possesses
lock
will
acquire
lock
run
code
within
block
release
lock
another
thread
possesses
lock
will
block
lock
available
synchronized
method
one
declared
synchronized
keyword
public
synchronized
void
foo
equivalent
public
void
foo
synchronized
words
object
one
thread
can
within
o's
synchronized
methods
given
time
second
problem
can
solved
judicious
use
synchronization
one
way
ensure
thread
synchronization
use
one
lock
entire
program
thread
can
modify
object
must
first
possess
program's
main
lock
solution
particularly
unrealistic
trade
simplicity
efficiency
one
hand
solution
simple
one
guaranteeing
one
thread
can
accessing
shared
objects
given
time
possibility
synchronization
problems
exists
hand
threads
will
spend
vast
majority
time
waiting
lock
solution
terribly
inefficient
particularly
multiple
processor
machine
multiple
processors
used
multiple
threads
program
multiple
threads
kept
busy
better
solution
problem
involves
locking
objects
individually
even
locking
portions
object
separately
example
synchronized
queue
implemented
singly
linked
list
head
tail
references
separate
lock
used
head
node
tail
node
allowing
one
thread
add
end
queue
another
removing
beginning
care
taken
certain
special
cases
queue
two
less
nodes
third
problem
can
solved
couple
ways
threads
can
sleep
specified
length
time
way
saying
allow
thread
make
progress
next
milliseconds
situations
time
primary
criterion
used
determine
long
thread
block
example
might
want
dequeue
method
thread
safe
queue
class
block
item
queue
case
wait
notify
used
can
read
great
deal
information
multi
threaded
java
couple
places
first
provided
two
thoroughly
commented
code
examples
java
web
site
java
sun
com
thread
tutorial
though
certainly
information
need
study
exam
covering
topics
timers
timertasks
cover
course
message
passing
concurrency
alternative
shared
memory
concurrency
concurrent
tasks
share
set
objects
thus
carefully
synchronize
access
every
task
separate
set
objects
instead
tasks
unable
see
other's
objects
though
permitted
send
messages
one
another
messaging
way
one
task
can
influence
another
influence
passing
messages
tasks
alternative
often
called
message
passing
concurrency
message
passing
provides
advantage
problems
associated
synchronizing
access
shared
objects
largely
go
away
deadlock
example
rare
though
impossible
accessing
object
one
task
another
task
middle
modifying
will
never
happen
primary
disadvantage
message
passing
situation
lot
information
needs
shared
tasks
case
cost
passing
messages
may
prohibitive
explored
message
passing
assignment
6
though
mechanism
somewhat
cumbersome
given
java
natively
support
message
passing
style
ideas
similar
find
languages
like
erlang
support
message
passing
directly
haskell
features
mainstream
languages
fairly
detailed
code
examples
java
available
interesting
haskell
features
show
mainstream
languages
lecture
sure
understand
ask
write
exam
expect
able
read
understand
code
uses
features
demonstrated
lecture
design
contract
bertrand
meyer
developed
programming
style
called
design
contract
core
design
contract
built
around
idea
whenever
one
component
software
system
uses
another
contract
governing
components
will
interact
considering
methods
java
part
contract
explicit
signature
method
indicates
types
arguments
method
expects
type
value
returns
allowed
call
public
private
checked
exceptions
throws
part
contract
implicit
values
legal
parameter
parameters
null
range
values
might
returned
method
returns
int
might
ever
return
non
negative
value
core
idea
new
idea
rules
governing
interaction
components
around
decades
meyer
tried
design
contract
make
rules
explicit
include
language
level
support
describing
can
say
directly
program
programming
language
instead
documentation
can
expect
compilers
run
time
systems
check
things
say
eiffel
object
oriented
language
meyer
designed
exploring
ideas
three
extra
things
can
say
contract
class
users
beyond
accustomed
java
preconditions
every
method
specify
must
true
parameters
passed
method
example
precondition
specified
particular
parameter's
value
must
null
integer
parameter
must
value
less
equal
arraylist's
size
postconditions
every
method
specify
guaranteed
true
method
finished
might
simple
saying
arraylist's
size
method
will
always
return
non
negative
value
complex
saying
guaranteed
every
element
list
will
less
equal
element
follows
sort
method
finished
class
invariants
describes
conditions
must
true
class
every
method
called
class
invariants
often
implicit
assumptions
make
writing
class
able
specify
code
makes
assumptions
explicit
forget
others
reading
code
can
know
also
allows
assumptions
checked
options
contract
checking
compile
time
checking
difficult
general
case
possible
least
cases
run
time
checking
compiler
can
insert
code
every
method
check
preconditions
postconditions
class
invariants
appropriate
times
violation
can
result
immediate
run
time
exception
check
debugging
remove
checks
shipping
code
customers
makes
easier
find
problems
working
program
preserves
performance
customers
eliminating
checks
fairly
sure
program
works
explicit
support
design
contract
gradually
beginning
show
mainstream
programming
languages
jury
whether
will
hugely
successful
worth
knowing
ideas
underlying
good
ones
even
program
langauge
directly
support
