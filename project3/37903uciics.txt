ics 180 february 2 1999 
variants alpha beta search 
ics
180
winter
1999
strategy
board
game
programming
lecture
notes
february
2
1999
variants
alpha
beta
search
although
basic
alpha
beta
search
discussed
already
simple
works
well
several
attempts
search
game
trees
even
efficiently
basic
idea
behind
consider
scores
range
alpha
beta
interesting
scores
uninteresting
alpha
beta
gets
efficiency
cutting
search
quickly
nodes
uninteresting
scores
narrow
gap
alpha
beta
fewer
scores
will
interesting
cutoffs
will
happen
first
quickly
review
original
alpha
beta
search
omitting
details
like
hashing
adjust
winning
scores
current
ply
basic
alpha
beta
search
int
alphabeta
int
depth
int
alpha
int
beta
move
bestmove
game
depth
alpha
alpha
score
bestmove
unmake
move
alpha
beta
break
return
alpha
fail
soft
alpha
beta
code
always
returns
alpha
beta
number
alpha
beta
words
score
uninteresting
extra
information
returned
score
reason
current
score
kept
variable
alpha
starts
bottom
window
interesting
scores
always
increases
possible
return
score
less
alpha
one
simplest
improvements
alpha
beta
keep
current
score
alpha
separate
variables
following
pseudocode
uses
constant
win
denote
maximum
score
can
returned
call
alpha
beta
search
fail
soft
alpha
beta
search
int
alphabeta
int
depth
int
alpha
int
beta
move
bestmove
int
current
win
game
depth
current
current
score
bestmove
score
alpha
alpha
score
score
beta
break
return
current
change
one
can
determine
little
information
position
returned
value
less
equal
alpha
still
know
true
value
position
may
pruned
away
important
lines
search
know
true
value
similarly
greater
equal
beta
know
true
search
value
least
slightly
tighter
upper
lower
bounds
improve
search
lead
greater
number
successful
hash
probes
use
fail
soft
alpha
beta
also
essential
mtd
algorithm
described
aspiration
search
replacement
alpha
beta
just
change
way
outermost
call
search
made
normally
using
alpha
beta
choose
best
move
one
calls
alphabeta
depth
win
win
huge
range
win
win
indicates
know
true
search
value
will
possible
scores
considered
interesting
move
one
makes
one
set
variable
bestmove
outer
level
search
instead
often
helpful
call
alpha
beta
artificially
narrow
window
centered
around
previous
search
value
result
score
within
window
saved
time
found
correct
search
value
search
fails
must
widen
window
search
aspiration
search
int
alpha
previous
window
int
beta
previous
window
score
alphabeta
depth
alpha
beta
score
beta
beta
win
else
break
constant
window
set
way
balances
time
savings
narrower
search
time
lost
repeating
unsuccessful
search
typical
value
chess
might
around
half
pawn
variants
aspiration
search
include
widening
window
gradually
event
unsuccessful
search
using
initial
search
window
necessarily
centered
around
previous
search
result
mtd
technique
like
aspiration
search
just
modification
initial
call
alpha
beta
narrower
search
window
leads
faster
searches
idea
make
search
window
narrow
possible
always
calls
alpha
beta
beta
alpha
1
effect
zero
width
search
compare
true
score
alpha
search
returns
value
alpha
true
score
alpha
otherwise
true
score
greater
alpha
one
use
idea
perform
binary
search
true
score
int
alpha
win
int
beta
win
beta
alpha
1
int
test
alpha
beta
2
alphabeta
depth
test
test
1
however
will
lead
large
number
searches
logarithm
difference
win
win
mtd
idea
instead
use
fail
soft
alpha
beta
control
search
call
fail
soft
alpha
beta
returns
search
value
closer
final
score
use
search
value
start
next
test
eventually
converge
mtd
int
test
0
score
alphabeta
depth
test
test
1
test
score
break
test
score
unfortunately
complicated
interactions
hash
table
can
cause
routine
get
infinite
loop
one
needs
additional
code
halt
search
many
iterations
made
without
convergence
one
big
advantage
mtd
can
simplify
code
alpha
beta
search
since
really
two
parameters
depth
alpha
rather
three
pvs
probably
best
alpha
beta
variants
goes
several
names
negascout
principal
variation
search
pvs
short
idea
alpha
beta
search
works
best
first
recursive
search
likely
one
best
score
techniques
sorting
move
list
using
best
move
stored
hash
table
make
especially
likely
first
move
best
can
search
moves
quickly
using
assumption
likely
good
pvs
performs
first
search
normal
window
subsequent
searches
uses
zero
width
window
test
successive
move
first
move
zero
width
search
fails
normal
search
principal
variation
search
fail
soft
version
int
alphabeta
int
depth
int
alpha
int
beta
move
bestmove
current
game
depth
alpha
score
beta
score
alphabeta
depth
1
beta
alpha
unmake
move
score
current
current
score
bestmove
score
alpha
alpha
score
score
beta
break
return
current
shares
advantage
mtd
nodes
search
tree
zero
width
windows
can
use
simpler
two
parameter
form
alpha
beta
since
calls
beta
alpha
1
one
can
extra
work
calls
saving
best
move
later
use
without
worrying
much
extra
time
takes
recommendations
program
uses
combination
aspiration
search
outermost
call
search
routines
pvs
inner
calls
however
different
games
behave
differently
searches
hard
implement
aspects
game
programming
best
way
choose
tune
parameters
implement
try
experiments
return
search
value
nearly
influenced
hash
table
different
numbers
nodes
searched
pick
one
leads
smallest
search
trees
typical
positions
game
david
eppstein
dept
information
computer
science
uc
irvine
