understanding software productivity 

understanding
software
productivity
walt
scacchi
information
operations
management
department
school
business
administration
university
southern
california
los
angeles
ca
90089
1421
usa
appears
advances
software
engineering
knowledge
engineering
hurley
ed
volume
4
pp
37
70
1995
december
1994
affects
software
productivity
improve
report
examines
current
state
art
software
productivity
measurement
turn
describes
framework
understanding
software
productivity
fundamentals
measurement
surveys
empirical
studies
software
productivity
identifies
challenges
involved
measuring
software
productivity
radical
alternative
current
approaches
suggested
construct
evaluate
deploy
evolve
knowledge
based
`software
productivity
modeling
simulation
system'
using
tools
techniques
domain
software
process
engineering
overview
affects
software
productivity
improve
concern
near
dear
responsible
researching
developing
large
software
systems
example
boehm
10
reports
1995
20
improvement
software
productivity
will
worth
45
billion
90
billion
worldwide
report
examines
current
state
art
understanding
software
productivity
turn
report
describes
fundamentals
measurement
presents
survey
studies
software
productivity
identifies
variables
apparently
affecting
software
productivity
identifies
alternative
directions
research
practice
understanding
affects
software
productivity
survey
apparent
existing
software
productivity
measurement
studies
fundamentally
inadequate
potentially
misleading
depending
indicators
software
productivity
measured
possible
achieve
results
show
modest
changes
software
development
technologies
lead
substantial
productivity
improvements
300
5
years
major
changes
new
technologies
can
lead
little
productivity
improvement
different
measurement
strategies
can
show
opposite
trend
short
measure
determines
much
productivity
improvement
see
whether
productivity
actually
improved
report
advocates
radical
alternative
current
approaches
measuring
understanding
affects
software
productivity
construct
evaluate
deploy
knowledge
based
software
productivity
modeling
simulation
systems
accordingly
effort
directed
developing
knowledge
based
system
models
symbolically
simulates
software
production
occurs
given
project
setting
modeling
facility
used
simulate
software
production
various
product
requirements
development
processes
project
settings
computing
resource
conditions
also
used
incrementally
capture
information
production
dynamics
multiple
software
projects
thus
improve
breadth
coverage
time
result
modelling
technology
used
articulate
update
computational
knowledge
based
`corporate
memory'
software
production
practices
potential
payoff
technology
substantial
technology
provides
vehicle
delivering
practical
feedback
software
developers
managers
can
use
prior
development
project
help
identify
might
improve
productivity
knowledge
based
technology
enable
project
managers
developers
analysts
query
model
conduct
`what
if'
analysis
diagnose
project
development
anomalies
generate
explanations
certain
project
conditions
affect
productivity
capabilities
possible
current
productivity
measurement
technologies
overall
examination
software
productivity
primarily
focuses
development
large
scale
software
systems
lss
lss
refers
delivered
software
systems
developed
team
developers
intended
sustained
operation
long
time
typically
representing
50k
500k
source
code
statements
choice
lss
motivated
economic
practical
considerations
lss
expensive
develop
maintain
even
modest
software
productivity
improvements
can
lead
substantial
savings
example
reasonable
assume
10
000
lines
code
may
cost
development
organization
100
000
250
000
larger
systems
range
50
000
250
000
lines
code
cost
may
climb
much
factor
4
25
turn
reasonable
assume
software
maintenance
costs
total
life
system
dominate
software
development
costs
factor
2
10
small
scale
programming
productivity
measurement
often
reveals
order
magnitude
variation
different
people
different
programs
18
19
large
scale
programming
efforts
large
staffs
can
mitigate
variance
outline
remainder
report
follows
section
2
provides
brief
exposition
science
measurement
section
serves
identify
fundamental
concerns
evaluating
software
productivity
measures
section
3
provides
select
survey
studies
attempt
identify
measure
affects
software
productivity
results
survey
summarized
section
3
14
list
software
projects
attributes
contribute
productivity
improvement
three
sections
set
stage
section
4
provides
discussion
measurable
variables
appear
affect
software
productivity
section
5
follows
new
direction
research
identifying
affects
software
productivity
improve
summarize
conclusions
consequences
follow
endeavor
notes
science
measurement
measurement
ultimately
quest
certainty
control
certainty
understanding
nature
phenomenon
control
influence
evaluate
phenomenon
paper
phenomenon
study
software
production
system
inception
delivery
operation
support
accordingly
want
understand
software
produced
measure
production
ultimately
positively
influence
control
rate
production
curtis
18
provides
appropriate
background
fundamental
principles
involved
measuring
software
production
characteristics
including
measure
validity
reliability
well
instrumentation
modeling
issues
desire
measure
software
production
implies
encounter
process
systematic
scientific
inquiry
implies
need
confront
fundamental
problems
role
measurement
theory
development
hypothesis
testing
verification
performance
evaluation
also
implies
understanding
relationship
measurement
instrumentation
artifacts
employed
collect
measure
data
phenomenon
study
instrumentation
turn
raises
questions
simplify
make
trade
offs
convenience
data
collection
versus
cost
alternative
instrumentation
collection
sampling
strategies
ease
rendering
displaying
results
data
analysis
different
audiences
internal
management
presentations
versus
journal
publication
handle
delete
anomalous
data
collected
survey
instruments
use
collected
data
monitor
evaluate
intervene
phenomenon
study
developing
narrative
diagrammatic
operational
abstraction
phenomenon
source
data
collected
fundamental
concerns
use
measurements
include
account
influence
unmeasured
units
uniformity
consistency
measured
units
rationalize
construction
composite
measures
rationalize
measurement
scales
normalizations
concerns
must
addressed
developing
sustaining
effort
measuring
software
production
types
measures
appropriate
understanding
software
productivity
productivity
studies
inside
software
world
usually
expressed
ratio
output
units
produced
per
unit
input
effort
simple
relation
carries
important
considerations
example
productivity
measures
comparable
counting
kind
outputs
lines
source
code
inputs
person
months
time
likewise
software
development
effort
productivity
2x
twice
productive
another
effort
whose
productivity
therefore
outputs
inputs
defined
critical
concerns
related
ratio
type
measure
will
become
apparent
survey
follows
measure
types
nominal
ordinal
interval
also
appropriate
indicators
characterize
variables
shape
software
productivity
next
section
survey
studies
software
productivity
measurement
shows
often
substantial
amount
difference
respect
degree
rigor
use
accepted
analytical
methods
sample
software
productivity
measurement
studies
number
researchers
sought
empirical
investigations
determine
whether
software
development
attribute
tool
technique
combination
significant
impact
software
production
studies
primarily
focus
development
lss
twelve
major
software
productivity
measurement
studies
reviewed
including
ibm
trw
nasa
itt
well
international
sites
addition
number
theoretical
empirical
studies
programmer
productivity
cost
benefit
analysis
software
cost
estimation
software
productivity
improvement
program
reviewed
together
studies
provide
loosely
grounded
basis
identifying
number
project
characteristics
affect
software
productivity
ibm
federal
systems
division
walston
felix
56
conducted
classic
study
area
authors
state
major
difficulty
arises
trying
identify
measure
independent
variables
can
used
estimate
software
development
productivity
cost
size
example
measured
software
productivity
terms
number
lines
code
produced
per
person
hour
however
staff
time
measured
duration
complete
development
project
rather
just
coding
phase
thus
information
percent
measured
project's
effort
dedicated
code
production
versus
necessary
development
activities
omission
tends
distort
results
analysis
ibm
dp
services
organization
albrecht
2
3
developed
`function
point'
measure
compare
productivity
24
projects
developed
business
applications
function
point
composite
measure
number
program
atributes
including
number
inputs
outputs
function
calls
file
accesses
etc
multiplied
weighting
factors
added
together
systems
albretch
examined
ranged
size
3k
318k
lines
code
written
either
dms
pl
1
cobol
developed
5
year
period
1974
1978
albrecht
claims
period
programs
studied
software
productivity
measured
function
points
increased
3
1
finds
developers
using
dms
database
management
system
language
productive
writing
pl
1
turn
productive
writing
cobol
application
systems
developed
tended
time
increasingly
interactive
vs
batch
accessing
large
data
files
databases
produce
reports
also
5
year
period
developers
progressively
began
practice
structured
coding
top
implementation
hipo
documentation
development
techniques
seem
lead
function
points
appearing
source
code
poorly
structured
code
will
tend
fewer
functions
points
well
structured
code
conforming
specification
thus
structured
code
can
produce
higher
function
point
measure
therefore
appear
produced
productively
number
confounding
factors
appear
albrecht's
results
undercut
validity
reported
productivity
improvement
claims
example
formula
computing
function
point
values
incorporate
weighting
multipliers
reports
produced
reliable
results
however
discuss
weights
determined
determine
programming
languages
software
applications
measured
also
indicates
department
manager
instructed
program
supervisors
collect
function
point
data
extent
supervisors
encouraged
programs
developed
ways
lead
function
points
produced
per
unit
effort
however
unclear
whether
function
point
technique
works
equally
well
non
business
application
systems
rely
accessing
large
files
retrieving
selected
data
performing
computations
data
producing
various
reports
thus
unclear
whether
3
1
productivity
improvement
albrecht
claims
due
shifts
choice
programming
language
produce
favorable
measures
alternative
program
development
techniques
choice
multiplier
weights
management
encouragement
collecting
data
substantiates
rewards
measured
improvement
equitable
life
organizations
behrens
5
also
utilizes
albrecht's
function
point
measures
compare
software
productivity
25
application
system
projects
developed
various
life
insurance
companies
1980
1981
results
consistent
albrecht's
supporting
contention
project
size
development
computing
environment
programming
language
impact
software
productivity
particular
finds
small
project
teams
produce
source
code
function
points
large
teams
comparable
amount
time
also
finds
developers
working
online
productive
working
batched
computing
environment
can
also
observe
large
projects
software
runs
tend
become
batch
like
size
grows
amount
computing
resources
require
grows
trw
defense
systems
group
boehm
9
12
sought
identify
avenues
improving
software
productivity
based
primarily
trw's
software
cost
estimation
program
scep
program
served
aid
developing
cost
estimates
competitive
proposals
large
government
software
projects
program
estimates
cost
software
project
function
program
size
expressed
delivered
source
instructions
number
cost
drivers
experience
scep
turn
gave
rise
development
cocomo
software
cost
estimation
model
presented
9
boehm
recognized
software
cost
drivers
effectively
inverse
productivity
`benefit'
drivers
found
example
personnel
team
capability
product
complexity
greatest
affect
driving
software
costs
productivity
thus
high
staff
capability
low
product
complexity
lead
high
productivity
low
cost
software
production
conversely
low
staff
capability
high
product
complexity
similarly
imply
low
productivity
high
cost
software
production
experience
cost
estimation
models
boehm
able
develop
quantitative
support
relative
contribution
different
software
development
characteristics
affect
software
cost
productivity
australia
70
study
lawrence
39
conducted
study
278
commercial
applications
developed
23
medium
large
organizations
australia
organizations
applications
studies
included
government
agencies
manufacturing
mining
concerns
banking
insurance
firms
performed
multivariate
analysis
productivity
variance
using
combination
computing
environment
organizational
factors
use
multivariate
analysis
variance
direct
contrast
preceding
software
productivity
studies
employ
univariate
analysis
lawrence
observed
source
lines
code
number
statements
number
procedure
invocations
number
functional
units
number
transfers
control
highly
correlated
researchers
substantiated
well
chose
employ
number
procedural
lines
code
divided
total
time
put
programming
job
programmer
receipt
program
specifications
completion
program
testing
lawrence
interested
measuring
productivity
individual
programmers
turn
developing
small
programs
50
10000
lines
code
found
programmer
productivity
increases
better
turnaround
decreases
online
source
code
testing
interface
database
contrast
albretch
lawrence
define
interface
database
means
whether
organizations
studied
employed
database
management
systems
thus
possible
determine
whether
albretch
lawrence
agree
productivity
impact
use
database
management
systems
however
lawrence
also
found
programming
experience
beyond
first
year
job
structured
programming
walkthroughs
contribute
little
productivity
improvement
nasa
sel
bailey
basili
4
found
higher
productivity
entire
system
life
cycle
associated
use
disciplined
programming
methodology
particularly
early
stages
system
development
findings
indicate
productivity
measures
well
resource
utilization
estimates
must
specific
organizational
setting
local
computing
environment
provide
accurate
measures
standard
program
oriented
productivity
cost
estimation
measures
will
provide
less
accurate
information
measures
account
characteristics
organization
computing
environment
mohanty
44
kemerer
30
also
found
similar
results
independent
examinations
different
software
cost
estimation
models
ibm
thadhani
54
lambert
37
examined
effects
good
computer
services
programmer
project
productivity
application
program
development
particular
studies
examine
effects
short
response
times
programmer's
skills
program
complexity
programmer
productivity
thadhani
reports
programmers
twice
productive
system's
average
response
time
0
25
seconds
less
averaged
2
seconds
however
review
similar
studies
conte
colleagues
17
report
average
response
time
critical
narrow
variance
expected
response
time
programmers
productive
system's
response
time
fast
consistent
relatively
predictable
computing
task
hand
thadhani
lambert
assert
unexpected
delay
response
time
trivial
computing
tasks
processing
simple
editor
shell
commands
compiling
small
program
psychologically
disruptive
programmer
delays
argue
cause
longer
delay
actual
elapsed
time
since
lss
development
efforts
can
entail
thousands
trivial
task
transactions
cumulative
time
will
represent
significant
cost
project
essentially
argue
response
time
impact
lss
development
projects
ample
processing
resources
critical
enhancing
software
productivity
subsequently
viewed
evidence
favor
providing
individual
programmers
processing
resources
adoption
powerful
personal
computing
workstations
way
improve
software
productivity
programmers
currently
must
share
small
number
heavily
loaded
computer
systems
providing
programmer
workstation
improve
collective
productivity
43
itt
advanced
technology
center
vosburg
associates
55
produced
perhaps
substantial
study
large
scale
software
productivity
date
examined
software
production
data
44
programming
projects
17
different
itt
subsidiaries
nine
different
countries
data
programming
productivity
quality
cost
collected
records
completed
projects
means
questionnaire
answered
project
managers
software
systems
ranged
size
5
000
500
000
coded
statements
median
size
22
000
statements
statement
counts
include
language
processing
directives
macro
calls
file
inclusion
statements
comments
blank
lines
study
covered
variety
software
systems
including
telecommunications
switches
programming
tools
operating
systems
electronic
defense
systems
process
control
total
represent
2
3
million
coded
statements
1500
person
years
effort
authors
focused
classifying
productivity
drivers
according
ability
software
project
manager
control
identify
two
types
factors
product
related
factors
usually
controllable
project
manager
production
process
related
factors
controllable
managers
thus
provide
opportunity
productivity
improvement
product
related
factors
identify
include
computing
resource
constraints
productivity
decreases
software
developed
timing
memory
utilization
cpu
occupancy
constraints
program
complexity
productivity
decreases
software
primarily
operating
systems
real
time
command
control
fault
tolerant
applications
require
extensive
error
detection
rollback
recover
routines
customer
participation
productivity
increases
customer
application
experience
participation
requirements
specification
articulation
size
program
product
productivity
decreases
number
lines
code
increases
production
process
related
factors
identify
include
concurrent
hardware
software
development
productivity
decreases
concurrent
development
hardware
development
computer
size
productivity
increases
computer
size
processor
speed
main
secondary
storage
capacity
increases
requirements
specifications
stability
productivity
increases
accurate
stable
system
requirements
specifications
use
modern
programming
practices
productivity
increases
extensive
use
top
design
modular
design
design
reviews
code
inspections
quality
assurance
programs
personnel
experience
productivity
increases
experienced
software
development
personnel
overall
find
product
related
process
related
factors
account
approximately
amount
variance
one
third
set
productivity
enhancement
conclusion
authors
suggest
improving
programming
productivity
requires
much
isolated
implementation
new
technologies
policies
view
`to
successful
productivity
improvement
program
must
address
entire
spectrum
productivity
issues
key
features
program
management
commitment
integrated
approach'
pp
151
152
australia
80
study
jeffrey
26
describes
comparative
study
software
productivity
among
small
teams
38
development
projects
three
austrialian
firms
firm
used
one
programming
language
projects
different
used
two
firms
software
systems
projects
ranged
small
200
loc
large
`
100k
loc
development
team
size
ranged
1
4
developers
19
projects
3
8
projects
result
analysis
jeffrey
asserts
optimal
staff
level
depends
language
used
size
resulting
software
system
adding
staff
beyond
optimal
point
decreases
productivity
increases
total
development
elasped
time
however
due
small
sample
size
three
firms
small
team
size
vis
vis
individual
programmer
variations
19
common
analytical
shortcomings
defining
input
output
measures
generality
assertions
limited
commerical
banks
cerveny
joseph
15
report
study
software
enhancement
productivity
200
commercial
banks
bank
required
change
national
tax
laws
implement
new
interest
reporting
requirements
thus
banks
satisfy
set
tax
law
requirements
cerveny
joseph
found
banks
employed
structured
design
programming
techniques
took
twice
effort
banks
used
non
structured
techniques
purchased
integrated
commercial
software
packages
effort
study
represents
person
hours
expended
analysis
programming
project
management
activities
data
apparently
collected
routine
basis
banks
study
report
measure
source
code
changes
accompany
measured
effort
however
report
banks
employed
structured
techniques
auditing
control
purposes
generally
lacked
case
tools
support
structured
techniques
thus
unclear
net
change
software
productivity
might
case
tools
support
structured
design
programming
techniques
empolyed
vs
japan
study
provocative
yet
systematic
comparison
industrial
software
productivity
japan
cusumano
kemerer
21
argue
japanese
software
development
capabilities
comparable
found
20
analyses
examined
data
24
16
japanese
development
efforts
collected
software
project
managers
completed
questionnaires
project
sample
varied
terms
appplication
type
programming
language
used
programming
language
application
type
hardware
platforms
full
time
versus
part
time
staff
effort
development
phase
percentage
code
reuse
development
code
defect
density
number
tools
methods
used
per
project
however
researchers
note
sample
projects
random
software
project
managers
may
reported
best
projects
cusamano
kemerer
employed
fortran
equivalent
noncomment
source
lines
code
output
measure
27
person
years
effort
input
measure
well
parametric
non
parametric
statistical
test
appropriate
report
software
productivity
appears
surface
greater
japan
differences
observed
found
statistically
significant
studies
productivity
cost
evaluation
jones
27
ibm
among
first
recognize
measures
programming
productivity
quality
terms
lines
code
cost
detecting
removing
code
defects
inherently
paradoxical
paradoxical
lines
code
per
unit
effort
tend
emphasize
longer
rather
efficient
high
quality
programs
similarly
high
level
programming
languages
tend
penalized
compared
assembly
programs
since
modern
programs
may
utilize
fewer
lines
code
assembly
routines
realize
computational
procedure
cost
code
defect
detection
removal
tends
indicate
costs
less
repair
poor
quality
programs
high
quality
programs
thus
jones'
results
undercut
utility
findings
reported
walston
felix
55
subject
paradoxes
alternative
jones
recommends
separating
productivity
measures
work
units
cost
units
program
quality
measured
defect
removal
efficiency
defect
prevention
chrysler
16
sought
identify
basic
determinants
programming
productivity
examining
programming
activities
single
organization
sought
identify
1
characteristics
time
complete
programming
coding
task
can
objectively
measured
task
begun
2
programmer
skill
attributes
related
time
complete
task
definition
programming
task
assumes
program's
specifications
`the
instructions
programmer
regarding
performance
required
program'
must
sufficiently
detailed
incorporate
objective
variables
can
measured
determine
relationships
although
studied
sample
36
cobol
programs
describe
size
account
number
programmers
working
results
similar
kind
albrecht
finding
programming
productivity
can
estimated
primarily
1
programmer
experience
current
computing
facility
2
number
input
files
3
number
input
edits
4
number
procedures
procedure
calls
5
number
input
fields
king
schrems
34
provide
classic
survey
problems
encountered
applying
cost
benefit
analysis
system
development
operation
surprise
`benefits'
identify
represent
commonly
cited
productivity
improvements
authors
observe
system
development
costs
usually
underestimated
difficult
control
productivity
improvements
overestimated
difficult
achieve
observe
cost
benefit
cost
productivity
analysis
can
used
planning
tool
assistance
choosing
among
alternative
technologies
allocating
scarce
resources
among
competing
demands
auditing
tool
performing
post
hoc
evaluations
existing
project
way
develop
`quantitative'
support
order
politically
influence
resource
allocation
decision
problems
describe
include
identifying
measuring
costs
benefits
comparing
cost
benefit
alternatives
cost
accounting
dilemmas
problems
determining
benefits
everyday
organizational
realities
example
two
cost
accounting
measurement
problems
arise
ommission
significant
costs
hidden
costs
omitting
significant
costs
occurs
certain
costs
measured
time
staff
spend
design
review
meetings
effort
required
produce
system
design
documents
hidden
costs
arise
number
ways
often
costs
displaced
either
others
organization
later
time
example
product
marketing
unit
achieves
early
release
software
system
developers
thoroughly
tested
customers
find
partially
defective
suspect
developers
try
accomodate
marketing
unit's
demands
system
testing
plans
undercut
compromised
system
integrity
put
question
developers
point
view
developers
might
later
become
demoralized
productivity
decrease
viewed
others
senior
management
delivering
lower
quality
systems
especially
compared
software
development
groups
demands
marketing
units
king
schrems
also
note
conducting
quality
cost
benefits
direct
costs
well
example
capers
jones
28
reports
software
development
laboratories
ibm
spends
equivalent
5
development
costs
software
measurement
analysis
activities
typically
observes
companies
spend
1
5
3
cost
developing
software
measure
kind
information
ibm
collect
cf
2
3
27
55
therefore
article
king
schrems
can
recommended
background
reading
interested
conducting
software
cost
vs
productivity
analysis
mohanty
44
compared
application
20
software
cost
estimation
models
use
large
system
development
organizations
entered
data
collected
large
software
project
entered
data
20
cost
estimation
models
found
range
costs
estimated
nearly
uniformly
distributed
varying
order
magnitude
led
conclude
almost
model
can
estimate
true
cost
software
degree
accuracy
however
also
conclude
analysis
cost
estimation
model
might
fact
accurate
within
organizational
setting
created
used
although
two
different
models
may
differ
estimate
software
development
costs
much
factor
10
model
may
reflect
cost
accounting
structure
organization
created
means
different
cost
estimation
models
logical
extension
productivity
models
lead
differrent
measured
values
can
show
great
variation
applied
software
development
projects
also
results
kemerer's
30
study
software
cost
estimation
models
corroborates
kind
findings
mohanty`s
study
shows
however
kemerer
go
far
show
function
points
may
refined
improve
reliability
measures
program
size
complexity
31
32
well
tuned
produce
better
cost
estimates
30
function
points
depend
solely
upon
program
source
code
characteristics
address
production
process
production
setting
variations
contributing
effects
romeu
gloss
soler
48
argue
software
productivity
measurement
studies
employ
inappropriate
statistical
analysis
techniques
argue
type
productivity
data
usually
reported
ordinal
data
rather
interval
ratio
data
parametric
statistical
techniques
employed
software
productivity
analysts
inappropriate
ordinal
data
whereas
non
parametric
techniques
appropriate
use
parametric
techniques
ordinal
data
results
apparently
stronger
relationships
correlations
regression
slopes
found
non
parametric
techniques
consequence
studies
productivity
measurement
claiming
statistically
substantiated
relationships
based
inappropriate
analytical
techniques
somewhat
dubious
strength
cited
relationship
may
strong
claimed
boehm
9
reported
productivity
software
development
project
keenly
affected
develops
system
well
organized
managed
team
following
scacchi
50
reviewed
number
published
reports
problems
managing
large
software
engineering
projects
found
surprise
projects
poorly
managed
poorly
organized
productivity
substantially
lower
otherwise
possible
poor
management
can
nullify
potential
productivity
enhancements
attributable
improved
development
technologies
scacchi
identified
number
strategies
managing
software
projects
focus
improving
organization
software
development
work
strategies
identify
conditions
workplace
skills
interests
developers
basis
project
specific
productivity
drivers
example
developers
strong
commitment
project
people
associated
will
productive
work
harder
produce
higher
quality
software
products
commitment
comes
value
developers
expect
find
products
produce
contrast
value
products
working
commitment
will
low
productivity
quality
work
will
lower
appropriate
strategy
focus
organizing
managing
project
cultivate
staff
commitment
project's
objectives
cf
33
developers
strongly
committed
project
team
effort
38
willing
undertake
unplanned
system
maintenance
articulation
work
tasks
needed
sustain
productive
work
conditions
6
7
scacchi
concludes
strategies
managing
software
development
work
overlooked
major
contributor
software
productivity
improvement
thus
require
study
experimentation
boehm
associates
trw
11
described
organization
software
project
whose
objective
develop
environment
enhance
software
productivity
factor
2
5
years
4
10
years
project
began
1981
article
describes
progress
four
years
assembling
software
development
environment
able
support
trw
development
projects
surprisingly
software
environment
contains
many
tools
managing
project
communications
development
documentation
much
gets
delivered
customer
system
documentation
tools
help
develop
customers
receives
improve
customer
satisfaction
thus
project
productivity
however
report
experiences
environment
production
project
report
developers
used
environment
believe
improved
development
productivity
25
40
cf
24
45
nonetheless
report
productivity
improvement
realized
additional
capital
investment
10
000
per
programmer
current
investigations
project
include
development
incorporation
number
knowledge
based
software
development
project
management
aids
additional
lss
productivity
improvements
capers
jones
28
provides
next
study
book
programming
productivity
jones
effective
job
describing
problems
paradoxes
plague
software
productivity
quality
measures
based
upon
previous
studies
27
example
observes
line
source
code
economic
good
frequently
used
software
productivity
measures
lines
code
source
statements
produced
per
unit
time
sound
indicator
economic
productivity
response
identifies
40
software
development
project
variables
can
affect
software
production
major
contribution
work
however
work
without
faults
example
jones
provides
`data'
support
examination
effects
variable
comparable
development
projects
data
lines
source
code
odd
often
rounded
significant
digit
500
10
000
500
000
collected
unnamed
sources
thus
measurements
lack
specificity
data
collection
techniques
lack
sufficient
detail
substantiate
analysis
jones
mentions
relies
upon
data
use
quantitative
software
productivity
quality
reliability
estimation
model
however
discuss
model
works
equations
solves
marked
contrast
boehm's
9
software
cost
productivity
estimation
efforts
identifies
software
project
variables
interest
also
presents
analytical
details
cocomo
software
cost
estimation
model
uses
thus
must
regard
jones's
reported
analysis
suspicion
nonetheless
jones
include
appendix
provides
questionnaire
developed
collecting
data
cost
quality
reliability
model
company
markets
questionnaire
includes
variety
suggestive
questions
people
collecting
productivity
data
may
find
interest
setting
sights
identifying
software
productivity
improvements
opportunities
boehm
10
also
identifies
dilemmas
encountered
defining
things
need
measured
understand
software
productivity
departure
studies
surveyed
previous
section
boehm
observes
software
development
inputs
include
different
life
cycle
development
phases
requiring
different
levels
effort
skill
activities
including
documentation
production
facilities
management
staff
training
quality
assurance
etc
support
personnel
contract
administrators
project
managers
organizational
resources
computing
platforms
communications
facilities
similarly
boehm
observes
measuring
software
development
outputs
solely
terms
attributes
delivered
software
delivered
source
code
statements
poses
number
dilemmas
complex
source
code
statements
complex
combinations
instructions
usually
receive
weight
sequences
simple
statements
determining
whether
count
non
executable
code
reused
code
carriage
returns
code
statements
whether
count
code
pre
post
processing
example
last
item
boehm
reports
putting
compact
ada
program
pretty
printer
frequently
may
triple
number
source
code
lines
even
reviewing
source
code
metrics
boehms
concludes
none
measures
fundamentally
imformative
lines
code
produced
per
unit
time
thus
boehm's
observations
add
weight
conclusion
source
code
statement
line
counts
treated
ordinal
measure
rather
interval
ratio
measure
software
productivity
conclusion
especially
appropriate
comparing
productivity
measures
across
different
studies
comparative
field
study
software
teams
developing
formal
specifications
bendifallah
scacchi
7
found
variation
specification
teamwork
productivity
quality
best
explained
terms
recurring
teamwork
structures
found
six
teamwork
structures
ie
patterns
interaction
recurring
among
teams
study
found
teams
shifted
one
structure
another
either
planned
unplanned
reasons
productive
teams
well
higher
product
quality
teams
clearly
identified
observed
patterns
teamwork
structures
lakhanpal's
38
study
corroborates
finding
showing
workgroup
cohesion
collective
capability
significant
factor
team
productivity
individual
experience
thus
structures
cohesiveness
shifting
patterns
teamwork
also
salient
software
productivity
variables
study
actually
examining
extent
case
tools
may
improve
software
productivity
norman
nunamaker
45
report
software
engineers
surveyed
believed
improve
software
productivity
cf
24
software
engineers
answered
questions
desirability
expected
effectiveness
variety
contemporary
case
mechanisms
methods
norman
nunamaker
found
software
engineers
believe
case
tools
enhance
ability
produce
various
analysis
reports
screen
displays
structured
diagrams
will
greatest
expected
boost
software
development
productivity
data
available
systematically
demonstrates
expected
gains
fact
realized
level
kraut
colleagues
35
report
study
organizational
changes
worker
productivity
quality
work
life
resulting
introduction
large
automated
system
surveyed
opinions
hundreds
system
users
10
different
user
sites
analysis
data
kraut
colleagues
found
system
increased
productivity
certain
classes
users
decreasing
user
classes
also
found
recurring
user
tasks
made
easier
uncommon
user
tasks
reported
difficult
complete
finally
found
distribution
user
task
knowledge
shifted
old
new
loci
within
user
sites
anything
software
development
productivity
introduction
new
software
development
tools
techniques
might
similar
differential
effect
productivity
software
development
task
configuration
locus
development
task
expertise
effect
might
apparent
large
development
organizations
employing
hundreds
thousands
software
developers
rather
small
development
teams
event
kraut
colleagues
observe
one
needs
understand
web
relationships
organization
work
among
tasks
developers
users
well
computing
resources
software
system
designs
order
understand
affects
productivity
quality
work
life
35
last
bhansali
associates
8
report
programmers
two
four
times
productive
using
ada
versus
fortran
pascal
like
languages
according
study
data
however
ada
contains
language
constructs
present
languages
clear
significant
explaining
difference
apparent
productivity
similarly
indicate
whether
source
code
involved
measured
pre
processing
can
affect
source
line
counts
already
observed
10
information
technology
productivity
brynjolfsson
14
provides
comprehensive
review
empirical
studies
examine
relationship
information
technology
productivity
study
broadly
defined
include
particular
kinds
software
systems
transaction
processing
strategic
information
systems
general
purpose
computing
resources
services
accordingly
notes
studies
examine
dollars
spent
different
types
software
systems
compared
overall
profitability
productivity
organizations
invested
furthermore
review
examines
studies
falling
manufacturing
service
sectors
within
us
economy
multiple
economic
sectors
however
none
studies
reviewed
preceding
sections
report
included
review
overall
focus
review
examine
nature
called
`productivity
paradox'
emerged
recent
public
discussions
economic
payoffs
resulting
organizational
investments
short
nature
paradox
indicates
little
measurable
contribution
productivity
organizations
within
economic
sector
national
economy
analysis
identifies
four
issues
account
apparent
productivity
paradox
mismeasurement
inputs
outputs
lags
due
adaptation
learning
effectively
utilize
new
redistribution
profits
payoffs
attributal
mismanagement
within
industrial
organizations
closer
comparative
examination
studies
brynjolfsson
concludes
`the
closer
one
examines
data
behind
studies
performance
looks
like
mismeasurement
core
productivity
paradox
'
14
74
thus
appears
measuring
understanding
productivity
impact
new
software
systems
remains
problematic
one
significant
underlying
cause
found
methods
measuring
productivity
data
summary
software
development
productivity
drivers
generous
though
somewhat
naive
review
preceding
studies
number
software
productivity
drivers
can
identified
generosity
comes
identifying
positive
experiences
results
reported
preceding
studies
naivete
comes
overlooking
fact
many
reported
experiences
results
derived
analytically
restricted
studies
dubious
flawed
analytical
methods
studies
fail
describe
account
variation
productive
ability
among
individual
programmers
systemtically
shown
vary
order
magnitude
19
large
software
systems
500k
code
statements
seems
likely
`average
programmer'
productivity
dominates
individual
variations
smaller
systems
less
50k
code
statements
developed
programmers
individual
differences
may
dominate
nearly
studies
cited
examined
small
systems
extent
nonetheless
take
positivist
view
find
following
attributes
software
application
product
developed
process
developed
setting
develop
contribute
favorably
improving
software
productivity
however
can
neither
reliably
predict
much
productivity
improvement
expected
measure
individual
collective
contribution
attributes
attributes
software
project
facilitate
high
productivity
include
software
development
environment
attributes
fast
turnaround
development
activities
high
bandwidth
processing
throughput
may
require
powerful
greater
capacity
computing
resources
substantial
computing
infrastructure
abundant
computing
resources
easy
access
support
system
specialists
contemporary
software
engineering
tools
techniques
use
design
code
development
aids
rapid
prototyping
tools
application
generators
domain
specific
reusable
software
components
etc
used
produce
incrementally
development
released
software
products
system
development
aids
coordinating
lss
projects
configuration
management
systems
software
testing
tools
documentation
management
systems
electronic
mail
networked
development
systems
etc
programming
languages
constructs
closely
matched
application
domain
concepts
object
oriented
languages
spreadsheet
languages
process
centered
software
development
environments
can
accomodate
multiple
shifting
patterns
small
group
work
structures
software
system
product
attributes
develop
small
medium
complexity
systems
complexity
indicated
size
source
code
delivered
functional
coupling
functional
cohesion
reuse
software
supports
information
processing
tasks
required
application
real
time
distributed
systems
software
developed
minimal
constraints
validation
data
processing
accuracy
security
ease
alteration
stable
system
requirements
specifications
short
development
schedules
minimize
chance
project
circumstances
change
project
staff
attributes
small
well
organized
project
teams
large
teams
organized
small
groups
3
7
experienced
developers
comfortable
working
experienced
software
development
staff
better
already
familiar
application
system
domain
similar
system
development
projects
software
developers
managers
collect
evaluate
software
production
data
rewarded
acknowledged
producing
high
data
value
software
variety
teamwork
structures
patterns
shifts
task
performance
factors
drive
software
costs
apparent
list
productivity
drivers
software
cost
drivers
opposite
productivity
drivers
example
software
without
real
time
performance
produced
productively
lower
cost
comparable
software
real
time
performance
requirements
also
clear
list
always
possible
desirable
achieve
software
productivity
enhancements
project
characteristics
listed
example
purpose
project
convert
operation
real
time
communications
system
one
computer
operating
system
another
computer
operating
system
combination
characteristics
may
apply
favorably
others
inverted
occurring
inhibitors
example
conversion
suggests
high
potential
substantial
reuse
existing
source
code
however
new
code
added
conversion
affects
system's
real
time
performance
spread
throughout
system
productivity
decrease
cost
increase
similarly
conversion
performed
well
organized
team
developers
already
experienced
system
complete
conversion
productively
larger
team
newly
hired
programmers
assigned
responsibility
finally
instead
viewing
software
productivity
improvement
generous
naive
point
view
seek
understand
affects
software
productivity
way
project
managers
developers
find
meaningful
need
approach
fundamentally
different
surveyed
achieve
must
first
articulate
analytical
challenges
must
taken
account
challenge
subject
section
4
also
need
develop
analytical
instruments
tools
allow
us
model
measure
software
production
ways
managers
developers
can
employ
lss
projects
effort
may
lead
us
away
numbers
simple
quantitative
measures
toward
symbolic
qualitative
models
incorporate
nominal
ordinal
interval
ratio
measures
software
production
capacity
accomodate
types
measures
well
within
capabilities
symbol
processing
systems
generally
beyond
strictly
numerical
productivity
models
ultimately
articulate
operational
knowledge
based
model
represents
software
production
process
22
23
40
operational
model
provide
framework
compatible
computational
vehicle
measuring
software
production
well
accomodate
simulations
projects
work
might
happen
certain
project
attributes
altered
subject
section
5
challenges
software
productivity
measurement
order
understand
variables
affect
software
productivity
people
interested
measuring
must
able
answer
following
five
questions
measure
software
productivity
measure
collect
software
productivity
data
measured
measure
software
productivity
improve
software
productivity
purpose
asking
questions
appreciate
complexity
answers
well
see
different
answers
lead
different
software
production
measurement
strategies
unfortunately
begun
see
preceding
section
answers
made
practice
can
lead
undesirable
compromises
analytical
methods
employed
reliability
results
claimed
measure
software
productivity
date
number
reasons
measuring
software
productivity
reported
simplest
terms
idea
identify
measure
reduce
software
development
costs
improve
software
quality
improve
rate
software
developed
practical
terms
includes
alternatives
increase
volume
work
successfully
accomplished
current
staff
effort
accomplish
volume
work
smaller
staff
develop
products
greater
complexity
market
value
staff
workload
avoid
hiring
additional
staff
increase
workload
rationalize
higher
levels
capital
staff
investment
reduce
error
densities
delivered
products
decreasing
amount
time
effort
needed
rectify
software
errors
streamline
downsize
software
production
operations
identify
possible
product
defects
earlier
development
identify
resource
utilization
patterns
discover
production
bottlenecks
underutilized
resources
identify
high
output
responsive
personnel
receive
rewards
identify
low
output
personnel
additional
training
reassignment
clearly
many
reasons
measuring
software
productivity
however
may
desirable
try
accomplish
objectives
single
productivity
measurement
program
example
different
people
involved
large
software
project
may
value
certain
alternatives
others
similarly
alternative
implies
certain
kinds
data
collected
diversity
may
lead
conflicts
measure
software
productivity
turn
may
lead
situation
measured
results
inaccurate
misleading
regarded
suspicion
cf
25
36
thus
productivity
measurement
program
must
carefully
design
avoid
creating
conflicts
mistrust
conditions
mismeasurement
within
software
projects
studied
involving
software
developers
project
managers
design
measurement
instrument
data
collection
feedback
program
can
help
minimize
potential
organizational
problems
well
gain
support
measure
software
productivity
data
choice
collect
report
software
production
data
determined
part
reasons
measuring
productivity
noted
choices
include
programmer
self
report
project
team
manager
outside
analysts
observers
automated
performance
monitors
programmer
manager
self
reported
data
least
costly
collect
although
may
limited
accuracy
however
productivity
measures
used
personnel
evaluation
one
expect
high
reliability
validity
self
reported
data
similarly
productivity
measures
employed
basis
allocating
resources
rewards
data
reporters
will
incentive
improve
reported
production
values
form
hawthorne
effect
whereby
people
seek
accomodate
software
production
behavior
generate
data
values
think
data
evaluators
want
see
instead
want
engender
software
production
measurement
capability
can
feed
back
useful
information
project
managers
developers
form
enhances
knowledge
experience
time
outside
observers
can
often
collect
information
higher
cost
self
report
similarly
automated
production
performance
monitors
may
use
still
emerging
area
technology
requiring
insight
measured
example
irving
associates
25
report
use
automated
performance
monitoring
systems
associated
perceived
increase
productivity
accurate
assessment
worker
performance
higher
levels
organizational
control
however
mechanisms
employed
workers
indicate
managers
overemphasize
quantitative
measures
underemphasize
quality
work
evaluating
worker
performance
workers
also
reported
increased
stress
lower
levels
job
satisfaction
decrease
quality
relationships
peers
managers
ultimately
one
expect
negative
factors
decrease
productivity
increase
staff
turnover
thus
findings
reported
irving
suggest
caution
use
automated
performance
monitors
collecting
high
quality
production
data
providing
ongoing
constructive
feedback
personnel
course
project
thus
longer
term
goal
overall
data
quality
accuracy
issue
self
reported
production
data
sufficient
causal
behavior
organizational
circumstances
need
taken
account
automated
performance
monitors
can
used
similarly
desire
show
measured
improvement
software
productivity
whether
production
improves
self
reported
automated
data
collection
procedures
will
suffice
hand
intent
productivity
measurement
program
ascertain
affects
software
production
alternative
work
arrangements
might
improve
productivity
reliable
accurate
data
must
collected
data
might
best
collected
analysts
observers
vested
interest
particular
measured
outcomes
will
collect
data
used
personnel
evaluation
turn
collected
data
analyzed
results
fed
back
project
developers
managers
form
can
act
upon
might
best
facilitated
involvement
representative
developers
managers
design
data
collection
effort
measured
choices
measure
many
complex
however
clear
focusing
program
product
attributes
lines
code
source
statements
function
points
will
lead
significant
insights
contributing
confounding
effects
software
production
process
production
setting
characteristics
software
productivity
vice
versa
studies
earlier
sections
clearly
indicate
different
lss
product
process
production
setting
characteristics
individually
collectively
affect
software
productivity
however
based
survey
inconsistencies
determining
characteristics
affect
increase
decrease
software
productivity
integrated
productivity
measurement
improvement
strategy
must
account
characteristics
products
processes
settings
delineate
potential
interrelationships
necessary
since
predict
beforehand
constituent
variables
will
reveal
greatest
significance
variance
different
projects
computing
environments
similarly
expect
software
product
process
setting
characteristics
will
need
measured
using
combination
nominal
ordinal
interval
ratio
measures
consider
turn
following
constituents
software
products
production
processes
production
settings
software
products
software
projects
produce
variety
outcomes
source
code
product
valuable
either
individual
developers
project
managers
project
organization
client
therefore
limit
production
measurement
attention
one
product
especially
comparable
effort
committed
producing
closely
related
products
point
since
software
projects
produce
many
products
along
way
interest
focussed
ascertaining
distribution
time
skill
teamwork
value
committed
developing
product
accordingly
can
see
following
kinds
products
resulting
software
development
project
delivered
new
versus
modified
source
statements
successive
software
life
cycle
development
stages
including
automatically
transformed
expanded
software
tools
application
generators
software
development
analyses
knowledge
particular
system
produced
requirements
analysis
specifications
architectural
detailed
designs
test
plans
application
domain
knowledge
knowledge
generated
made
explicit
problem
domain
electronically
switch
large
volume
telephone
message
traffic
computer
control
documents
artifacts
internal
external
reports
system
diagrams
terminal
displays
produced
development
schedule
milestones
development
analyses
user
manuals
system
maintenance
guides
improved
software
development
skills
new
occupational
career
opportunities
project
personnel
new
ways
cooperating
order
develop
software
products
software
production
process
lss
often
produced
multi
stage
process
commonly
understood
terms
system
life
cycle
inception
delivery
sustained
operation
retirement
requirements
frequently
renegotiated
senior
software
engineers
quit
preliminary
architectural
design
modern
software
requirements
specification
design
aids
employed
might
expect
coding
phase
may
show
comparatively
low
productivity
test
integration
show
comparatively
high
cost
however
observe
none
studies
cited
section
3
collected
analyzed
data
addresses
issues
since
production
process
activity
can
produce
valuable
products
conventional
measure
outcome
one
smallest
effort
activities
process
developing
large
software
systems
coding
number
studies
reported
boehm
9
indicate
coding
usually
consumes
10
20
total
lss
development
effort
hand
software
testing
integration
consume
largest
share
usually
representing
50
development
effort
early
development
activities
consume
10
15
clearly
delivered
software
source
code
valuable
product
however
seems
clear
code
production
depends
outcomes
products
activities
precede
general
software
projects
progress
simple
sequential
order
requirements
analysis
specification
design
coding
testing
integration
delivery
however
mean
activities
performed
great
care
management
attention
quite
contrary
although
project
may
organized
managed
produce
requirements
specification
design
documents
according
planned
schedule
actual
course
development
work
difficult
accurately
predict
development
task
breakdowns
rework
common
many
projects
6
7
41
experience
suggests
software
specifications
get
revised
later
design
stages
requirements
change
midway
design
software
testing
reveals
inadequacies
certain
specifications
forth
50
52
events
leads
redoing
previously
accomplished
development
work
life
cycle
development
process
better
understood
simple
linear
process
rather
one
many
possible
paths
can
lead
either
forward
backward
development
cycle
depending
circumstantial
events
arise
project
conditions
precede
follow
occurence
events
want
better
estimate
measure
understand
variables
affect
software
production
throughout
life
cycle
need
delineate
activities
constitute
production
process
can
seek
isolate
tasks
within
activities
can
dramatically
impact
overall
productivity
activities
software
life
cycle
process
examined
include
system
requirements
analysis
frequency
distribution
changes
operational
system
requirements
throughout
duration
project
software
requirements
specifications
possibly
including
rapid
prototypes
number
interrelationship
computational
objects
attributes
relations
operations
central
critical
components
system
kernel
software
architecture
design
complexity
software
architecture
measured
number
interconnections
functional
cohesion
software
modules
together
comparable
measures
project
team
organization
also
measured
frequency
distribution
changes
configuration
software
architecture
team
work
structure
detailed
software
unit
design
time
spent
design
module
given
number
project
staff
participating
amount
existing
reused
system
components
incorporated
system
developed
software
unit
coding
application
generation
time
code
designed
modules
density
discovered
inconsistencies
bugs
found
module's
detailed
design
source
code
unit
testing
integration
system
testing
ratio
time
effort
allocated
versus
actually
spent
testing
effort
spent
repair
detected
errors
density
known
error
types
amount
automated
mechanisms
employed
generate
evaluate
test
case
results
similar
variables
consideration
can
also
articulated
system
development
evolution
activities
including
quality
assurance
configuration
management
preliminary
customer
beta
site
testing
customer
documentation
production
delivery
turnover
sustained
operation
system
evolution
addition
must
also
appreciate
software
production
can
organized
different
modes
manufacture
organization
work
including
ad
hoc
problem
solving
articulation
work
6
7
33
41
project
oriented
job
shop
typical
software
development
projects
50
batched
job
shops
producing
family
small
volume
related
software
products
pipeline
software
production
organized
concurrent
multi
stage
development
staff
specialized
particular
development
crafts
`software
requirement
analysts'
`software
architects'
`coders'
flexible
software
manufacturing
systems
represent
one
view
`software
factory
future'
53
transfer
line
assembly
line
raw
unfinished
information
resources
brought
semi
skilled
software
craftspeople
perform
highly
routinized
limited
fabrication
assembly
tasks
accordingly
characteristics
distinguish
potential
modes
software
production
one
another
values
along
set
dimensions
include
1
developer
skill
requirements
2
ease
productivity
measurement
instrumentation
3
capitalization
4
flexibility
procedures
accomodate
development
anomalies
5
ability
adopt
assimilate
software
innovations
software
production
setting
setting
software
produced
make
difference
productivity
expect
lss
production
say
trw
defense
systems
group
different
mcc
software
technology
program
center
artificial
intelligence
laboratory
mit
data
processing
center
aetna
life
casualty
refinery
software
center
exxon
expect
lss
production
various
development
organization
departments
corporation
different
answer
yes
software
production
settings
differ
number
ways
including
programming
language
use
assembly
fortran
cobol
ada
commonlisp
smalltalk
etc
computing
applications
telecommunications
switch
command
control
ai
research
application
database
management
structural
analysis
signal
processing
refinery
process
control
etc
computers
sun
4
workstations
dec
vax
amdahl
580
cray
mp
symbolics
3670
pc
clone
etc
operating
systems
unix
variants
vax
vms
ibm
vm
zetalisp
ms
dos
etc
differences
host
development
target
end
user
computing
environment
setting
well
computing
server
client
systems
software
development
tools
compilers
editors
application
generators
report
generators
expert
systems
etc
practices
use
hacking
structured
techniques
modular
design
formal
specification
configuration
management
qa
mil
std
2167a
guidelines
etc
personnel
skill
base
number
software
staff
college
degree
degree
non
technical
field
bs
cs
ee
ms
cs
ee
ph
cs
ee
etc
experience
application
area
dependence
outside
organizational
units
system
vendors
marketing
business
analysis
planning
laboratory
directors
change
control
committees
clients
etc
extent
client
participation
experience
similar
application
systems
expectation
sustained
system
support
frequency
history
mid
project
innovations
production
computing
environment
often
new
release
operating
system
processor
memory
upgrade
new
computing
peripherals
introduced
etc
occur
prior
development
projects
frequency
history
troublesome
anomalies
mistakes
arise
prior
system
development
projects
schedule
overshoot
budget
overrun
unexpected
high
staff
turnover
unreliable
new
release
software
etc
measure
software
productivity
measuring
software
productivity
presupposes
ability
construct
measurement
program
comparable
employed
experimental
designs
behavioral
studies
18
necessary
insure
measures
employed
reliable
valid
accurate
repeatable
turn
implies
choices
must
made
respect
following
concerns
productivity
measurement
research
design
sampling
strategy
simply
put
least
three
kinds
choices
research
design
qualitative
case
studies
quantitative
surveys
triangulation
studies
qualitative
case
studies
can
provide
depth
descriptive
knowledge
software
production
work
occurs
sort
problems
arise
studies
usually
one
shot
affairs
low
cost
initiate
employ
open
ended
anthropological
data
collection
strategies
usually
require
outside
analysts
produce
rich
necessarily
generalizable
findings
multiple
comparative
case
studies
much
less
common
require
greater
sustained
field
research
effort
van
den
bosch
associates
13
describe
comparative
qualitative
case
study
designs
studying
software
production
6
7
provide
detailed
examples
quantitative
survey
studies
employ
form
instrumentation
questionnaire
gather
data
manner
well
suited
statistical
analysis
survey
sample
must
carefully
defined
insure
reliable
valid
statistical
results
constrast
qualitative
studies
survey
studies
require
data
analysis
skills
widely
available
supported
automated
statistical
packages
consider
following
scenario
sequence
activities
entailed
preparation
conduct
quantitative
study
develop
productivity
data
collection
instrument
form
questionnaire
pilot
test
revise
initial
instrument
sure
desired
data
can
collected
subjects
modest
effort
implement
data
collection
activity
schedule
plans
follow
first
second
round
non
respondents
never
expect
everyone
will
gladly
cooperate
data
collection
program
validate
`clean'
collected
data
remove
clarify
ambiguous
responses
code
data
analytical
variables
scale
normalize
apply
selected
variables
univariate
analysis
determine
first
order
descriptive
statistics
second
order
variables
factors
analysis
variance
select
apparently
significant
first
second
order
variables
univariate
analysis
multivariate
analysis
partial
correlations
regression
analysis
formulate
analytical
model
apparent
quantitative
relationship
factors
formulate
descriptive
model
analyzed
statistical
phenomenon
substantiate
findings
recommendations
chief
drawback
surveys
usually
capture
description
process
phenomena
provide
low
resolution
indicators
causal
relationships
among
measure
variables
therefore
surveys
best
suited
`snap
shot'
studies
although
multiple
longitudinal
survey
studies
also
possible
costly
less
common
triangulation
studies
attempt
draw
relative
strengths
qualitative
quantative
studies
maximize
analytical
depth
generalizability
robustness
short
triangulation
studies
seek
use
qualitative
field
studies
gain
initial
sensitivity
critical
issues
use
surveys
based
field
studies
identify
frequency
distribution
variables
constitute
issues
larger
population
derive
small
select
sample
projects
work
groups
depth
examination
verification
research
designs
quite
scarce
software
production
measurement
cost
diversity
skills
require
may
just
way
saying
high
quality
results
require
substantial
research
investment
van
den
bosch
associates
13
propose
one
study
design
whose
baseline
cost
estimated
range
1
3
person
years
effort
unit
analysis
concern
deciding
critical
things
study
indicated
section
4
3
multitude
factors
can
potentially
affect
software
productivity
however
clear
factors
simultaneously
affective
instead
influence
may
circumstantial
spread
time
organizational
space
software
products
production
processes
production
setting
characteristics
can
influential
necessarily
time
computing
resources
leads
us
recognize
subject
analysis
software
productivity
life
history
software
project
terms
evolving
products
processes
production
settings
awareness
also
impinges
choice
research
design
sampling
strategy
level
terms
analysis
together
unit
analysis
level
terms
characterize
basis
determining
scope
generalizability
software
productivity
analysis
level
analysis
indicates
whether
resulting
analysis
covers
micro
level
behavior
macro
level
behavior
span
given
unit
analysis
software
productivity
examined
level
individual
programmers
small
work
groups
software
life
cycle
activities
development
organization
company
industry
level
chosen
determines
granularity
data
needed
well
can
aggregated
increase
scope
generalizability
analysis
experience
suggests
analysis
data
collected
across
three
consecutive
levels
provide
strong
results
cf
13
40
41
51
opposed
cited
section
3
typically
employ
one
level
greater
desired
scope
generalizability
carefully
systematic
data
collection
analysis
must
terms
analysis
draw
attention
language
ontology
productivity
analysis
analyst
assuming
unit
levels
analysis
choices
analytical
vocabulary
rationale
use
foreshadows
outcomes
consequences
implied
analysis
analysis
software
productivity
framed
terms
expressing
economic
`costs'
`benefits'
`organizational
impacts
'
however
rationales
commonly
employed
broaden
vocabulary
scope
analysis
example
kling
scacchi
35
observe
least
five
different
kinds
rationale
common
respectively
whose
terms
emphasize
features
underlying
technology
attributes
organization
setting
improving
relations
software
people
management
determining
can
affect
control
benefit
productivity
measurement
effort
addressing
organizational
politics
ongoing
social
interactions
negotiations
characterize
software
production
work
point
diverse
rationales
implied
terms
analysis
recognize
simple
account
can
rendered
completely
describes
affects
software
productivity
particular
setting
instead
might
best
choice
interpret
analysis
terms
rationale
better
identify
rationale
informing
particular
situation
whatever
choice
analysis
will
constrained
terms
built
data
collection
instruments
improve
software
productivity
addressing
question
boehm
10
identifies
number
strategies
improving
software
productivity
get
best
people
make
development
steps
efficient
eliminate
development
steps
eliminate
rework
build
simpler
products
reuse
components
strategies
draw
attention
development
activities
processes
add
value
emerging
software
system
cusumano
20
independently
reports
strategies
regularly
practiced
various
japanese
software
factories
achieve
software
productivity
improvements
however
boehm
indicate
productivity
improvement
opportunities
measured
ascertain
effectiveness
can
anyone
else
state
much
improvement
strategy
combined
strategy
might
realize
clearly
much
needs
explained
order
begin
adequately
answer
question
summary
large
scale
studies
software
productivity
across
multiple
software
projects
many
different
settings
necessitate
collecting
plethora
data
number
diversity
variables
identified
indicate
software
productivity
understood
simply
ratio
amount
source
code
statements
produced
unit
time
instead
understanding
software
productivity
requires
systematic
analysis
variety
types
production
measures
well
interrelationships
suggests
need
robust
theoretical
framework
analytical
methods
support
tools
address
dilemmas
now
apparent
understanding
measuring
software
productivity
alternative
directions
software
productivity
measurement
improvement
need
fundamental
shift
understanding
affects
software
productivity
particular
new
effort
directed
development
knowledge
based
software
productivity
analysis
system
capable
modeling
simulating
production
dynamics
software
project
specific
setting
order
develop
system
appropriate
also
develop
project
specific
theories
software
production
cultivate
software
productivity
drivers
develop
techniques
utilizing
qualitative
symbolic
project
data
develop
setting
specific
theories
software
production
standard
measures
lines
code
produced
represent
data
relatively
easy
collect
however
also
least
useful
informing
understanding
affects
improve
software
productivity
lack
articulated
theory
software
production
report
identifies
number
elements
constituents
theory
principal
include
software
products
processes
give
rise
products
computational
organizational
characteristics
facilitate
inhibit
processes
clearly
developing
theory
basic
research
problem
problem
must
informed
systematic
empirical
examination
current
software
development
projects
practices
theory
used
construct
new
models
hypotheses
measures
account
production
large
software
systems
different
settings
cf
4
18
similarly
models
measures
tuned
better
account
mutual
influence
product
process
setting
characteristics
specific
project
turn
lead
simple
practical
effective
measures
software
production
give
project
managers
developers
source
information
can
use
improve
quality
characteristics
products
processes
settings
identify
cultivate
software
productivity
drivers
apparent
rush
measure
software
productivity
may
lost
sight
fundamental
concern
software
developers
productive
presence
many
technical
organizational
constraints
potential
productivity
improvement
inherent
property
new
software
development
technology
35
instead
people
develop
software
must
effectively
mobilize
transform
whatever
resources
available
construct
software
products
software
developers
must
realize
articulate
potential
productivity
improvement
new
software
development
technologies
can
facilitate
articulation
technological
impediments
organizational
constraints
can
nullify
inhibit
potential
thus
basic
concern
must
identify
cultivate
software
productivity
drivers
whether
drivers
manifest
new
computing
resources
alternative
organizational
work
arrangements
section
3
14
identifies
number
productivity
drivers
weakly
follow
number
software
productivity
measurement
studies
drivers
primarily
represent
technological
resource
alternatives
related
research
50
52
also
identifies
set
project
management
strategies
seek
improve
software
production
alternative
social
organizational
work
arrangements
strategies
identified
research
investigations
practice
software
development
complex
settings
6
7
35
41
52
studies
begining
show
development
project's
organizational
history
idiosyncratic
workplace
incentives
investments
prior
technologies
work
arrangements
local
job
markets
occupational
career
contingencies
organizational
politics
can
dramatically
affect
software
productivity
potential
either
positively
negatively
6
29
35
50
cases
appears
organizational
social
conditions
dominate
productivity
contribution
attributable
place
software
development
technologies
words
certain
circumstances
changing
organization
conditions
work
arrangements
might
far
greater
effect
improving
software
productivity
potential
merely
trying
`fix
things'
installing
new
technology
software
productivity
improvement
will
come
better
software
development
technologies
alone
organizational
project
management
strategies
improve
software
productivity
potential
must
identified
made
explicit
supported
develop
symbolic
qualitative
measures
software
productivity
develop
rich
understanding
software
production
occurs
small
number
representative
software
projects
can
articulate
initial
qualitative
process
model
software
production
incorporates
subjective
impressionistic
data
local
software
development
experts
use
model
data
determine
quantitative
data
collect
basis
refining
evolving
process
model
overall
idea
first
determine
measure
beginning
collect
data
data
easy
collect
lines
code
necessarily
tell
us
anything
lines
code
produced
tools
used
problems
encountered
wrote
code
etc
instead
seek
touch
people
develop
software
since
reasonable
assume
can
identify
beliefs
works
well
situation
enhances
productivity
improves
quality
products
quantitative
data
can
used
substantiate
refute
frequency
distribution
findings
described
qualitative
terms
subsequently
lead
development
family
process
models
accounts
growing
range
scope
software
production
develop
knowledge
based
systems
model
software
production
seek
integrated
approach
capture
make
explicit
empirically
grounded
understanding
software
production
computational
model
model
embody
computational
framework
capturing
describing
applying
knowledge
software
development
projects
carried
managed
22
40
41
42
new
software
process
modelling
technology
form
knowledge
based
systems
emerging
22
23
40
technology
appears
well
suited
support
acquisition
representation
operationalization
qualitative
knowledge
exists
within
software
development
project
readers
interested
specific
realization
approach
consult
40
41
42
however
software
process
engineering
environment
knowledge
engineering
system
capable
modeling
simulating
enacting
software
products
production
processes
production
settings
interrelationships
employed
knowledge
acquisition
can
acquire
knowledge
software
projects
conducting
depth
observational
field
studies
7
ideally
studies
organized
facilitate
comparative
analysis
data
collected
account
concerns
described
section
4
turn
requires
articulation
scheme
data
collection
coding
analysis
focus
directed
gathering
organizing
information
life
history
software
development
project
terms
products
processes
setting
attributes
described
earlier
goal
able
develop
descriptive
model
software
production
analytical
conclusion
can
traced
back
original
data
emerged
subsequently
descriptive
model
must
capture
knowledge
seek
form
can
represented
processed
within
knowledge
based
system
knowledge
representation
area
knowledge
representation
long
active
area
research
field
artificial
intelligence
thus
discussions
topics
approaches
can
get
easily
bogged
debates
implementation
technology
philosophy
like
suffice
say
knowledge
organization
scheme
essential
scheme
must
accomodate
kinds
software
production
data
outlined
section
5
suggestive
starting
point
others
working
schema
representation
language
described
49
utilized
47
software
process
specification
language
spsl
used
40
41
42
example
representation
system
development
projects
scacchi
colleagues
22
23
40
41
42
51
developed
scheme
organizing
representing
knowledge
organizational
settings
resource
arrangements
development
plans
actions
states
schedules
histories
expectations
turn
elaborate
relationships
concepts
using
data
derived
detailed
narrative
descriptions
system
development
projects
6
33
illustrate
approach
ultimately
goal
scheme
representing
knowledge
software
development
projects
facilitate
computational
analysis
simulation
querying
explanation
40
41
knowledge
operationalization
knowledge
base
software
production
projects
provides
initial
basis
developing
operational
model
software
production
knowledge
based
system
requires
1
knowledge
base
storing
facts
hueristics
reasoning
strategies
according
previous
scheme
2
question
answering
subsystem
retrieving
facts
stored
deduced
known
relationships
among
facts
3
simulator
exploring
alternative
trajectories
software
development
projects
suggestive
elaborations
systems
available
22
23
40
47
49
recommended
example
assuming
interesting
knowledge
base
already
stored
question
answering
subsystem
used
answer
queries
following
kinds
1
developer
responsible
particular
action
situation
2
project
development
circumstances
particular
time
schedule
interval
3
particular
circumstance
true
action
done
4
specified
action
performed
5
software
design
task
accomplished
6
certain
document
produced
specific
questions
can
answered
retrieval
knowledge
base
either
direct
retrieval
property
inheritance
inference
rules
22
40
49
simulate
measure
effects
productivity
enhancements
design
knowledge
based
system
simulates
software
production
requires
underlying
computational
model
development
states
actions
plans
schedules
expectations
requirements
histories
order
answer
`what
if'
questions
40
ultimately
operation
simulator
depends
upon
availability
relevant
knowledge
base
facts
hueristics
reasoning
strategies
found
development
projects
consider
following
scenario
simulator
use
developed
acquired
knowledge
based
software
production
simulation
system
kind
outlined
simulator's
user
manager
new
project
particular
setting
wants
determine
acceptable
schedule
project
thus
certain
attributes
affecting
productivity
knowledge
setting
project
yet
incorporated
knowledge
base
user
interacts
simulator
elicit
relevant
attributes
setting
project
schedule
enter
knowledge
base
user
starts
simulation
interactive
question
answering
dialog
simulator
proceed
compare
particular
facts
related
user's
queries
prior
project
knowledge
already
accumulated
knowledge
base
tries
execute
proposed
production
schedule
give
rise
changes
simulated
project
states
actions
sub
schedules
expectations
histories
consistent
inferred
hueristics
reasoning
strategies
simulation
finishes
full
schedule
executed
halt
reaches
state
inhibited
state
reflects
point
project
bottleneck
emerges
example
key
computing
resource
overutilized
precondition
critical
production
step
met
6
7
41
42
analysis
conditions
prevailing
simulated
project
point
helps
user
draw
useful
conclusions
critical
interactions
various
organizational
units
development
groups
computing
resource
arrangements
facilitate
productive
work
simulation
may
redone
different
setting
project
attributes
order
explore
hueristics
improving
productivity
project
ultimately
simulation
embodies
deep
model
software
production
turn
can
substantiated
quantified
data
frequency
distribution
actions
states
etc
arising
different
software
development
projects
approach
approach
developing
knowledge
based
software
productivity
modeling
simultion
system
described
radical
departure
conventional
approaches
understanding
measuring
software
productivity
accordingly
following
sequence
activities
performed
strategy
evaluating
utility
approach
initiate
comparative
case
studies
surveys
current
house
software
production
practices
studies
serve
provide
initial
baseline
data
software
project
products
production
processes
production
setting
characteristics
clean
analyze
collected
data
using
available
skills
tools
provide
statement
baseline
knowledge
apparent
relationships
measured
software
production
variables
preceding
step
correspond
`knowledge
acquisition'
activity
described
codify
subsets
available
software
project
data
knowledge
specification
language
spsl
40
41
42
step
corresponds
initial
realization
`knowledge
representation'
`knowledge
operationalization'
activities
described
demonstrate
results
computational
language
processor
suggested
earlier
40
embed
software
productivity
modeling
simulation
system
within
advanced
case
environment
order
demostrate
integration
access
software
production
guidance
lss
development
efforts
22
23
40
41
42
53
conclusions
affects
software
productivity
improve
report
examines
state
art
measuring
understanding
software
productivity
turn
descries
framework
understanding
software
productivity
identifies
fundamentals
measurement
surveys
selected
studies
software
productivity
survey
helps
identify
recurring
variables
affect
software
productivity
results
analysis
shortcomings
found
many
surveyed
studies
identify
alternative
knowledge
based
approach
research
practice
understanding
affects
software
productivity
approach
builds
upon
recent
advances
modeling
simulating
enacting
software
engineering
processes
situated
within
complex
organizational
settings
also
approach
enables
construction
organizational
knowledge
base
affects
software
productivity
thus
optimistic
potential
developing
knowledge
based
systems
modeling
simulating
reasoning
software
development
projects
new
way
gain
insight
affects
software
productivity
acknowledgements
work
part
usc
system
factory
project
supported
contracts
grants
northrop
corp
office
naval
technology
naval
ocean
system
center
pacific
bell
additional
support
provided
usc
center
operations
management
education
research
usc
center
software
engineering
preparation
initial
version
report
benefited
discussions
suggestions
provided
dave
belanger
chandra
kintala
jerry
schwarz
don
swartout
advanced
software
concepts
department
bell
laboratories
murray
hill
nj
pankaj
garg
abdulaziz
jazzar
peiwei
mi
david
hurley
provided
helpful
comments
subsequent
versions
report
collective
input
people
appreciated
misstated
misrepresented
references
abdel
hamid
madnick
impact
schedule
estimation
software
project
behavior
ieee
software
3
4
1986
70
75
albrecht
`measuring
application
development
productivity'
proc
joint
share
guide
ibm
application
development
symposium
october
1979
83
92
albrecht
gaffney
`software
function
source
lines
code
development
effort
prediction
software
science
validation'
ieee
trans
soft
engr
se
9
6
1983
639
648
bailey
basili
`a
meta
model
software
development
resource
expenditures'
proc
5th
intern
conf
soft
engr
ieee
computer
society
1981
107
116
behrens
`measuring
productivity
computer
systems
development
activities
function
points'
ieee
trans
soft
engr
se
9
6
1983
648
652
bendifallah
scacchi
`understanding
software
maintenance
work'
ieee
trans
soft
engr
se
13
3
1987
311
323
bendifallah
scacchi
`work
structures
shifts
empirical
analysis
software
specification
teamwork'
proc
11th
intern
conf
soft
engr
ieee
computer
society
1989
345
357
bhansali
pflug
taylor
wooley
`ada
technology
current
status
cost
impact'
proceedings
ieee
79
1
1991
22
29
boehm
software
engineering
economics
prentice
hall
englewood
cliffs
nj
1981
boehm
`improving
software
productivity'
computer
20
8
1987
43
58
boehm
penedo
stuckle
williams
pyster
`a
software
development
environment
improving
productivity'
computer
17
6
1984
30
44
boehm
wolverton
`software
cost
modelling
lessons
learned'
systems
software
1
1980
195
201
van
den
bosch
ellis
freeman
johnson
mcclure
robinson
scacchi
scheft
van
staa
tripp
`evaluating
implementation
software
development
life
cycle
methodology'
acm
software
engineering
notes
7
1
1982
45
61
brynjolfsson
`the
productivity
paradox
information
technology
'
communications
acm
36
12
1993
67
77
cerveny
joseph
`a
study
effects
three
commonly
used
software
engineering
strategies
software
enhancement
productivity'
information
management
14
1988
243
251
chrysler
`some
basic
determinants
computer
programming
productivity'
communications
acm
21
6
1978
472
483
conte
dunsmore
shen
software
engineering
models
measures
benjamin
cummings
palo
alto
ca
1986
curtis
`measurement
experimentation
software
engineering'
proc
ieee
68
9
1980
1103
1119
curtis
`substantiating
programmer
variability'
proc
ieee
69
7
1981
cusumano
japan's
software
factories
oxford
univ
press
new
york
1991
cusumano
kemerer
`a
quantitative
analysis
japanese
practice
performance
software
development'
management
science
36
11
1990
1384
1406
garg
mi
pham
scacchi
thunquest
`the
smart
approach
software
process
engineering
'
proc
16th
intern
conf
software
engineering
sorrento
italy
ieee
computer
society
1994
341
350
garg
scacchi
`on
designing
intelligent
software
hypertext
systems'
ieee
expert
4
1989
52
63
hanson
kosinski
`programmer
perceptions
productivity
programming
tools'
communications
acm
28
2
1985
180
189
irving
higgins
safayeni
computerized
performance
monitoring
systems
use
abuse
communications
acm
29
8
1986
794
801
jeffrey
`a
software
development
productivity
model
mis
environments'
systems
soft
7
1987
115
125
jones
`measuring
programming
quality
productivity'
ibm
system
17
1
1978
39
63
jones
programming
productivity
mcgraw
hill
new
york
1986
keen
`information
systems
organizational
change'
communications
acm
24
1
1981
24
33
kemerer
`an
empirical
validation
software
cost
estimation
models'
communications
acm
30
5
1987
416
429
kemerer
`improving
reliability
function
point
measurement
empirical
study
'
ieee
trans
software
engineering
18
11
1992
1011
1024
kemerer
`reliability
function
point
measurement
field
experiment'
communications
acm
36
2
1993
85
97
kidder
soul
new
machine
atlantic
monthly
press
1981
king
schrems
`cost
benefit
analysis
information
systems
development
operation'
acm
computing
surveys
10
1
1978
19
34
kling
scacchi
`the
web
computing
computing
technology
social
organization'
advances
computers
21
1982
3
87
kraut
dumais
koch
`computerization
productivity
quality
work
life'
communications
acm
32
2
1989
220
238
lambert
`a
comparative
study
system
response
time
programmer
development
productivity'
ibm
systems
23
1
1984
36
43
lakhanpal
`understanding
factors
influencing
performance
software
development
groups
exploratory
grou
level
analysis
'
information
software
technology
35
8
1993
468
471
lawrence
`programming
methodology
organizational
environment
programming
productivity'
systems
software
2
1981
257
269
mi
scacchi
`a
knowledge
based
environment
modeling
simulating
software
engineering
processes'
ieee
trans
knowledge
data
engr
2
3
1990
283
294
reprinted
nikkei
artificial
intelligence
20
1
1991
176
191
japanese
mi
scacchi
`modeling
articulation
work
software
engineering
processes
'
proc
1st
intern
conf
software
process
ieee
computer
society
redondo
beach
ca
1991
mi
scacchi
`process
integration
case
environments
'
ieee
software
9
2
may
1992
45
53
reprinted
computer
aided
software
engineering
2nd
edition
chikofsky
ed
ieee
computer
society
1993
mittal
kim
berg
`a
case
study
workstation
usage
early
phases
software
development
life
cycle'
proc
acm
sigsoft
sigplan
software
engineering
symposium
practical
software
development
environments
1986
70
76
mohanty
`software
cost
estimation
present
future'
software
practice
experience
11
1981
103
121
norman
nunamaker
`case
productivity
perceptions
software
engineering
professionals'
communications
acm
32
9
1989
1102
1108
pengelly
norris
higham
`software
process
modelling
measurement
qms
case
study
'
information
software
technology
35
6
7
375
380
reddy
fox
husain
mcroberts
`the
knowledge
based
simulation
system'
ieee
software
3
2
1986
26
37
romeu
gloss
soler
`some
measurement
problems
detected
analysis
software
productivity
data
statistical
significance'
proc
compsac
83
ieee
computer
society
1983
17
24
sathi
fox
greenberg
`representation
activity
knowledge
project
management'
ieee
trans
pattern
analysis
machine
intelligence
7
5
1985
531
552
scacchi
`managing
software
engineering
projects
social
analysis'
ieee
trans
soft
engr
se
10
1
1984
49
59
scacchi
`on
power
domain
specific
hypertext
environments'
amer
soc
info
sci
40
5
1989
scacchi
`designing
software
systems
facilitate
social
organization'
smith
salvendy
eds
work
computers
vol
12a
advances
humans
factors
ergonomics
elsevier
new
york
1989
64
72
scacchi
`the
software
infrastructure
distributed
system
factory'
soft
engr
6
5
september
1991
355
369
thadhani
`factors
affecting
programmer
productivity
application
development'
ibm
systems
23
1
1984
19
35
vosburg
curtis
wolverton
albert
malec
hoben
liu
`productivity
factors
programming
environments'
proc
7th
intern
conf
soft
engr
ieee
computer
society
1984
143
152
walton
felix
`a
method
programming
measurement
estimation'
ibm
systems
16
1
1977
54
65
