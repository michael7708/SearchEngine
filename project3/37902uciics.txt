ics 180 february 2 1999 
forcing progress winning positions 
ics
180
winter
1999
strategy
board
game
programming
lecture
notes
february
2
1999
forcing
progress
winning
positions
game
reaches
point
win
can
forced
alpha
beta
search
will
find
paradoxically
making
winning
move
turn
always
enough
win
game
problem
games
like
checkers
chess
one
can
make
sequence
moves
lead
forced
win
cause
win
get
closer
example
consider
following
chess
position
white
move
can
win
immediately
moving
queen
square
e7
checkmating
black
queen
white
also
moves
win
slowly
fact
one
move
white
can
make
win
instance
suppose
white
moves
king
e6
black's
moves
d8
f8
either
white
still
checkmate
possible
black
moves
d8
white
can
still
win
moving
back
d6
sequence
moves
1
ke6
kd8
2
kd6
ke8
back
started
white
making
winning
moves
making
progress
win
alpha
beta
search
gives
evaluation
winning
position
can
easily
fall
trap
prevent
need
change
evaluation
winning
positions
win
fewer
moves
counted
slightly
better
delayed
win
code
straightforward
keep
variable
ply
denoting
far
current
position
root
search
can
adjust
score
winning
position
subtracting
ply
following
pseudocode
assumes
defined
constant
win
refers
maximum
score
possible
game
chess
typical
value
win
100
1000
times
value
pawn
alpha
beta
search
win
scores
adjusted
ply
int
ply
global
variable
initialized
zero
start
search
int
alphabeta
int
depth
int
alpha
int
beta
game
current
player
won
return
win
ply
else
game
current
player
lost
return
win
ply
else
depth
beta
break
ply
return
alpha
now
example
immediate
checkmate
seen
ply
1
gets
score
999
win
1
moving
king
e8
forces
win
ply
3
score
997
program
will
move
position
maximizing
score
take
immediate
checkmate
games
othello
natural
limit
length
game
move
adds
piece
board
can
64
moves
game
finishes
games
way
get
sort
infinite
loop
can
just
use
score
win
win
without
worrying
ply
adjustment
one
complication
ply
adjustment
trick
interact
hash
table
problem
ply
may
differ
time
store
move
hash
table
time
retrieve
order
make
retrieved
score's
ply
adjustment
correct
store
scores
hash
table
adjusted
relative
current
position
rather
position
root
search
storing
position
hash
table
use
something
like
following
pseudocode
max
ply
constant
defined
greater
maximum
depth
possible
search
win
1000
max
ply
100
might
reasonable
variable
just
index
current
position
hash
table
score
win
max
ply
hash
score
score
ply
else
score
win
max
ply
hash
score
score
ply
else
hash
score
score
retrieving
position
hash
table
opposite
adjustment
needs
made
hash
score
win
max
ply
score
hash
score
ply
else
hash
score
win
max
ply
score
hash
score
ply
else
score
hash
score
david
eppstein
dept
information
computer
science
uc
irvine
