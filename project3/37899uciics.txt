ics 180 april 17 1997 
game tree evaluation 
ics
180a
spring
1997
strategy
board
game
programming
lecture
notes
april
17
1997
minimax
negamax
search
game
trees
game
can
define
rooted
tree
game
tree
nodes
correspond
game
positions
children
node
positions
can
reached
one
move
instance
tic
tac
toe
actually
root
tree
nine
children
left
symmetric
cases
board
configuration
arises
two
different
sequences
moves
create
two
separate
nodes
really
tree
see
later
talk
hashing
take
advantage
duplicated
nodes
speed
search
need
search
one
copy
position
use
search
results
everywhere
else
position
appears
tree
also
assume
players
take
turns
moving
multiple
moves
skipped
turns
complications
can
dealt
treating
entire
sequence
actions
single
player
forming
single
move
finally
assume
tree
finite
dealing
game
can
go
forever
infinitely
many
choices
single
move
three
kinds
nodes
tree
internal
nodes
even
levels
correspond
positions
first
player
move
internal
nodes
odd
levels
correspond
positions
second
player
move
leaves
correspond
positions
game
ended
one
player
won
perhaps
game
drawn
game
tree
evaluation
suppose
internal
node
children
leaves
game
certain
end
one
move
can
assume
player
move
going
pick
best
move
leaf
giving
won
position
will
move
win
leaf
gives
drawn
position
will
move
draw
leaves
give
won
positions
opponent
will
lose
matter
happens
know
game
outcome
nodes
one
level
leaves
know
can
apply
analysis
bottom
determine
correct
outcome
nodes
two
levels
leaves
three
levels
reach
root
tree
node
position
won
player
move
can
find
child
node
giving
won
position
drawn
can
find
child
giving
draw
neither
holds
lost
gives
us
algorithm
playing
games
perfectly
enough
computation
time
reasonable
game
enough
computation
time
trees
big
also
tells
thus
correct
evaluation
function
needs
three
values
win
lose
draw
evaluations
use
computer
game
programs
wider
range
real
number
values
inaccurate
represent
first
player
win
value
1
draw
value
0
second
player
win
value
1
value
internal
node
game
tree
maximum
minimum
children's
values
depending
whether
first
second
player
move
respectively
partial
game
trees
practice
search
algorithms
will
work
expanding
part
game
tree
use
kind
stopping
rule
decide
stop
expanding
tree
certain
internal
nodes
making
leaves
instance
might
stop
sequences
eight
moves
since
game
ended
leaves
guess
likely
one
player
win
using
evaluation
functions
make
assumption
within
nodes
expanded
one
player
will
trying
reach
positions
large
values
evaluation
function
player
will
trying
reach
positions
small
values
players
really
play
way
can
determine
value
leaf
will
reach
min
max
procedure
outlined
compute
value
internal
node
either
maximum
minimum
children's
values
depending
whether
first
second
player
move
respectively
path
leaf
known
principal
variation
basic
principle
minimax
game
search
expand
partial
game
tree
find
principal
variation
make
move
forming
first
step
variation
breadth
first
depth
first
search
negamax
code
described
computation
game
tree
values
breadth
first
compute
values
tree
bottom
single
level
tree
time
instead
can
perform
depth
first
post
order
recursive
traversal
tree
evaluates
node
recursively
evaluating
children
keeping
track
values
seen
far
much
space
efficient
need
store
whole
game
tree
single
path
generally
quite
short
eight
moves
example
stopping
rule
see
next
time
discuss
alpha
beta
search
depth
first
traversal
also
advantage
can
use
information
found
far
help
decide
visit
certain
irrelevant
parts
tree
saving
lot
time
convenient
modify
game
tree
values
slightly
need
maximization
operations
rather
alternate
minima
maxima
odd
levels
tree
nodes
second
player
move
negate
values
defined
node
modified
values
can
found
computing
maximum
negations
node's
children's
values
maybe
will
make
sense
write
source
code
game
tree
search
search
game
tree
given
depth
return
evaluation
root
node
double
negamax
int
depth
depth
0
game
return
eval
pos
else
double
infty
move
available
pos
make
move
max
negamax
depth
1
unmake
move
return
note
finds
evaluation
determine
move
actually
make
need
find
actual
move
root
tree
although
many
programs
return
entire
principal
variation
slightly
modify
search
performed
root
search
game
tree
given
depth
return
evaluation
root
node
move
rootsearch
int
depth
double
infty
move
mm
move
available
pos
make
move
double
em
negamax
depth
1
em
em
mm
unmake
move
return
mm
analysis
negamax
branching
factor
depth
traditionally
one
analyzes
game
tree
algorithms
making
simplifying
assumptions
game
tree
looks
like
assume
internal
node
number
children
number
known
branching
factor
also
assume
search
tree
fixed
depth
algorithm
game
end
early
depth
reached
assumptions
easy
write
formula
amount
time
negamax
program
uses
just
proportional
number
tree
nodes
expanded
may
look
like
multiply
something
since
loop
nested
within
call
negamax
time
spent
loop
can
charged
recursive
calls
made
branching
factor
depth
number
1
2
3
1
1
1
1
stuff
parentheses
end
formula
close
one
overall
time
close
game
meet
strict
assumptions
can
work
backwards
define
effective
branching
factor
whatever
value
works
make
formula
describe
program's
running
time
even
less
formally
use
branching
factor
describe
average
number
moves
available
typical
position
game
can
say
formula
first
exponential
means
able
search
many
nodes
get
computer
twice
fast
old
one
will
able
increase
small
number
levels
second
depends
strongly
branching
factor
game
small
branching
factor
like
checkers
may
often
three
moves
search
can
search
much
deeper
chess
may
30
moves
position
go
hundreds
moves
position
like
small
possible
unfortunately
function
game
working
less
function
well
can
program
however
technique
talk
next
time
alpha
beta
pruning
acts
reduce
effective
branching
factor
considerably
lucky
square
root
value
unpruned
game
trees
lets
us
search
twice
depth
might
without
using
alpha
beta
iterated
deepening
one
question
remains
negamax
code
give
depth
argument
primitive
game
programs
just
set
fixed
number
will
result
lot
variation
amount
time
program
takes
per
move
instead
probably
like
something
chooses
search
depth
based
amount
time
search
will
take
fortunately
exponential
nature
game
search
one
advantage
makes
sort
control
easy
technique
known
iterated
deepening
start
searching
shallowly
repeatedly
increase
depth
run
time
depth
0
enough
time
left
another
level
search
depth
rootsearch
depth
make
move
seems
like
wasting
time
since
last
search
thrown
away
analysis
shows
amount
time
wasted
small
times
different
levels
add
together
like
1
2
formula
already
seen
come
close
last
term
iterated
deepening
cheap
provides
good
time
based
control
also
helpful
ways
can
use
results
shallower
searches
help
choose
order
search
moves
deeper
searches
see
alpha
beta
searching
ordering
critical
fast
searching
david
eppstein
dept
information
computer
science
uc
irvine
wednesday
28
nov
2001
20
59
54
pst
