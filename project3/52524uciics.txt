linked list processing 

linked
list
processing
introduction
computer
science
ii
ics
22
introduction
lecture
will
continue
study
variety
methods
operate
linked
lists
study
methods
carefully
meaning
study
code
hand
simulate
various
empty
small
non
empty
lists
will
increase
understanding
complex
reference
manipulation
start
gain
understanding
write
linked
list
code
first
will
study
various
linked
list
processing
methods
isolation
unspecified
collection
class
instance
variables
end
lecture
will
examine
list
interface
can
implemented
directly
via
arrays
linked
lists
classes
contains
large
number
methods
perform
interesting
manipulations
arrays
lists
like
collection
classes
studied
class
generic
specifies
object
type
value
ln
specifies
int
instance
variable
studying
code
will
bring
us
next
programming
assignment
implement
various
collection
classes
via
linked
lists
including
iterators
will
study
variants
linked
lists
allow
methods
written
compactly
simply
efficiently
include
circular
lists
header
lists
trailer
lists
doubly
linked
lists
often
headers
trailers
although
variants
interesting
linear
linked
lists
simpler
think
often
efficient
code
complex
used
much
often
practice
special
variants
finally
note
linked
lists
implementation
technique
collection
classes
purposes
status
arrays
useful
way
implement
certain
well
specified
state
behavior
will
see
write
even
collection
classes
implemented
via
linked
lists
often
already
seen
collection
classes
implemented
via
arrays
textbooks
describe
linked
lists
special
kind
collection
believe
wrong
perspective
seeing
queues
implemented
via
arrays
linked
lists
will
see
similarity
arrays
linked
lists
implementation
tools
insert
front
rear
already
examined
code
inserting
new
value
front
rear
linked
list
code
inserting
front
trivial
single
statement
using
loops
therefore
1
complexity
class
assume
defining
method
class
stores
front
instance
variable
refering
front
linked
list
first
node
method
written
public
void
insertfront
int
newvalue
front
new
ln
newvalue
front
front
refers
newly
constructed
node
whose
next
instance
variable
refers
original
nodes
list
might
null
linked
list
originally
empty
notice
code
efficient
takes
amount
time
regardless
many
nodes
linked
list
performance
different
arrays
require
loop
shift
values
right
one
index
adding
new
value
front
code
inserting
value
rear
bit
complicated
already
studied
folllowing
code
task
public
void
insertrear
int
newvalue
front
null
front
new
ln
newvalue
null
else
ln
front
next
null
next
next
new
ln
newvalue
null
note
code
else
block
starts
front
list
advances
refers
last
node
list
node
whose
next
null
next
node
changed
refer
non
null
value
new
node
becomes
rear
linked
list
notice
code
efficient
taking
amount
time
proportional
number
nodes
already
linked
list
longer
lists
takes
time
shorter
lists
performance
also
different
arrays
require
constant
amount
time
adding
new
value
rear
unless
course
size
array
double
requires
copying
values
doubling
array
sizes
keep
problem
minimum
without
allocating
much
space
array
soon
fact
saw
insert
many
values
end
list
reading
file
values
linked
list
preserving
order
problem
becomes
bad
declare
extra
cache
variable
always
refer
rear
node
linked
list
located
scanning
front
time
store
reference
front
list
cache
reference
rear
list
can
add
values
front
rear
quickly
advantage
linked
lists
arrays
code
written
public
void
insertrear
int
newvalue
front
null
front
rear
new
ln
newvalue
null
else
rear
rear
next
new
ln
newvalue
null
search
methods
section
will
examine
two
search
methods
first
simpler
makes
assumption
order
values
stored
linked
list
second
builds
first
assumes
values
stored
increasing
order
method
can
return
soon
finds
desired
value
realizes
value
searching
appear
later
list
methods
assume
declared
class
front
instance
variable
processes
still
worst
case
therefore
good
binary
searching
ordered
arrays
log2n
arrays
try
locate
value
return
index
1
value
occur
array
linked
lists
return
null
reference
object
indicate
absence
value
searched
first
search
implemented
simply
follows
public
ln
locate
int
tolocate
ln
front
null
next
value
tolocate
return
return
null
method
either
returns
reference
first
node
storing
tolocate
value
instance
variable
null
parameter's
value
appears
node
linked
list
method
may
traverse
entire
linked
list
value
searching
can
appear
anywhere
values
linked
list
ordered
can
write
slightly
complicated
method
can
efficient
public
ln
locate
int
tolocate
ln
front
null
value
tolocate
next
value
tolocate
return
return
null
terminate
loop
stores
null
value
referred
already
exceeded
tolocate
body
loop
vaue
locate
found
point
still
terminate
entire
method
note
can
use
demorgan's
law
determine
termination
condition
null
value
simplifies
null
value
tolocate
another
way
write
code
put
tolocate
comparisons
inside
loop
leaving
actual
loop
simplified
public
ln
locate
int
tolocate
ln
front
null
next
value
tolocate
return
else
value
tolocate
return
null
return
null
remove
methods
section
will
examine
three
methods
removing
nodes
linked
lists
first
two
specify
value
stored
node
remove
third
specify
reference
directly
node
remove
possibly
found
via
one
previously
discussed
search
methods
three
cases
methods
worst
case
scan
nodes
linked
list
making
complexity
class
methods
assume
declared
class
front
instance
variable
generally
will
special
case
removing
nodes
front
list
removing
nodes
inside
list
will
want
stop
cursor
one
node
one
want
remove
excise
required
node
see
following
picture
details
removing
node
containing
value
7
notice
refers
node
containing
7
node
preceding
first
method
removes
first
occurrence
exists
node
containing
specified
value
many
mutator
methods
need
check
special
case
value
stored
first
node
case
must
alter
front
next
field
later
node
public
void
removefirst
int
toremove
front
null
return
front
value
toremove
front
front
next
else
ln
front
next
null
next
next
value
toremove
next
next
next
return
certainly
thinking
one
ahead
performing
checks
like
next
value
toremove
bit
complicated
another
way
write
method
ghost
reference
keeps
track
let
us
call
value
prev
use
shown
notice
can
drop
front
null
check
needed
verify
hand
simulate
code
front
stores
null
public
void
removefirst
int
toremove
ln
prev
null
front
null
prev
next
value
toremove
prev
null
front
front
next
else
prev
next
next
return
simply
look
value
toremove
go
back
ghost
reference
alter
prev
next
next
following
code
removes
nodes
store
toremove
linked
list
uses
look
ahead
method
contains
two
complicated
loops
first
removes
values
front
list
second
positions
int
list
public
void
removeall
int
toremove
remove
values
front
none
left
return
front
null
return
try
next
loop
front
value
toremove
break
try
next
loop
else
front
front
next
remove
values
inside
assumes
front
empty
ln
front
next
null
body
next
value
toremove
next
next
next
else
next
advance
note
first
loop
removes
nodes
storing
toremove
located
front
linked
list
removing
might
nodes
case
method
returns
executing
second
loop
second
loop
removes
nodes
storing
toremove
front
list
notice
carefully
conditionally
advances
remove
node
remove
node
advance
rechecked
new
node
now
appears
directly
one
refers
try
hand
simulating
method
remove
nodes
containing
5
list
containing
nodes
5
5
1
5
5
5
1
5
1
common
mistake
write
next
loop
header
case
sequential
occurences
value
removed
linked
list
odd
numbered
ones
removed
repetitive
sequence
finally
suppose
reference
node
want
remove
list
may
returned
one
locate
methods
described
previous
sections
can
write
code
follows
note
using
comparison
want
know
whether
reference
refer
object
public
void
remove
ln
reftoremove
front
null
return
front
reftoremove
front
front
next
else
ln
front
next
null
next
next
reftoremove
next
next
next
return
notice
must
terminate
loop
either
next
refers
null
tested
loop
continuation
condition
reftoremove
node
list
also
null
refers
reftoremove
tested
loop
body
case
must
use
operator
references
second
case
excise
required
node
immediately
return
utility
methods
equals
copy
section
will
discuss
two
interesting
utility
methods
first
determines
whether
two
linked
lists
equal
will
define
term
applied
linked
lists
mean
lists
number
nodes
exactly
values
appear
exactly
order
assume
defining
method
collection
class
cc
also
caches
number
nodes
linked
list
storing
values
size
instance
variable
course
always
compute
value
traversing
list
lets
precompute
set
0
constructor
increment
decrement
nodes
added
removed
list
can
write
method
follows
public
boolean
equals
object
return
true
instanceof
cc
return
false
size
cc
size
return
false
lists
size
traverse
check
equality
values
nodes
ln
r1
front
r2
cc
front
r1
null
r1
r1
next
r2
r2
next
r1
value
r2
value
return
false
difference
found
return
true
notice
declaration
loop
declares
intializes
two
cursors
one
declaration
allowed
loops
can
declare
initialize
number
local
variables
one
type
symmetrically
cursor
advanced
iteration
loop
notice
loop's
continuation
condition
just
r1
null
execute
loop
lists
size
replace
r2
null
even
redundant
less
efficient
r1
null
r2
null
lists
size
every
time
r1
null
can
guarantee
r2
null
method
worst
case
nodes
list
must
scanned
method
return
true
next
suppose
want
make
copy
list
means
allocate
number
nodes
containing
values
linked
together
order
calling
equals
copy
always
return
true
simple
slow
complexity
class
n2
way
implement
method
shown
public
cc
copy
cc
answer
new
cc
ln
front
null
next
answer
insertrear
value
return
answer
cursor
traverses
linked
list
inserting
value
finds
end
linked
list
cc
seen
insertrear
method
can
take
lot
time
list
many
nodes
class
cc
supports
reverse
method
faster
version
can
written
follows
public
cc
copy
cc
answer
new
cc
ln
front
null
next
answer
insertfront
value
answer
reverse
return
answer
now
call
insertfront
1
reverse
will
study
next
section
also
inserts
1
followed
reversal
results
complexity
class
can
write
method
using
local
cache
reference
reading
values
file
public
cc
copy
ln
lastcache
null
cc
answer
new
cc
ln
front
null
next
lastcache
null
lastcache
answer
front
new
ln
value
null
else
lastcache
lastcache
next
new
ln
value
null
return
answer
method
meets
required
semantics
copying
even
efficient
previous
method
complicated
write
although
reverse
even
complicated
see
method
uses
caching
pattern
reading
values
files
familiar
permutation
methods
reverse
sort
following
method
reverses
references
linked
list
assume
defining
method
class
stores
front
instance
variable
public
void
reverse
ln
answer
null
front
null
ln
tomove
front
front
front
next
tomove
next
answer
answer
tomove
front
answer
code
definitely
tricky
write
use
time
need
hand
simulation
requirement
scans
list
although
lots
tricky
assignments
inside
loop's
body
finally
sort
linked
list
fastest
way
first
conver
linked
list
array
sort
array
arrays
sort
nlog2n
reconstitute
arrray
back
linked
list
thus
entire
process
nlog2n
dominant
term
code
written
follows
assumes
value
fields
stores
refefence
object
public
void
sort
comparator
object
new
object
length
assume
linked
list
length
cached
ln
front
int
0
length
next
value
arrays
sort
front
int
0
length
next
value
transform
problem
sorting
list
one
know
solve
efficiently
sorting
array
transform
solution
new
problem
sorted
array
solution
original
one
sorted
list
transformation
list
array
array
list
total
complexity
class
nlog2n
just
nlog2n
generally
long
transformations
original
problem
new
one
new
answer
back
original
answer
complexity
class
bigger
complexity
class
solves
new
problem
overall
complexity
class
original
problem
will
complexity
class
new
problem
lots
problems
can
transformed
sorting
complexity
classes
undoing
transformation
bigger
nlog2n
will
complexity
class
solving
problem
special
lists
now
will
study
variants
linked
lists
allow
methods
written
compactly
simply
efficiently
include
circular
lists
header
lists
trailer
lists
doubly
linked
lists
often
headers
trailers
although
variants
interesting
linear
linked
lists
simpler
think
often
efficient
code
complex
used
much
often
practice
special
variants
code
assume
class
ln
declares
private
object
value
instead
using
int
circular
lists
circular
list
linked
list
whose
last
node
refers
first
following
pictures
illustrate
circular
list
containing
one
three
nodes
respectively
one
node
version
especially
interesting
next
field
refers
since
single
node
first
last
code
print
circular
list
bit
intricate
traverse
list
reaching
null
none
stored
circular
list
instead
must
print
first
node
exists
separately
traverse
list
reach
first
node
public
void
print
front
null
return
system
println
front
value
ln
front
next
front
next
system
println
value
hand
simulate
code
ensure
understand
see
attempts
come
compact
code
fails
header
lists
header
list
linked
list
always
contains
special
header
node
empty
header
list
contains
just
one
node
node
stores
data
value
field
always
stores
null
exists
solely
simplify
code
processes
linked
lists
ensuring
every
real
node
linked
list
preceded
node
guarantee
allows
us
never
change
front
refers
always
refers
header
therefore
need
special
case
code
handle
now
impossible
option
following
pictures
illustrate
empty
header
list
one
containing
three
string
values
fact
can
declare
final
front
new
ln
null
null
front
will
always
refer
node
header
java
compiler
ensures
every
change
value
compare
original
code
written
remove
value
list
code
works
header
lists
public
void
removefirst
object
toremove
ln
front
next
null
next
toremove
equals
next
value
next
next
next
return
hand
simualate
code
ensure
understand
notice
code
includes
special
tests
concerning
front
instead
includes
looping
code
assumes
toremove
can
reached
following
next
field
preceding
node
even
real
first
node
predecessor
header
node
likewise
code
removeall
header
list
simplified
well
public
void
removeall
int
toremove
ln
front
next
null
body
toremove
equals
next
value
next
next
next
else
next
advance
code
now
looks
much
like
removefirst
now
loop
runs
completion
explicit
return
inside
loop
special
way
advance
depending
whether
node
removed
course
takes
bit
space
store
header
list
always
contains
one
extra
node
always
just
two
words
memory
also
although
methods
can
written
simply
header
lists
others
length
can
complicated
take
big
longer
execute
must
skip
header
node
trailer
lists
trailer
list
linked
list
always
contains
special
trailer
node
empty
trailer
list
contains
just
one
node
header
node
node
stores
data
value
field
always
stores
null
exists
solely
simplify
code
processes
linked
lists
ensuring
every
real
node
linked
list
followed
node
following
pictures
illustrate
empty
trailer
list
one
containing
three
string
values
although
generally
less
useful
header
list
one
useful
operation
can
perform
quickly
trailer
list
removing
node
already
reference
note
node
will
never
trailer
will
always
node
inside
list
coming
trailer
compare
original
code
written
remove
node
given
reference
list
code
works
trailer
lists
original
code
code
1
needs
looping
removes
node
actually
shifting
forward
value
node
following
always
node
trailer
lists
excising
followig
node
whose
data
now
redundant
public
void
remove
ln
reftoremove
reftoremove
value
reftoremove
next
value
reftoremove
next
reftoremove
next
next
hand
simualate
code
ensure
understand
sometimes
useful
combine
header
trailer
nodes
one
list
allowing
simple
methods
simple
header
lists
simple
trailer
list
written
simply
following
pictures
illustrate
empty
header
trailer
list
one
containing
three
string
values
three
remove
methods
written
operate
correctly
header
trailer
list
doubly
linked
lists
doubly
linked
list
non
linear
linked
list
contains
reference
node
comes
linked
list
define
doubly
linked
node
dln
public
class
dln
public
dln
dln
object
dln
prev
value
next
public
dln
prev
next
public
object
value
following
pictures
illustrate
doubly
linked
list
containing
three
string
values
notice
prev
reference
first
node
next
reference
last
node
store
null
respectively
node
precedes
follows
end
ones
can
traverse
nodes
doubly
linked
lists
directions
forward
backward
methods
alter
doubly
linked
lists
often
requires
twice
much
overhead
node
now
refers
two
others
one
lists
occupy
50
space
simple
linear
linked
lists
3
words
memory
2
following
method
illustrates
remove
node
doubly
linked
list
public
void
remove
dln
reftoremove
front
reftoremove
front
reftoremove
next
else
reftoremove
prev
next
reftoremove
next
reftoremove
next
null
reftoremove
next
prev
reftoremove
prev
often
useful
include
header
trailer
nodes
doubly
linked
lists
ensures
every
real
node
predecessor
successor
following
pictures
illustrate
doubly
linked
list
containing
three
string
values
doubly
linked
lists
header
trailer
nodes
can
simplify
remove
code
public
void
remove
dln
reftoremove
reftoremove
prev
next
reftoremove
next
reftoremove
next
prev
reftoremove
prev
note
front
will
never
equal
reftoremove
header
node
likewise
reftoremove
next
will
never
equal
null
trailer
create
empty
doubly
linked
header
trailer
list
requires
following
code
front
new
dln
null
null
new
dln
null
null
null
front
next
prev
front
bit
convoluted
finally
can
also
define
circular
doubly
linked
lists
circular
doubly
linked
lists
contain
header
trailer
nodes
smallest
lists
contains
two
nodes
linked
ways
circularly
overhead
extra
complexity
special
linked
lists
make
less
useful
simple
linear
linked
lists
problem
set
ensure
understand
material
lecture
please
solve
announced
problems
read
lecture
get
stumped
problem
go
back
read
relevant
part
lecture
still
questions
please
get
help
instructor
ta
student
hand
simulate
methods
discussed
lecture
empty
lists
various
small
non
empty
lists
rewrite
removeall
method
use
ghost
references
hand
simulate
various
list
various
values
repeated
suppose
last
node
circularly
linked
list
referred
previous
node
first
one
happen
print
method
written
rewrite
linkedqueue
iterator
support
remove
method
hint
use
ghost
reference
