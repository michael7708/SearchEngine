ics 23 cse 23 project 2 end game 
project 2 end game 
ics
23
cse
23
project
2
end
game
due
date
time
friday
october
24
6
59pm
introduction
kalah
one
family
african
games
played
since
ancient
times
project
will
develop
portions
program
plays
one
version
kalah
provided
user
interface
majority
game
logic
code
implements
rules
game
will
write
search
strategy
routines
will
allow
program
play
game
rules
game
game
kalah
played
board
looks
like
two
players
refer
top
player
bottom
player
player
six
holes
side
board
one
pot
right
kalah
picture
hole
far
left
top
player's
pot
hole
far
right
bottom
player's
pot
game
typically
begins
six
beans
hole
players
take
turns
moving
move
begins
player
picking
beans
one
holes
proceeding
counterclockwise
puts
one
bean
hole
opponent's
pot
reach
picked
beans
dispersed
opponent's
pot
encountered
move
skipped
depending
upon
last
bean
placed
one
three
things
occurs
last
bean
placed
player's
pot
takes
another
turn
last
bean
placed
one
current
player's
holes
hole
empty
opponent's
hole
directly
across
hole
empty
beans
opponent's
hole
player's
hole
placed
player's
pot
turn
ends
cases
turn
ends
whenever
turn
ends
holes
one
side
board
empty
game
beans
non
empty
side
board
placed
player's
pot
goes
side
board
instance
turn
ended
top
player's
holes
empty
remaining
beans
go
bottom
player's
pot
player
beans
pot
end
game
winner
sure
know
play
game
attempting
complete
program
will
save
much
time
effort
provided
program
will
already
play
game
kalah
two
human
players
allow
play
computer
player
create
ai
class
write
necessary
code
kalahaifactory
class
described
later
write
starting
point
code
need
complete
project
included
zip
archive
much
code
provided
compiled
class
form
provided
java
files
heavily
commented
need
work
two
classes
first
need
create
new
class
implements
provided
kalahai
interface
class
needs
named
certain
way
specifically
need
include
student
id
name
class
student
id
12345678
class
called
kalahai12345678
important
created
ai
class
also
need
write
one
line
code
kalahaifactory
class
comments
class
will
explain
need
everything
else
left
run
program
kalah
class
contains
main
method
run
program
execute
kalah
class
provided
gui
simple
straightforward
use
run
kalah
window
will
appear
status
messages
blank
kalah
board
game
menu
menu
two
choices
new
exit
exit
course
exits
game
new
brings
dialog
box
can
choose
whether
top
bottom
players
human
computer
controlled
number
holes
per
player
number
beans
hole
game's
start
speed
gui
animates
move
clicking
ok
starts
game
human
controlled
player
makes
move
double
clicking
hole
allowed
move
beans
computer
simply
moves
turn
make
beans
yellow
move
can
see
moves
action
move
beans
returned
normal
brown
color
status
messages
remind
whose
move
let
know
tried
something
illegal
moving
beans
opponent's
hole
can
exit
game
well
start
new
game
time
necessary
terminology
will
building
rudimentary
artificial
intelligence
ai
computer
can
play
game
kalah
another
instance
artificial
intelligence
task
project
fairly
narrow
can
disregard
vast
majority
code
gave
implements
either
gui
game
logic
fact
code
provided
compiled
class
form
rather
source
code
reason
three
main
abstractions
need
understand
order
write
code
required
project
consider
holes
board
call
holes
positions
notion
position
encapsulated
interface
called
position
can
uniquely
describe
hole
board
noting
whether
belongs
top
player
bottom
player
specifying
hole
number
hole
top
bottom
row
holes
numbered
starting
1
lefthand
side
board
shown
gui
pots
given
special
hole
number
indicated
constant
position
pot
ai
analyzes
possibilities
will
necessary
evaluate
current
game
situation
collectively
call
description
current
situation
game
state
tersely
state
game
state
comprised
number
beans
position
flag
indicating
whether
currently
top
bottom
player's
turn
flag
indicating
whether
game
ended
notion
game
state
encapsulated
gamestate
interface
since
possible
two
ai's
playing
makes
sense
encapsulate
ai
class
two
objects
class
created
play
one
another
implement
ai
class
implements
provided
kalahai
interface
consists
method
called
choosemove
analyzes
possibilities
picks
ai's
next
move
since
move
constitutes
picking
beans
particular
position
choosemove
returns
position
remember
name
ai
class
appropriately
described
student
id
12345678
name
ai
class
kalahai12345678
game
trees
can
think
possible
game
states
arranged
conceptually
kind
search
tree
called
game
tree
node
tree
contains
particular
game
state
children
game
states
can
result
making
valid
move
state
root
tree
initial
game
state
kalah
game
first
move
made
children
initial
state
possible
states
can
arise
top
player
making
valid
opening
move
since
top
player
goes
first
six
states
corresponding
moving
beans
top
player's
six
holes
moves
illegal
considered
partial
look
kalah
game
tree
picture
initial
state
six
possibilities
top
player
may
choose
move
one
choice
3
picture
indicates
four
choices
bottom
player
will
pictured
choices
top
player
can
make
result
bottom
player's
choices
surprisingly
game
tree
can
grow
large
rather
quickly
call
leaves
game
tree
final
states
leaves
indicate
states
one
player
won
game
exhaustively
searching
possibilities
time
player
wants
pick
move
wants
pick
one
will
lead
winning
game
state
can
determine
best
move
three
steps
apply
evaluation
function
final
game
state
evaluation
function
typically
returns
number
higher
numbers
considered
better
identify
final
state
highest
value
end
game
like
occur
best
win
us
determine
path
current
game
state
final
state
chose
make
move
takes
us
current
game
state
path
toward
chosen
final
state
assuming
complete
game
tree
disposal
simple
approach
implement
however
practical
limitations
make
approach
impossible
first
number
game
states
level
tree
grows
exponentially
work
way
tree
since
many
six
possible
moves
can
taken
particular
game
state
simply
enough
memory
store
entire
game
tree
can
imagine
build
game
tree
20
levels
deep
six
possible
moves
can
made
particular
state
number
nodes
tree
620
1
roughly
equivalent
3x1015
besides
even
enough
memory
available
store
tree
processing
time
create
entire
game
tree
prohibitive
need
find
compromise
approach
perhaps
always
find
best
possible
outcome
makes
decision
reasonable
amount
time
using
reasonable
amount
memory
heuristic
search
study
artificial
intelligence
much
say
good
ways
search
toward
goal
impractical
check
possible
paths
toward
can
first
make
use
following
observation
suppose
top
player
made
move
game
bottom
player
wants
figure
best
move
make
using
search
tree
approach
discussing
bottom
player
need
concern
subtree
current
game
state
root
move
made
moves
made
can
ignored
now
possible
take
paths
tree
thus
analyzing
next
move
make
need
generate
part
search
tree
originates
current
game
state
approach
reduces
storage
needs
significantly
waste
time
memory
processing
parts
tree
can
longer
reach
even
generate
part
tree
need
part
may
still
much
large
store
heuristic
search
comes
play
heuristic
search
generate
much
relevant
subtree
practical
using
resulting
game
states
guide
us
selecting
move
hope
will
best
several
strategies
use
heart
strategy
use
notion
evaluation
function
discussed
earlier
need
rate
particular
game
state
way
can
decide
large
number
game
states
best
outcome
us
simple
approach
following
eval
state
beans
pot
state
beans
opponent's
pot
also
important
note
need
actually
build
game
tree
memory
algorithm
will
perform
sort
depth
first
search
game
tree
meaning
can
use
parameters
recursive
method
stored
run
time
stack
perform
search
negating
need
actually
build
store
game
tree
will
dramatically
reduce
amount
memory
needed
choose
move
since
one
path
tree
will
ever
need
stored
run
time
stack
time
putting
ideas
together
can
develop
search
algorithm
will
look
move
leads
game
state
evaluates
highest
value
algorithm
looks
something
like
int
search
gamestate
int
depth
depth
0
return
evaluation
else
turn
move
valid
move
can
make
make
move
yielding
state
s'
search
s'
depth
1
return
maximum
value
returned
recursive
search
calls
else
valid
move
opponent
can
make
make
move
yielding
state
s'
search
s'
depth
1
return
minimum
value
returned
recursive
search
calls
couple
things
need
discuss
algorithm
first
notice
two
cases
recursion
either
computer
player's
turn
currently
making
decision
opponent's
turn
case
algorithm
almost
except
computer
player's
turn
maximum
value
returned
words
computer
player
wants
make
best
possible
move
can
opponent's
turn
minimum
value
returned
assumed
opponent
will
also
make
move
best
interest
worst
interest
may
assume
computer
player
will
always
top
bottom
player
top
bottom
player
might
computer
player
deciding
whether
turn
opponent's
turn
exercise
caution
ensure
making
right
decision
second
notice
depth
parameter
will
used
limit
depth
search
make
sure
search
manageable
length
time
recurse
one
level
deeper
depth
reduced
one
stop
recursing
reaches
zero
thirdly
observe
top
player
makes
move
necessarily
case
bottom
player
will
making
next
move
care
must
taken
deciding
whose
turn
easiest
way
deal
problem
let
current
game
state
keep
track
lastly
note
algorithm
returns
evaluation
best
state
best
state
need
exercise
care
actually
implementing
algorithm
will
able
actually
choose
move
deliverables
need
turn
java
source
code
kalahaixxxxxxxx
class
xxxxxxxx
student
id
kalahaifactory
class
new
classes
developed
expect
write
new
classes
need
submit
since
ai
class
expected
work
correctly
provided
code
left
turn
code
additional
work
advanced
students
win
instead
heuristic
search
used
winner
tournament
typically
will
someone
writes
searches
use
heuristic
techniques
perhaps
ones
take
completely
different
approach
searching
game
tree
try
approaches
see
well
perform
relative
depth
first
search
approach
used
used
instance
approach
called
alpha
beta
pruning
essence
smarter
depth
first
search
good
alternative
technique
employ
try
googling
alpha
beta
pruning
evaluation
function
may
always
may
even
never
best
use
move
puts
beans
pot
now
might
set
board
opponent
later
obtain
larger
quantity
beans
perhaps
another
move
left
board
opponent
poor
position
remember
goal
obtain
beans
obtain
beans
opponent
modify
evaluation
function
write
several
can
swap
program
see
human
computer
player
evaluation
function
gave
source
code
requirements
modified
alex
thornton
allow
tournament
spring
2003
heavily
modified
alex
thornton
fall
2002
written
ics
23
summer
2002
norman
jacobson
influenced
three
previous
lab
assignments
cyberthello
alex
thornton
spring
2001
game
kalah
david
kay
assistance
david
smallberg
cyberkalah
norman
jacobson
summer
2002
source
code
originally
written
alex
thornton
summer
2002
modifications
fall
2002
spring
2003
tournament
code
written
dan
frost
norm
jacobson
