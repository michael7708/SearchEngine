bucket radix sorting 
integer string sorting 
ics
161
design
analysis
algorithms
lecture
notes
january
23
1996
bucket
sorting
seen
various
algorithms
sorting
log
time
lower
bound
showing
log
optimal
lower
bound
applies
comparison
sorting
allowed
operations
comparisons
results
will
depend
specific
data
type
want
sort
typical
types
might
integer
floating
point
character
string
start
really
simple
example
want
sort
integers
range
1
two
quickly
can
determine
sorted
order
answer
1
without
even
computing
anything
know
1
2
3
1
less
stupid
example
suppose
numbers
still
range
1
might
duplicates
can
use
array
count
many
copies
number
sort
int
int
1
0
0
0
0
0
0
three
loops
take
time
go
back
time
instead
counting
comparisons
since
algorithm
doesnt
use
comparisons
one
completely
obvious
point
one
loops
nested
normally
see
collection
nested
loops
time
bound
product
number
iterations
loop
nested
loop
rather
2
answer
possible
inner
loop
execute
many
times
iterations
outer
loop
easiest
way
see
match
times
increment
array
entries
times
decrement
since
increments
also
decrements
algorithm
already
close
useful
less
likely
want
sort
numbers
exactly
likely
want
sort
records
number
derived
example
maybe
data
uci
phone
book
want
sort
entries
phone
number
useful
sort
just
phone
numbers
want
still
know
name
goes
number
suppose
list
records
key
number
1
generalize
problem
little
necessarily
equal
can
solve
making
array
linked
lists
move
input
record
list
appropriate
position
array
concatenate
lists
together
order
bucket
sort
list
1
0
empty
nonempty
let
first
record
move
key
0
concatenate
onto
end
two
loops
taking
time
one
taking
total
time
good
smaller
suppose
want
sort
10000
people
birthday
10000
366
time
stability
say
sorting
algorithm
stable
two
records
key
stay
original
order
property
will
important
extending
bucket
sort
algorithm
works
well
large
first
algorithms
seen
stable
bucket
sort
yes
add
items
lists
order
concatenating
preserves
order
heap
sort
act
placing
objects
heap
heapifying
destroys
initial
ordering
might
merge
sort
maybe
depends
divide
lists
two
merge
instance
divide
choosing
every
element
go
list
unlikely
stable
divide
splitting
list
midpoint
break
ties
merging
favor
first
list
algorithm
can
stable
quick
sort
maybe
depends
partition
step
comparison
sorting
algorithm
can
made
stable
modifying
comparisons
break
ties
according
original
positions
objects
algorithms
automatically
stable
radix
sort
large
think
decimal
representation
number
10
100
1000
etc
range
0
9
digits
easily
small
enough
bucket
sort
radix
sort
bucket
sort
bucket
sort
bucket
sort
simply
radix
sort
key
nonzero
bucket
sort
keys
mod
10
keys
keys
10
possibly
strange
part
sort
least
important
digit
first
matter
one
bucket
sort
since
last
one
one
puts
everything
place
answer
trying
sort
things
hand
tend
something
different
first
bucket
sort
recursively
sort
values
sharing
common
first
digit
works
less
efficient
since
splits
problem
many
subproblems
contrast
radix
sorting
never
splits
list
just
applies
bucket
sorting
several
times
list
radix
sorting
last
pass
bucket
sorting
one
effect
overall
order
want
one
using
important
digits
previous
bucket
sorting
passes
used
take
care
case
two
items
key
mod
10
last
pass
correctness
prove
algorithm
correct
induction
induction
hypothesis
steps
numbers
sorted
key
modulo
10
certainly
steps
numbers
modulo
1
therefore
sorted
value
base
case
true
inductively
step
1
sorts
key
10
two
numbers
value
key
10
stability
property
bucket
sorting
leaves
sorted
lower
order
digits
value
bucket
sort
step
1
puts
right
order
either
case
induction
hypothesis
holds
sufficiently
large
taking
keys
mod
10
change
point
list
sorted
analysis
algorithm
takes
time
per
bucket
sort
log
10
log
bucket
sorts
total
time
log
ever
best
algorithm
use
answer
smaller
takes
log
bucket
sort
takes
larger
log
taken
method
worse
log
taken
comparison
sorting
can
make
better
answer
use
decimal
notation
multiplication
division
expensive
better
use
base
power
2
saves
constant
factor
easy
optimization
importantly
10
small
can
increase
base
large
without
increasing
bucket
sort
times
significantly
use
base
notation
base
power
2
close
get
time
bounds
form
1
log
log
example
sorting
million
32
bit
numbers
use
2
16
roughly
64000
base
use
number
place
10
radix
sorting
pseudocode
two
loops
minuscule
fraction
total
time
per
bucket
sort
need
two
bucket
sorting
passes
solve
problem
complicated
methods
one
can
make
integer
sorting
algorithms
bounds
loglog
log
log
log
less
practical
interest
good
enormously
greater
sorting
floating
point
numbers
floating
point
represents
numbers
roughly
form
2
numbers
value
just
bucket
sort
different
b's
complicate
picture
basically
important
sort
first
radix
sort
one
bucket
sort
sorting
character
strings
essentially
alphabetical
order
different
base
26
representation
numbers
sorting
ascii
character
value
different
base
256
representation
usual
first
character
important
therefore
one
want
save
last
can
just
work
backwards
strings
bucket
sorts
character
values
position
details
involved
applying
idea
get
quick
algorithm
strings
different
lengths
always
exist
character
position
can
test
string's
length
use
character
value
0
string
short
since
come
aardvark
one
way
think
just
pad
strings
null
characters
make
length
however
padding
idea
can
significantly
increase
size
strings
words
makes
sorting
algorithm
based
slow
strings
short
one
length
time
will
2
even
though
input
length
idea
using
radix
sort
strings
end
better
bad
comparison
sort
algorithm
problem
sort
strings
i'th
character
values
wasting
lot
work
sorting
strings
shorter
one
possible
solution
bucket
sort
sort
strings
longer
length
find
list
long
strings
can
another
call
bucket
sorting
just
sort
strings
lengths
still
remains
subtle
problem
approach
recall
bucket
sort
efficient
early
passes
radix
sort
algorithm
sorting
really
long
strings
may
bucket
sorts
may
efficient
solution
use
array
buckets
radix
sort
pass
putting
things
buckets
distribute
still
fast
concatenating
nonempty
buckets
coalesce
also
still
fast
slowdown
comes
finding
nonempty
buckets
make
list
buckets
will
nonempty
using
bucket
sorting
yet
third
way
sort
pairs
string
two
bucket
sorts
buckets
second
bucket
sort
give
sorted
list
characters
position
strings
tells
us
buckets
will
nonempty
radix
sort
part
algorithm
getting
pretty
complicated
confusing
bad
express
pseudocode
string
sort
make
list
pairs
str
bucket
sort
pairs
str
bucket
sort
pairs
giving
lists
chars
bucket
sort
strings
length
max
length
empty
0
concatenate
strings
length
start
distribute
buckets
chars
position
coalesce
concatenating
buckets
chars
concatenate
list
empty
strings
start
return
time
first
three
bucket
sorts
remaining
pass
takes
time
number
strings
character
position
total
time
loop
overall
algorithm's
total
time
total
length
strings
number
character
values
ics
161
dept
information
computer
science
uc
irvine
last
update
02
may
2000
20
24
49
pdt
