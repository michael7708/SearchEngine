collection classes final issues hash tables 

collection
classes
final
issues
hash
tables
introduction
computer
science
ii
ics
22
introduction
lecture
will
cover
remaining
topics
useful
know
dealing
collection
classes
java
first
will
examine
class
named
collections
plural
interface
named
collection
like
arrays
class
provides
many
useful
static
methods
operate
collections
take
collections
parameters
second
will
briefly
discuss
hashing
will
learn
just
enough
can
get
general
feel
works
principle
operations
1
mutate
hashed
value
etc
will
examine
various
classes
write
hashcode
methods
discuss
write
method
classes
finally
will
briefly
examine
java
1
5's
mechanism
writing
generic
collections
avoid
casting
compiler
check
things
running
programs
mechanism
powerful
simple
cases
straightforwardly
useful
beyond
use
interesting
can
become
much
subtle
next
lecture
note
covers
topic
detail
collections
class
collections
class
library
various
useful
static
methods
collection
classes
implementing
collection
singular
interface
subinterfaces
parameters
javadoc
summary
methods
appears
discussed
next
take
look
static
methods
provided
first
min
method
can
passed
collection
comparator
computes
minimum
value
collection
according
comparator
actual
code
shown
public
static
object
min
collection
coll
comparator
comp
comp
null
min
coll
overloaded
method
discussed
iterator
coll
iterator
object
candidate
next
hasnext
object
next
next
comp
compare
next
candidate
0
candidate
next
return
candidate
iterates
collection
looking
every
value
complexity
class
remembering
smallest
value
examines
argued
following
code
added
declaration
iterator
coll
size
0
return
null
values
collection
return
null
reference
value
instead
code
written
throw
nosuchelementexception
next
called
initialize
candidate
certainly
reasonable
element
smallest
elements
along
min
matching
declaration
max
another
binarysearch
take
kind
collection
list
case
binarysearch
comparator
binarysearch
method
passed
list
object
search
comparator
assumes
list
sorted
increasing
order
according
comparator
performs
binary
search
actually
method
uses
compute
answer
depends
whether
concrete
class
implementing
list
also
implements
randomaccess
interface
defines
methods
interface
called
tagging
interface
sole
purpose
classes
say
whether
implements
interface
class
can
tagging
interface
defines
methods
prey
subclass
program
6
tagging
interface
ball
floater
declared
implemented
interface
black
holes
ask
objects
instanceof
prey
list
collection
implementing
interface
declaring
time
perform
get
set
methods
list
1
standard
java
collection
classes
arraylist
class
linkedlist
will
study
soon
higher
index
get
set
longer
takes
perform
method
binarysearch
method
checks
whether
list
asked
search
instanceof
randomaccess
calls
method
lots
gets
calls
method
taht
uses
iterates
forward
backward
homing
value
search
overloaded
versions
min
max
binarysearch
exclude
comparator
parameter
fact
one
called
min
method
comparator
null
method
assumes
objects
list
natural
ordering
implement
comparable
interface
interface
similar
different
comparator
javadoc
comparable
interface
shown
class
implements
comparable
objects
knows
compare
objects
called
natural
ordering
class
example
string
implements
comparable
wrapper
classes
standard
lexical
dictionary
ordering
thus
collection
strings
call
just
collections
min
return
smallest
string
according
natural
ordering
course
use
simpler
method
answer
can
returned
way
java
can
compare
strings
compareto
method
built
string
class
using
version
parameter
specifying
object
constructed
class
implents
comparator
allows
us
much
flexibility
compare
strings
determine
one
smallest
reason
think
comparator
interface
important
comparable
interface
used
frequently
java
one
dominant
natural
ordering
objects
declare
class
implements
comparable
provide
compareto
method
implements
ordering
might
see
something
like
comparable
specifies
array
objects
come
classes
implement
comparable
interface
finally
code
inside
min
max
binarysearch
casts
object
comparing
object
comparable
cast
fails
object
comes
class
implement
interface
method
throws
classcastexception
fact
exception
thrown
list
stores
different
incomparable
objects
java
use
compareto
compare
string
object
integer
object
javadoc
method
details
says
version
min
two
interesting
methods
class
reverse
even
shuffle
take
list
single
parameter
collection
classes
sequential
ordering
reverse
shuffle
first
method
just
reverses
order
second
method
randomizes
order
second
method
useful
call
updateall
method
simulation
model
simulton
always
udpate
method
called
first
methods
runs
lists
implementing
randomaccess
tagging
interface
calls
get
set
directly
others
list
implementations
linkedlist
iterates
list
copying
elements
array
runs
shuffles
array
using
algorithm
iterates
array
putting
values
back
list
also
ultimate
complexity
class
still
constant
much
bigger
fact
collections
class
also
two
sort
methods
one
comparator
one
without
trying
use
natural
ordering
specified
comparable
can
sort
lists
directly
without
first
converting
array
calling
arrays
sort
way
overloaded
omit
comparator
use
natural
ordering
finally
class
includes
two
interesting
kinds
decorators
dealing
unmodifiability
synchronization
respectively
look
unmodifiability
property
first
names
decorator
classes
unmodifiable
prefix
name
collection
suffix
unmodifiableset
suffixes
allow
names
collection
interfaces
collection
list
set
sortedset
map
sortedmap
produces
object
allows
methods
called
accessors
work
mutators
calling
mutator
makes
object
immediately
throw
unsupportedoperationexception
example
nested
class
underlying
unmodifiable
set
starts
private
static
class
unmodifiableset
implements
set
private
final
set
unmodifiableset
set
null
throw
new
nullpointerexception
nested
class
inner
class
static
continues
follows
accessors
mutators
calling
named
method
instance
variable
throwing
unsupportedoperationexception
respectively
public
int
size
return
size
public
object
remove
object
key
throw
new
unsupportedoperationexception
thus
can
use
decorator
return
object
refers
whole
original
set
can
examined
never
changed
often
approach
faster
making
copy
set
another
way
ensure
original
changed
especially
set
big
methods
will
called
method
call
immediately
another
method
call
takes
bit
time
synchronization
concerns
collections
shared
two
separate
threads
think
multitasking
decorator
one
thread
calls
method
collection
java
guaranteed
finish
thread
can
call
method
code
called
threadsafe
will
briefly
examine
threads
next
lecture
multitasking
big
interesting
topic
right
bit
scope
course
standard
collections
threadsafe
methods
run
quickly
different
complexity
class
different
constant
factor
hash
tables
hashing
section
will
briefly
discuss
hash
tables
better
understand
collection
classes
like
hashset
hashmap
work
achieve
1
complexity
class
many
operations
discussion
necessarily
truncated
will
provide
us
lot
insight
hashing
details
describe
accurate
description
actual
hash
tables
java
uses
standard
java
library
defines
hashtable
class
deailts
bit
simplified
spirit
many
details
accurately
described
entire
books
phd
theses
written
hashing
describing
hash
tables
will
discuss
process
hashing
hashcode
method
implements
process
note
hashcode
method
defined
class
object
like
tostring
inherited
possibly
overridden
every
class
will
first
illustrate
method
string
class
discuss
hash
tables
containing
strings
later
will
generalize
know
arbitrary
classes
hashing
process
computing
int
value
object
will
use
value
suitably
modified
index
array
try
see
value
stored
set
lookup
value
associated
key
map
slight
simplification
hashcode
method
defined
string
class
refers
instance
variable
chars
actually
filled
char
storing
characters
string
public
int
hashcode
int
hash
0
int
0
chars
length
hash
31
hash
chars
promotion
char
int
return
hash
every
character
starting
front
multiplies
previous
hash
value
31
adds
ascii
value
character
example
hashcode
returns
97
just
ascii
value
aa
hashcode
returns
3104
31
97
97
generally
string
length
chars
array
contains
values
hashed
value
given
formula
chars
0
31n
1
chars
1
31n
2
chars
2
311
chars
1
15
200
hashcode
returns
1
453
165
193
richard
pattis
hashcode
returns
125
886
044
yes
arithmetic
overflow
standard
properties
binary
numbers
result
might
negative
recall
java
throw
exceptions
arithmetic
operators
produce
values
outside
range
int
hashing
one
places
behavior
produces
results
still
useful
now
transition
discuss
hash
tables
simplest
model
underlying
data
structure
hash
table
list
array
index
stores
list
values
hashed
spot
will
assume
using
concrete
class
arraylist
discussion
purposes
illustration
lets
use
array
length
10
will
simplify
typical
pictures
arrays
list
objects
bare
minimum
shown
call
index
hash
table
bin
declare
initialize
hash
table
follows
list
ht
new
arraylist
10
int
0
ht
length
ht
new
arraylist
now
put
everything
together
discuss
use
hashcode
value
hash
table
perform
useful
operations
sets
first
see
add
object
set
using
hash
table
boolean
add
object
int
math
abs
hashcode
ht
length
ht
contains
return
false
ht
add
return
true
first
compute
hashcode
taking
absolute
value
finally
computing
remainder
modulo
hash
table's
length
end
result
number
can
use
index
hash
table
value
0
ht
length
1
check
whether
object
already
list
linear
search
return
false
immediatley
duplicates
put
set
otherwise
add
value
list
end
return
true
example
marsha
hascode
returns
1081298290
hash
table
results
index
0
thus
marsha
belongs
bin
0
table
originally
empty
every
arraylist
empty
marsha
placed
shown
first
list
referred
bin
0
reality
index
computed
expression
hashcode
0x7fffffff
ht
length
uses
hexidecimal
number
logical
operator
mask
sign
bit
binary
number
making
non
negative
worry
detail
faster
computing
absolute
value
likewise
can
write
equally
simple
methods
check
containment
removal
values
set
post
hashing
work
done
standard
list
methods
boolean
contains
object
int
math
abs
hashcode
ht
length
return
ht
contains
boolean
remove
object
int
math
abs
hashcode
ht
length
return
ht
remove
now
will
see
tostring
methods
classes
implemented
hash
tables
produce
output
weird
order
easiest
way
write
tostring
method
just
iterate
bins
first
last
bin
iterate
list
values
accumulating
string
everything
return
real
tostring
method
uses
stringbuffer
catenates
efficiently
string
will
discuss
class
end
semester
string
tostring
object
boolean
first
true
string
answer
int
0
ht
length
int
0
ht
size
answer
first
ht
get
first
false
return
answer
simple
well
compared
anonymous
inner
classes
everything
simple
can
efficient
discussion
interesting
part
learning
hash
tables
like
feel
bit
cheated
get
first
going
assume
good
hash
function
given
possible
values
will
put
hash
table
equally
spread
bins
number
end
bin
aside
two
objects
hash
bin
called
collision
theoretically
perfect
hash
function
computed
hash
table
length
able
compute
different
values
collisions
elements
hash
functions
difficult
find
can
expensive
computer
time
run
will
assume
collision
can
occur
use
lists
bin
store
colliding
objects
means
stored
values
hash
table
bins
complexity
class
adding
checking
removing
value
hash
object
compute
bin
expect
values
bin
using
list
operations
contains
remove
linear
searches
lists
constant
complexity
class
now
comes
magic
knew
big
made
exactly
big
complexity
class
adding
checking
removing
1
fact
fixed
percentage
say
complexity
class
operations
1
half
complexity
class
2
2
1
constants
make
hash
table
take
twice
long
bigger
hash
table
10
complexity
class
10
10
1
constants
make
hash
table
take
ten
times
long
bigger
hash
table
bigger
number
bins
fewer
values
bin
faster
list
methods
run
course
limit
reason
make
hash
table
bins
just
means
lots
bins
will
empty
will
never
lookup
information
empty
bins
values
added
just
occupy
extra
space
improve
performance
assumption
know
bad
one
really
make
bins
hash
table
constructed
discard
assumption
just
arrays
allowing
hash
tables
double
size
whenever
start
fill
size
doubling
hash
tables
requires
create
new
hash
table
twice
many
bins
iterate
every
value
old
hash
table
adding
new
hash
table
rehasing
notice
guarantee
object
hashed
index
old
table
will
hash
index
new
table
taking
ht
length
different
length
remainder
likely
different
code
implements
doublelength
hash
table
uses
iteration
scheme
first
bins
elements
list
tostring
void
doublelength
list
oldht
ht
ht
new
arraylist
ht
length
2
int
0
ht
length
ht
new
arraylist
int
0
oldht
length
int
0
oldht
size
add
oldht
get
note
create
2n
new
arraylists
iterate
values
old
hash
table
adding
new
hash
table
add
1
operation
just
array
doubling
complexity
class
doubling
length
hash
table
java
double
length
hash
table
depends
load
factor
either
specified
constructor
class
uses
hash
table
default
value
typically
75
load
factor
hash
table
ratio
gets
bigger
values
added
hash
table
exceeds
specified
limit
hash
table's
length
doubled
actually
probably
factor
1
5
collections
like
list
default
case
hash
table
exceeded
75
full
adding
76
value
hash
table
100
bins
will
increase
length
array
length
doubling
want
often
double
make
array
much
bigger
making
load
factor
much
smaller
classic
time
vs
space
tradeoff
using
space
bins
hash
table
can
reduce
time
takes
execute
various
methods
throughout
discussion
ignored
time
takes
java
compute
hashcode
object
obviously
method
run
relatively
quickly
compared
overhead
needed
start
complete
hash
table
search
often
tradeoff
quickly
hashcode
method
runs
uniformly
computes
bin
values
way
depend
solely
hashcode
method
also
number
bins
hash
table
case
time
takes
execute
hashcode
method
independent
number
items
hash
table
hashcode
methods
write
class
will
used
collection
backed
hash
table
set
key
map
override
inherited
hashcode
method
method
write
quick
produce
collisions
rule
must
follow
equals
implies
hashcode
hashcode
equals
objects
must
hash
bin
regardless
hash
table
length
also
notice
implies
goes
just
one
way
objects
produce
hash
code
may
may
equals
might
just
collision
typically
hashcode
method
will
call
hashcode
instance
variables
numerically
combine
single
value
example
abstractlist
class
defines
following
hashcode
method
relying
iterator
examine
value
stores
find
hashcode
add
weighted
sum
public
int
hashcode
int
hashcode
1
iterator
iterator
hasnext
object
obj
next
hashcode
31
hashcode
obj
null
0
obj
hashcode
return
hashcode
class
just
inherits
hashcode
override
will
using
intersting
instance
variables
compute
hash
value
might
many
collisions
slowing
methods
collection
class
using
mutation
caching
final
two
topics
hashing
related
mutate
object
collection
employs
hashing
can
cache
hash
values
immutable
objects
seen
hash
tables
store
object
bin
one
depends
value
returned
hashcode
method
called
object
added
hash
table
also
seen
hashcode
method
typically
returns
result
depends
state
object
hash
codes
instance
variable
share
object
hash
table
mutate
object
likely
stored
wrong
bin
hash
table
according
value
hashcode
now
returns
searching
removing
etc
will
probably
work
correctly
thus
note
javadoc
hashset
hashmap
mutating
key
map
forbidden
problem
mutating
value
hashing
done
key
associated
value
given
prohibition
using
immutable
class
hash
table
perfect
match
since
contains
mutators
string
collection
classes
immutable
fact
string
class
uses
caching
remembering
computed
value
hashing
kind
rolls
tongue
caching
hashing
caching
another
classic
time
vs
space
tradeoff
store
computed
value
expect
might
compute
second
time
just
return
precomputed
value
can
now
show
accurate
version
hashcode
method
defined
string
class
assume
hashcode
instance
variable
declared
class
public
int
hashcode
hashcode
0
return
hashcode
int
hash
0
int
0
chars
length
hash
31
hash
chars
promotion
char
int
return
hashcode
hash
first
time
hashcode
method
called
computes
value
returning
stores
hashcode
instance
variable
next
time
called
just
immediately
returns
value
string
class
immutable
value
hashcode
returns
always
fact
mutable
classes
can
extend
modification
count
trick
used
iterators
combine
caching
call
hashcode
method
first
time
object
store
hash
code
modification
count
object
subsequent
call
hashcode
method
current
modification
count
can
just
return
cached
hash
code
different
must
recompute
hash
code
re
store
new
modification
count
reading
java
classes
source
code
classes
standard
java
library
stored
zip
file
format
current
10mb
probably
2
5
times
size
unzipped
java
1
3
file
typically
stored
top
level
folder
java
jdk1
3
1
04
file
named
src
jar
java
1
4
file
typically
stored
top
level
folder
java
j2sdk1
4
1
01
file
named
src
zip
newer
versions
file
zip
format
extension
also
zip
windows
pc
can
drag
either
files
zip
icon
case
scr
zip
can
just
double
click
result
can
double
click
file
zip
window
load
metrowreks
editor
view
can
copy
file
zip
window
onto
say
desktop
examine
edit
mentioned
lecture
classes
documented
javadoc
written
fairly
simply
even
beginners
might
able
understand
code
least
parts
code
contaisn
although
useful
javadoc
html
pages
documenting
classes
code
classes
great
resource
understanding
java
way
things
hash
tables
really
used
implement
collection
classes
lot
details
got
another
interesting
method
examine
sort
method
arrays
class
generics
java
1
5
time
see
java
generics
pdf
tutorial
problem
set
ensure
understand
material
lecture
please
solve
announced
problems
read
lecture
get
stumped
problem
go
back
read
relevant
part
lecture
still
questions
please
get
help
instructor
ta
student
programming
assignment
will
throroughly
test
ability
use
collecton
classes
binarysearch
method
assumes
precondition
list
passed
sorted
according
comparator
passed
explain
good
idea
method
check
preconditon
easily
applying
comparator
adjacent
pair
values
list
explain
hashcode
method
integer
wrapper
class
computes
value
