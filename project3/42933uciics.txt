inheritance class hierarchies 

inheritance
class
hierarchies
introduction
computer
science
iii
ics
21
22
23
introduction
lecture
will
begin
discussing
direct
relationships
among
classes
including
generalizing
relationship
object
class
classes
will
discus
subclasses
also
known
extension
classes
superclasses
aka
base
classes
concept
inheritance
among
classes
pragmatically
will
focus
inheriting
state
methods
defined
classes
overriding
methods
brief
review
originally
learned
every
class
independent
every
class
type
variable
reference
object
stored
always
names
class
timer
new
timer
learned
class
object
acted
type
generic
class
variable
declared
type
object
store
reference
object
constructed
class
still
primitive
value
int
wrap
value
integer
wrapper
class
now
first
time
type
left
side
declaration
class
constructed
write
object
new
string
abc
object
new
integer
123
object
new
timer
variable
call
methods
declared
object
class
wanted
call
methods
class
object
really
refered
store
reference
object
type
variable
needed
cast
reference
check
instanceof
operator
integer
pop
intvalue
integer
integer
pop
recently
learned
sometimes
classes
indirectly
related
implemented
interface
cases
used
interface
name
type
variable
store
reference
object
constructed
class
implements
interface
decisionint
inrange
new
isbetween
0
5
likewise
variable
call
methods
declared
interface
class
guaranteed
specify
lecture
will
learn
another
complicated
useful
way
classes
related
via
subclassing
extension
inheritance
will
study
generalization
type
variable
restricts
references
objects
can
store
methods
can
call
variable
class
object
refers
determines
actual
behavior
methods
called
object
class
properties
know
just
special
case
learning
subclassing
extension
inheritance
concepts
reference
casting
instanceof
operator
likewise
rediscussed
general
framework
class
inheritance
although
programming
implications
inheritance
many
varied
will
focus
technical
details
first
whenever
discuss
new
facets
classes
must
discuss
related
constructors
fields
methods
specifically
will
learn
picture
objects
constructed
subclasses
extend
fields
provided
superclasses
will
learn
new
constructor
syntax
purpose
well
will
discuss
methods
superclass
inherited
overridden
subclasses
determining
behavior
object
constructed
subclass
make
information
concrete
will
use
simple
classes
collected
small
hierarchy
intcounter
modularcounter
boundedcounter
classes
implements
counter
interface
modularcounter
boundedcounter
extend
intcounter
adding
fields
inheriting
overriding
defining
new
methods
will
close
lecture
discussing
skipcounter
class
acts
decorator
counter
interface
contrast
use
making
yet
subclasses
can
download
counters
via
inheritance
demonstration
application
whose
code
described
used
illustrate
material
lecture
extends
subclassing
often
new
class
slight
variation
extension
old
class
adds
state
fields
adds
modifies
behavior
methods
makes
programming
language
object
oriented
provides
mechansim
define
new
class
based
old
class
requiring
us
define
just
new
fields
changed
new
methods
java
use
extends
keyword
create
subclass
based
extending
superclass
example
first
line
defines
modularcounter
class
public
class
modularcounter
extends
intcounter
field
constructor
method
java
oop
languages
can
define
class
extend
just
one
class
often
show
relationship
follows
always
superclass
top
subclass
can
build
complicated
application
program
library
many
classes
related
superclass
subclass
relationships
forming
inheritance
hierarchy
draw
hierarchies
follows
subclass
beneath
superclass
arrow
pointing
superclass
may
many
direct
subclasses
subclass
exactly
one
direct
superclass
example
modularcounter
boundedcounter
classes
extend
intcounter
class
subclass
sense
powerful
superclass
extends
adds
fields
methods
unfortunately
terms
subclass
superclass
seem
exactly
opposite
informal
meanings
word
super
implies
something
powerful
fact
subclass
powerful
careful
use
terms
many
classes
declared
without
extending
class
default
absence
extends
implies
classes
extend
class
object
class
super
superclasses
extends
class
root
inheritance
hierarchy
created
inheritance
relationships
example
following
inheritance
hierarchy
includes
just
classes
discussed
quarter
classes
extend
class
definition
subclasses
object
class
will
soon
study
read
javadoc
classes
hierarchy
studying
fields
methods
inherit
intcounter
superclass
intcounter
class
appears
simple
class
compared
reading
writing
elements
needed
discuss
general
inheritance
class
hierarchies
certainly
class
pedagogically
useful
practical
public
class
intcounter
public
intcounter
public
intcounter
int
initialvalue
value
initialvalue
public
void
reset
value
0
public
void
increment
value
public
int
getvalue
return
value
public
string
tostring
return
value
private
int
value
0
class
declares
instance
variable
value
automatically
initializes
0
one
constructor
allows
us
keep
value
stores
initial
value
value
notice
first
constructor
written
java
supply
another
constructor
java
automatically
supplies
nothing
constructor
class
defines
constructors
mutators
commands
reset
increment
state
stored
value
accessor
query
getvalue
returns
value
tostring
returns
value
string
easily
accomplished
via
catenation
empty
string
can
use
class
can
declare
intcounter
new
intcounter
call
increment
call
system
println
remember
writing
writing
tostring
print
simply
1
modularcounter
subclass
modularcounter
class
appears
will
first
explain
java's
inheritance
mechanism
using
class
extend
subclass
intcounter
briefly
examine
now
worry
details
yet
understand
will
discuss
components
next
sections
public
class
modularcounter
extends
intcounter
public
modularcounter
int
modulus
0
modulus
public
modularcounter
int
value
int
modulus
throws
illegalargumentexception
super
value
modulus
1
throw
new
illegalargumentexception
modularcounter
modulus
bad
value
0
value
modulus
throw
new
illegalargumentexception
modularcounter
value
bad
modulus
modulus
public
int
getmodulus
return
modulus
public
void
increment
getvalue
modulus
1
reset
else
super
increment
public
string
tostring
return
super
tostring
modulus
private
final
int
modulus
explain
relationship
bewteen
modularcounter
intcounter
examining
inheritance
affects
three
components
class
fields
constructors
methods
process
will
explain
uses
super
appear
fields
subclasses
object
constructed
subclass
contains
fields
subclass
defines
fields
contained
superclass
superclass
superclass
etc
way
class
object
root
inheritance
hierarchy
object
class
defines
instance
variables
will
graphically
represent
note
public
private
access
modifiers
work
subclassing
although
subclass
may
contain
fields
defined
superclass
fields
defined
private
superclass
subclass
refer
wishes
access
change
must
use
standard
accessor
mutator
methods
defined
superclass
public
fields
typically
none
instance
variables
defined
superclass
can
referred
directly
subclass
draw
object
constructed
subclass
will
show
containing
fields
superclass
inside
will
label
boundary
superclass
instance
variable
appears
example
intcounter
class
defines
value
type
int
instance
variable
modularcounter
class
extends
defines
modulus
type
int
instance
variable
modularcounter
extends
intcounter
inherits
fields
will
draw
modularcounter
object
follows
choose
represent
object
class
pictures
even
though
always
top
class
inheritance
hierarchy
class
defines
state
continue
study
mechanics
inheritance
pictures
like
one
will
make
material
easier
understand
finally
will
now
introduce
another
access
modifier
named
protected
keyword
allows
access
level
inbetween
public
private
different
package
friendly
class
member
declared
protected
can
referred
methods
class
can
referred
methods
subclass
subclass
subclass
etc
can
referred
methods
class
defined
package
like
package
friendly
last
rule
protected
access
modifier
bit
strange
students
advised
use
protected
know
means
run
across
code
uses
summary
access
modifiers
get
restrictive
following
sequence
public
protected
package
friendly
private
can
say
protected
members
package
friendly
plus
able
accessed
subclasses
whether
package
constructors
subclasses
seen
object
constructed
subclass
contains
fields
present
superclass
well
diagram
construct
object
subclass
must
first
diagram
construct
superclass
fields
encapsulated
inside
oval
superclass
take
new
fields
subclass
defines
place
outside
oval
encapsulate
fields
inside
subclass
oval
first
line
code
subclass
constructor
must
call
super
keyword
appears
constructor
means
call
constructor
superclass
whatever
class
subclass
extends
student
prefer
use
name
superclass
java
way
exception
first
line
uses
case
call
super
course
arguments
super
must
match
parameters
one
constructors
superclass
may
overloaded
example
two
constructors
defined
superclass
modularcounter
public
modularcounter
int
modulus
0
modulus
public
modularcounter
int
value
int
modulus
throws
illegalargumentexception
super
value
modulus
1
throw
new
illegalargumentexception
modularcounter
modulus
bad
value
0
value
modulus
throw
new
illegalargumentexception
modularcounter
value
bad
modulus
modulus
can
see
first
constructor
just
refers
second
general
one
using
mechanism
studied
first
line
code
second
constructor
must
call
constructor
superclass
always
denoted
keyword
super
purpose
calling
super
appropriately
initialize
private
instance
variables
superclass
fact
super
explicitly
called
implicitly
called
super
leave
call
super
accidentally
purpose
constructor
java
will
still
compile
run
code
superclass
parameterless
constructor
second
constructor
modularcounter
class
calls
right
super
constructor
reinitializing
value
intcounter
value
parameter
value
modularcounter
constructor
notice
required
placement
super
first
method
must
done
sanity
check
value
can
performed
will
check
values
seems
odd
calling
super
required
order
java
finally
assuming
parameters
ok
stores
second
parameter
modulus
instance
variable
defined
modularcounter
subclass
writing
new
modularcounter
3
new
modularcounter
0
3
leads
construction
object
shown
picture
rules
construction
summarized
allocate
space
fields
specified
subclass
superclasses
initialize
fields
according
declarations
call
superclass
constructor
reinitializes
fields
superclass
note
supercalss
constructor
will
first
call
constructor
superclass
unless
object
class
superclass
execute
rest
constructor
code
may
reinitialize
fields
declared
class
instance
variables
declared
initialized
reinitialized
top
hierarchy
downwards
think
java
starting
super
class
object
initialization
maybe
reinitialization
downward
subclass
actually
constructed
technically
constructors
classes
written
prior
lecture
extend
object
start
super
construct
object
class
extend
recall
objects
object
class
store
state
constructor
takes
parameters
omit
call
super
constructor
class
java
automatically
includes
call
super
us
right
top
class
writing
extends
class
parameterless
constructor
java
compiler
will
complain
general
parameterless
constructor
java
writes
class
thus
public
class
super
finally
subclass
constructors
typically
specify
parameters
superclass
constructors
subclass
constructor
reinitialize
instance
variables
superclass
via
super
well
instance
variables
ones
defines
superclass
know
methods
subclassing
far
interesting
subtle
facet
subclasses
can
inherit
use
methods
superclasses
although
seen
also
inherit
fields
access
modifiers
fields
private
subclass
directly
access
fields
defined
superclass
must
use
accessors
mutators
supplied
supercalss
examine
change
instance
variables
accessor
modifiers
methods
public
methods
inherited
superclass
can
referred
subclass
section
will
discuss
inherited
methods
new
methods
finally
overridden
methods
interesting
powerful
first
subclass
inherits
methods
available
superclass
can
call
methods
variable
whose
type
specified
subclass
intcounter
superclass
declares
reset
getvalue
tostring
methods
modularcounter
subclass
inherits
methods
declare
modularcounter
mc
new
modularcounter
0
3
can
call
mc
reset
mc
getvalue
mc
tostring
remember
called
implicitly
system
println
mc
mc
cases
java
executes
methods
defined
intcounter
superclass
method
superclass
subclass
can
refer
instance
variables
declared
intcounter
superclass
really
aware
called
via
modularcounter
object
second
subclasses
can
also
define
new
methods
ones
defined
superclass
either
different
name
name
different
signature
parameter
structure
methods
considered
new
methods
modularcounter
subclass
defines
public
getmodulus
method
simply
public
int
getmodulus
return
modulus
method
name
defined
intcounter
superclass
make
sense
define
method
intcounters
store
modulus
value
represent
simpler
objects
declare
modularcounter
mc
new
modularcounte
0
3
can
call
mc
getmodulus
java
executes
getmodulus
method
defined
modularcounter
subclass
finally
interestingly
subclass
can
also
override
method
note
word
override
overwrite
words
hard
differentiate
hear
case
subclass
defines
method
name
signature
method
inherits
call
method
name
correct
number
type
arguments
java
executes
method
defined
subclass
one
inherited
superclass
thus
subclass
particularizes
method
can
access
instance
variables
declared
subclass
intcounter
superclass
declares
public
increment
method
parameters
modularcounter
class
inherits
overrides
method
defining
public
void
increment
getvalue
modulus
1
reset
else
super
increment
declare
modularcounter
mc
new
modularcounter
0
3
can
call
mc
increment
java
executes
increment
method
defined
modularcounter
subclass
one
shown
overrides
method
superclass
will
now
examine
java
executes
method
statement
calls
inherited
getvalue
method
checks
equality
one
less
modulus
instance
variable
defined
private
inside
modularcounter
class
thus
directly
accessible
method
also
defined
test
true
inherited
reset
method
called
false
inherited
increment
method
called
else
part
wrote
call
increment
method
java
try
recursively
call
increment
method
executing
one
defined
modularcounter
subclass
instead
wrote
super
increment
tells
java
call
overridden
method
inherited
model
objects
one
showing
superclass
inside
subclass
can
help
us
understand
process
java
uses
decide
method
call
think
following
general
process
happening
whenever
method
called
object
comes
subclass
java
starts
outermost
subclass
java
finds
method
defined
right
name
right
signature
calls
method
defined
subclass
java
find
method
goes
inward
direct
superclass
repeats
process
whenever
java
find
method
subclass
moves
inward
superclass
repeating
process
finds
right
method
call
new
methods
subclass
trivial
methods
always
found
outer
level
java
finds
definitions
inherited
methods
moves
inward
superclass
first
defines
overridden
methods
java
finds
definition
outer
subclass
although
actual
process
java
uses
find
method
much
efficient
fast
table
lookup
model
good
one
understand
simpler
explain
result
finally
subclass
method
overrides
superclass
method
method
name
called
will
immediately
found
subclass
subclass
method
can
call
superclass
method
overrode
prefixing
method's
name
using
keyword
super
often
superclass
method
helps
subclass
method
get
job
done
increment
method
modularcounter
sometimes
needs
just
increment
private
instance
variable
value
defined
intcounter
class
way
can
calling
increment
method
defined
superclass
hence
call
super
increment
concretely
declare
modularcounter
mc
new
modularcounter
0
2
first
call
mc
increment
java
finds
executes
increment
subclass
explicitly
executes
inherited
method
second
call
value
now
set
1
java
finds
executes
increment
subclass
executes
inherited
reset
method
note
intcounter
class
defined
tostring
modularcounter
class
overrides
defnining
public
string
tostring
return
super
tostring
modulus
works
first
calling
tostring
method
defined
intcounter
class
getting
string
representation
value
instance
variable
catenating
modulus
instance
variable
available
subclass
thus
just
can
use
explicit
reference
current
object
can
use
super
reference
current
object
well
pretending
constructed
superclass
accessing
member
forcing
java
find
method
one
level
deeper
object
pictures
boundedcounter
subclass
boundedcounter
class
appears
another
specialization
intcounter
quite
similar
form
modularcounter
works
counting
certain
bound
stopping
increment
operations
effect
public
class
boundedcounter
extends
intcounter
public
boundedcounter
int
bound
0
bound
public
boundedcounter
int
value
int
bound
throws
illegalargumentexception
super
value
bound
0
throw
new
illegalargumentexception
boundedcounter
bound
bad
value
bound
throw
new
illegalargumentexception
modularcounter
value
bad
bound
bound
public
int
getbound
return
bound
public
void
increment
getvalue
bound
super
increment
public
string
tostring
return
super
tostring
bounded
bound
private
final
int
bound
can
extend
intcounter
specializing
add
methods
modifying
meanings
inherited
methods
well
adding
appropriate
constructors
notice
subclass
define
differences
superclass
often
subclass
will
inherit
many
methods
superclass
definining
just
small
amount
new
state
new
methods
overriding
just
inherited
methods
thus
economical
define
subclasses
javadoc
inheritance
hierarchies
javadoc
includes
special
features
help
us
understand
class
fits
inheritance
hierarchy
javadoc
modularcounter
class
run
javadoc
exactly
code
shown
constains
special
javadoc
comments
can
concentrate
structural
details
inheritance
tells
us
modularcounter
class
declared
edu
uci
ics
pattis
introlib
package
subclass
whose
direct
superclass
intcounter
also
declared
package
likewise
class
subclass
whose
direct
superclass
object
declared
java
lang
package
seen
object
direct
superclass
top
java
class
hierarchy
shows
constructor
summary
next
contains
two
contructors
studied
method
summary
shows
methods
defined
class
getmodulus
newly
defined
method
increment
tostring
override
inherited
methods
following
method
summary
javadoc
shows
methods
inherited
superclasses
modularcounter
shows
getvalue
reset
intcounter
standard
methods
object
inherits
notice
tostring
method
defined
object
class
listed
way
method
modularcounter
class
refer
method
super
tostring
refers
tostring
method
inheritred
intcounter
class
write
anything
like
super
super
tostring
another
example
will
soon
study
details
jbutton
class
allows
us
place
buttons
application
take
appropriate
action
pressed
actually
will
soon
see
much
jbutton
description
implies
examine
javadoc
sun's
api
class
starts
tells
us
jbutton
class
declared
javax
swing
package
subclass
whose
direct
superclass
abstractbutton
also
declared
javax
swing
package
likewise
class
subclass
whose
direct
superclass
jcomponent
also
declared
javax
swing
package
likewise
class
subclass
whose
direct
superclass
container
declared
different
package
java
awt
likewise
class
subclass
whose
direct
superclass
component
also
declared
java
awt
package
finally
class
subclass
whose
direct
superclass
object
declared
java
lang
package
seen
object
direct
superclass
top
java
class
hierarchy
addition
displaying
methods
defined
class
javadoc
shows
methods
inherited
subclasses
jbutton
appears
appears
objects
jbutton
class
many
methods
can
use
query
control
point
studies
concerned
functioning
jbuttons
functioning
javadoc
documenting
subclasses
java
programs
know
methods
certainly
know
easier
program
java
method
usage
probably
follows
kind
power
law
plotting
frequency
use
method
one
finds
small
number
methods
used
huge
amount
time
huge
number
methods
rarely
used
tthe
exact
curve
straight
line
plotted
log
graph
power
slope
recall
log
ab
equals
log
many
applications
can
written
calling
just
settext
addactionlistener
methods
specifying
button's
label
button
pushed
others
also
use
seticon
gettext
setenabled
probably
used
another
half
dozen
methods
guis
written
admitedly
professional
programmer
polymorphism
casting
instanceof
recall
two
critical
rules
understand
java
method
calls
restate
illustrate
applied
context
inheritance
hierarchies
rules
type
compatibility
rules
discussed
core
object
oriented
programming
first
rule
applied
compile
time
second
runtime
1
methods
java
compiler
allows
called
variable
2
java
determines
method
context
inheritance
overriding
call
type
variable
declared
determines
methods
can
call
regardless
object
refers
compiler
examines
code
method
call
checks
declared
type
variable
supports
method
call
object
variable
refers
determines
method
actually
called
regardless
type
variable
course
type
must
allow
call
java
runtime
systems
calls
method
follows
reference
variable
object
class
object
determine
method
name
call
declare
modularcounter
mc
can
call
methods
mc
defined
inherited
modularcounter
class
affected
actual
class
object
mc
refers
just
interfaces
declare
variable
name
interface
can
use
call
methods
defined
interface
shall
soon
see
can
declare
intcounter
ic
new
modularcounter
0
3
storing
superclass
variable
reference
subclass
object
call
method
increment
modularcounter
class
overrides
increment
method
inherits
intcounter
java
executes
method
defined
modularcounter
class
reread
previous
paragraphs
everything
else
discuss
terms
inheritance
built
upon
ideas
will
continue
explore
become
better
acquainted
throughout
rest
quarter
ability
variable
refer
objects
constructed
different
classes
compatible
variable's
type
via
interfaces
class
hierarchy
correct
method
determined
runtime
called
polymorphism
means
many
forms
rules
assignment
variable
reference
become
much
interesting
classes
related
inheritance
hierarchy
already
seen
can
assign
reference
object
variable
whose
type
interface
object's
class
implements
interface
basic
rules
inheritance
implicit
upcasting
can
assign
reference
subclass
object
variable
whose
type
superclass
without
casting
example
intcounter
c1
new
modularcounter
0
3
fact
correct
redundant
write
intcounter
c1
intcounter
new
modularcounter
0
3
course
can
write
object
new
everthing
can
implicitly
upcasted
object
class
explicit
downcasting
can
attempt
assign
reference
superclass
object
variable
whose
type
subclass
must
use
cast
whenever
downcast
java
believes
compile
time
downcast
will
work
java
check
runtime
cast
works
example
modularcounter
c2
modularcounter
c1
given
declaration
c1
will
work
runtime
write
modularcounter
c2
c1
java
compiler
report
error
need
explicit
cast
going
downwards
almost
always
needed
downcasting
pop
dequeue
methods
integer
integer
dequeue
class
object
type
variable
related
subclass
superclass
relationship
assign
one
write
modularcounter
c3
new
timer
modularcounter
c3
modularcounter
new
timer
java
compiler
dectect
report
error
rules
make
sense
know
object
constructed
subclass
think
modularcounter
supports
methods
java
allows
called
superclass
think
intcounter
subclass
inherits
methods
superclass
course
may
override
add
new
methods
well
recall
legal
write
object
new
class
constructing
object
stored
recall
java
allows
us
call
methods
defined
object
class
upcasting
reduces
number
methods
can
called
subclass
just
superclass
downcasting
increases
number
methods
can
called
using
variable
can
call
methods
subclass
specified
cast
java
requires
us
use
explicit
casting
signal
us
java
will
check
something
runtime
downcasting
modularcounter
mc
modularcounter
new
intcounter
5
accepted
java
compile
always
fails
runtime
object
created
modularcounter
class
subsequently
tried
call
mc
getmodulus
work
object
constructed
intcounter
class
fails
support
method
downcasting
work
suppose
use
simplestack
class
one
object
parameters
return
types
following
way
simplestack
new
simplestack
push
new
modularcounter
0
3
modularcounter
mc
modularcounter
pop
downcast
works
object
returned
pop
really
reference
object
constructed
modularcounter
class
written
push
new
intcounter
0
previous
code
still
compiler
cast
popping
throw
classcastexception
finally
will
learn
better
semantics
instanceof
recall
originally
learned
expression
instanceof
typename
returns
true
stored
non
null
reference
refers
object
constructed
class
typename
now
generalize
last
part
allowing
refer
object
allowed
casted
class
typename
can
name
class
interface
thus
declare
modularcounter
mc
new
modularcounter
0
3
asked
mc
instanceof
counter
result
true
next
section
shows
declare
interface
named
counter
declared
modularcounter
implement
counter
asked
mc
instanceof
intcounter
result
true
mc
refers
object
class
intcounter
perform
upcast
class
course
asked
mc
instanceof
modularcounter
result
true
upcasting
instanceof
always
returns
true
typename
superclass
actual
object
refers
downcasting
must
truly
check
see
object
constructed
specified
class
completeness
reference
variable
stores
null
can
casted
class
try
call
method
result
refers
object
counter
interface
fact
counter
classes
implement
common
interface
see
done
useful
counter
interface
specified
public
interface
counter
public
void
reset
public
void
increment
public
int
getvalue
class
implement
counter
interface
needs
implement
least
three
methods
fact
classes
seen
implement
declare
intcounter
modularcounter
boundedcounter
class
really
done
follows
public
class
intcounter
implements
counter
public
class
modularcounter
extends
intcounter
implements
counter
public
class
boundedcounter
extends
intcounter
implements
counter
fact
java
allows
us
leave
last
two
implements
counter
tell
java
modularcounter
extend
intcounter
combines
knowledge
knowledge
intcounter
implements
counter
deduce
modularcounter
implements
intcounter
even
modularcounter
define
one
method
inherit
methods
intcounter
thus
inherit
methods
needs
implement
counter
look
following
three
declarations
legal
types
compatible
objects
via
interface
upcasting
just
type
constucted
object
counter
c1
new
modularcounter
0
3
intcounter
c2
new
modularcounter
0
3
modularcounter
c3
new
modularcounter
0
3
can
call
reset
getvalue
increment
variables
can
call
tostring
well
class
will
least
inherit
tostring
method
object
class
addition
can
call
c3
getmodulus
call
c1
getmodulus
call
c2
getmodulus
types
variables
specify
method
remember
type
variable
determines
methods
can
called
likewise
call
c1
increment
c2
increment
c3
increment
java
executes
increment
method
defined
modularcounter
class
right
one
objects
actual
method
called
depends
class
object
type
variable
students
devil
time
understanding
type
object
distinction
always
seem
want
backwards
type
variable
determines
method
called
class
object
variable
refers
determines
whether
method
can
called
right
rules
complicated
takes
bit
getting
used
three
declarations
put
program
like
use
restrictive
type
possible
care
counter
calling
reset
getvalue
increment
methods
might
well
declare
type
counter
technically
care
whether
using
intcounter
modularcounter
boundedcounter
fact
might
change
code
one
declaring
type
generically
counter
rest
code
will
guarantee
compile
even
change
constructed
object
using
course
needed
call
getmodulus
third
declaration
works
truly
must
modularcounter
explore
issue
types
bit
suppose
want
collect
bunch
counters
array
increment
know
classes
counter
constructed
might
one
class
another
simplest
way
counter
counters
new
counter
code
store
new
intcounter
modularcounter
boundedcounter
member
index
counters
int
0
counters
length
counter
counters
increment
just
counters
increment
using
interface
name
counter
type
array
specifying
every
array
member
refers
object
constructed
class
implementing
counter
right
generalization
objects
get
stored
array
loop
generates
index
array
can
write
counter
counters
well
member
counters
array
type
counter
call
increment
change
state
object
fact
can
accomplished
simply
writing
just
counters
increment
students
invariable
want
store
class
counter
different
array
write
loop
processes
takes
lots
code
also
seen
students
use
one
array
write
code
like
int
0
counters
length
terrible
counter
counters
terrible
instanceof
intcounter
terrible
intcounter
counters
increment
terrible
else
instanceof
modularcounter
terrible
modularcounter
counters
increment
terrible
else
instanceof
boundedcounter
terrible
boundedcounter
counters
increment
terrible
none
uses
instanceof
casting
needed
original
approach
much
simpler
understand
concepts
involved
hang
elegant
also
robust
changes
example
define
new
class
also
implements
counter
objects
can
also
put
array
incremented
exact
code
shown
approaches
declare
new
array
add
another
else
code
kinds
changes
cripple
software
maintenance
final
example
suppose
enqueued
bunch
objects
simplequeue
want
dequeue
object
reference
class
implements
counter
want
add
current
value
sum
code
simplequeue
new
simplequeue
code
store
new
intcounter
modularcounter
boundedcounter
reference
int
sum
0
isempty
object
dequeue
instanceof
counter
sum
counter
getvalue
note
guaranteed
every
reference
queue
object
constructed
class
implementing
counter
write
loop
simply
isempty
sum
counter
dequeue
getvalue
can
directly
cast
dequeued
value
former
code
non
counter
references
skipped
code
non
counter
reference
causes
classcastexception
thrown
skipcounter
decorator
recall
reverseacomparator
decorator
constructor
took
object
constructed
class
implementing
comparator
interface
class
also
implements
comparator
decorating
object
passed
compare
method
always
returns
opposite
result
will
now
look
another
decorator
time
counter
defined
public
class
skipcounter
implements
counter
public
skipcounter
counter
todecorate
int
skip
throws
illegaargumentexception
skip
1
throw
new
illegalargumentexception
skipcounter
skip
skip
1
basecounter
todecorate
skip
skip
public
void
reset
basecounter
reset
public
void
increment
int
1
skip
basecounter
increment
public
int
getvalue
return
basecounter
getvalue
public
string
tostring
return
basecounter
skip
skip
private
counter
basecounter
private
int
skip
notice
constructor
takes
parameters
reference
object
constructed
class
implements
counter
positive
int
reference
stored
instance
variable
basecounter
int
stored
instance
variable
skip
class
implements
counter
must
define
methods
reset
increment
getvalue
first
last
implemented
just
applying
named
method
basecounter
middle
implemented
applying
named
method
skip
times
basecounter
incrementing
counter
skip
times
finally
tostring
method
overridden
catenate
tostring
basecounter
along
much
skipping
thus
write
counter
new
skipcounter
new
modularcounter
0
3
2
call
increment
getvalue
returns
2
incrementing
0
1
2
call
increment
getvalue
returns
1
incrementing
2
0
remember
modulus
3
1
likewise
calling
tostring
time
returns
string
1
mod
3
skip
2
thus
can
decorate
counter
making
call
increment
actually
increment
skip
times
alternative
approach
extend
class
hierarchy
follows
approach
need
different
subclass
every
class
hierarchy
added
classes
need
add
skip
subclasses
nature
skipping
rather
write
classes
can
write
one
decoarator
class
apply
objects
constructed
class
hierarchy
problem
set
ensure
understand
material
lecture
please
solve
announced
problems
read
lecture
get
stumped
problem
go
back
read
relevant
part
lecture
still
questions
please
get
help
instructor
ca
student
happen
accidentally
forgot
call
super
commented
following
constructor
syntax
error
runtime
error
explain
public
modularcounter
int
value
int
modulus
throws
illegalargumentexception
accidentally
leave
call
super
value
modulus
1
throw
new
illegalargumentexception
modularcounter
modulus
bad
value
0
value
modulus
throw
new
illegalargumentexception
modularcounter
value
bad
modulus
modulus
explain
following
increment
method
written
modularcounter
class
good
original
one
shown
public
void
increment
super
increment
getvalue
modulus
reset
saw
declare
modularcounter
new
modularcounter
0
3
ask
instanceof
intcounter
return
true
write
complicated
expression
returns
true
really
refers
object
constructed
class
intcounter
subclasses
problem
arises
code
add
subclasses
intcounter
ambitious
student
check
object
class
alternative
fail
safe
way
write
code
java
will
let
us
rewrite
simpler
constructor
modularcounter
public
modularcounter
int
modulus
super
0
modulus
error
compiler
generate
problem
created
body
allowed
see
also
body
complicated
constructor
refers
think
allowed
call
new
inherited
method
constructor
example
wanted
call
constructor
print
immediately
object
constructed
write
following
legal
print
wrote
new
modularcounter
0
3
public
modularcounter
int
value
int
modulus
system
println
super
value
modulus
modulus
public
modularcounter
int
value
int
modulus
super
value
system
println
modulus
modulus
public
modularcounter
int
value
int
modulus
super
value
modulus
modulus
system
println
explain
following
method
legal
java
public
static
counter
gimmeacounter
math
random
5
return
new
intcounter
0
else
return
new
modularcounter
0
3
given
method
following
declarations
legal
counter
gimmeacounter
intcounter
gimmeacounter
modularcounter
gimmeacounter
added
explict
downcasting
illegal
declarations
always
never
sometimes
cause
runtime
error
changed
return
type
gimmeacounter
intcounter
method
legal
java
explain
indicate
declarations
still
legal
explicit
downcasting
work
questions
changed
return
type
modularcounter
answer
following
related
questions
suppose
wanted
write
equals
method
tested
equality
just
testing
value
counter
test
involving
modulus
bound
class
es
write
code
code
goes
one
class
needs
new
code
just
write
code
one
classes
suppose
wanted
write
equals
method
tested
true
state
equality
objects
compared
must
come
class
state
must
identical
class
es
write
code
code
goes
one
class
needs
new
code
just
write
code
one
classes
suppose
wanted
write
class
implementing
comparator
use
sort
objects
class
implementing
counter
well
object
constructed
integer
wrapper
class
class
es
write
code
code
goes
one
class
needs
new
code
just
write
code
one
classes
java
body
getmodulus
method
contained
call
super
getmodulus
write
constructor
skipcounter
just
one
int
parameter
skip
create
skipcounter
object
automatically
decorates
intcounter
explain
good
idea
skipcounter
extend
intcounter
class
besides
object
write
public
static
method
named
allok
takes
two
parameters
filled
array
decisionint
int
method
returns
true
every
object
array
isok
method
called
int
parameter
returns
true
otherwise
return
false
carefully
finish
sentence
first
argument
passed
constructor
skipcounter
must
