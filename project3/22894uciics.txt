fielding dissertation chapter 6 experience evaluation 
chapter 6 experience evaluation 
top
prev
next
chapter
6
experience
evaluation
since
1994
rest
architectural
style
used
guide
design
development
architecture
modern
web
chapter
describes
experience
lessons
learned
applying
rest
authoring
internet
standards
hypertext
transfer
protocol
http
uniform
resource
identifiers
uri
two
specifications
define
generic
interface
used
component
interactions
web
well
deployment
technologies
form
libwww
perl
client
library
apache
http
server
project
implementations
protocol
standards
6
1
standardizing
web
described
chapter
4
motivation
developing
rest
create
architectural
model
web
work
serve
guiding
framework
web
protocol
standards
rest
applied
describe
desired
web
architecture
help
identify
existing
problems
compare
alternative
solutions
ensure
protocol
extensions
violate
core
constraints
make
web
successful
work
done
part
internet
engineering
taskforce
ietf
world
wide
web
consortium
w3c
efforts
define
architectural
standards
web
http
uri
html
involvement
web
standards
process
began
late
1993
developing
libwww
perl
protocol
library
served
client
connector
interface
momspider
39
time
web's
architecture
described
set
informal
hypertext
notes
14
two
early
introductory
papers
12
13
draft
hypertext
specifications
representing
proposed
features
web
already
implemented
archive
public
www
talk
mailing
list
used
informal
discussion
among
participants
www
project
worldwide
specifications
significantly
date
compared
web
implementations
mostly
due
rapid
evolution
web
introduction
mosaic
graphical
browser
ncsa
several
experimental
extensions
added
http
allow
proxies
part
protocol
assumed
direct
connection
user
agent
either
http
origin
server
gateway
legacy
systems
awareness
within
architecture
caching
proxies
spiders
even
though
implementations
readily
available
running
amok
many
extensions
proposed
inclusion
next
versions
protocols
time
growing
pressure
within
industry
standardize
version
versions
web
interface
protocols
w3c
formed
berners
lee
20
act
think
tank
web
architecture
supply
authoring
resources
needed
write
web
standards
reference
implementations
standardization
governed
internet
engineering
taskforce
www
ietf
org
working
groups
uri
http
html
due
experience
developing
web
software
first
chosen
author
specification
relative
url
40
later
teamed
henrik
frystyk
nielsen
author
http
1
0
specification
19
became
primary
architect
http
1
1
42
finally
authored
revision
url
specifications
form
standard
uri
generic
syntax
21
first
edition
rest
developed
october
1994
august
1995
primarily
means
communicating
web
concepts
wrote
http
1
0
specification
initial
http
1
1
proposal
iteratively
improved
next
five
years
applied
various
revisions
extensions
web
protocol
standards
rest
originally
referred
http
object
model
name
often
lead
misinterpretation
implementation
model
http
server
name
representational
state
transfer
intended
evoke
image
well
designed
web
application
behaves
network
web
pages
virtual
state
machine
user
progresses
application
selecting
links
state
transitions
resulting
next
page
representing
next
state
application
transferred
user
rendered
use
rest
intended
capture
possible
uses
web
protocol
standards
applications
http
uri
match
application
model
distributed
hypermedia
system
important
point
however
rest
capture
aspects
distributed
hypermedia
system
considered
central
behavioral
performance
requirements
web
optimizing
behavior
within
model
will
result
optimum
behavior
within
deployed
web
architecture
words
rest
optimized
common
case
constraints
applies
web
architecture
will
also
optimized
common
case
6
2
rest
applied
uri
uniform
resource
identifiers
uri
simplest
element
web
architecture
important
uri
known
many
names
www
addresses
universal
document
identifiers
universal
resource
identifiers
15
finally
combination
uniform
resource
locators
url
17
names
urn
124
aside
name
uri
syntax
remained
relatively
unchanged
since
1992
however
specification
web
addresses
also
defines
scope
semantics
mean
resource
changed
since
early
web
architecture
rest
used
define
term
resource
uri
standard
21
well
overall
semantics
generic
interface
manipulating
resources
via
representations
6
2
1
redefinition
resource
early
web
architecture
defined
uri
document
identifiers
authors
instructed
define
identifiers
terms
document's
location
network
web
protocols
used
retrieve
document
however
definition
proved
unsatisfactory
number
reasons
first
suggests
author
identifying
content
transferred
imply
identifier
change
whenever
content
changes
second
exist
many
addresses
corresponded
service
rather
document
authors
may
intending
direct
readers
service
rather
specific
result
prior
access
service
finally
exist
addresses
correspond
document
periods
time
document
yet
exist
address
used
solely
naming
rather
locating
information
definition
resource
rest
based
simple
premise
identifiers
change
infrequently
possible
web
uses
embedded
identifiers
rather
link
servers
authors
need
identifier
closely
matches
semantics
intend
hypermedia
reference
allowing
reference
remain
static
even
though
result
accessing
reference
may
change
time
rest
accomplishes
defining
resource
semantics
author
intends
identify
rather
value
corresponding
semantics
time
reference
created
left
author
ensure
identifier
chosen
reference
indeed
identify
intended
semantics
6
2
2
manipulating
shadows
defining
resource
uri
identifies
concept
rather
document
leaves
us
another
question
user
access
manipulate
transfer
concept
can
get
something
useful
hypertext
link
selected
rest
answers
question
defining
things
manipulated
representations
identified
resource
rather
resource
origin
server
maintains
mapping
resource
identifiers
set
representations
corresponding
resource
resource
therefore
manipulated
transferring
representations
generic
interface
defined
resource
identifier
rest's
definition
resource
derives
central
requirement
web
independent
authoring
interconnected
hypertext
across
multiple
trust
domains
forcing
interface
definitions
match
interface
requirements
causes
protocols
seem
vague
interface
manipulated
interface
implementation
protocols
specific
intent
application
action
mechanism
behind
interface
must
decide
intention
affects
underlying
implementation
resource
mapping
representations
information
hiding
one
key
software
engineering
principles
motivates
uniform
interface
rest
client
restricted
manipulation
representations
rather
directly
accessing
implementation
resource
implementation
can
constructed
whatever
form
desired
naming
authority
without
impacting
clients
may
use
representations
addition
multiple
representations
resource
exist
time
accessed
content
selection
algorithm
can
used
dynamically
select
representation
best
fits
capabilities
client
disadvantage
course
remote
authoring
resource
straightforward
remote
authoring
file
6
2
3
remote
authoring
challenge
remote
authoring
via
web's
uniform
interface
due
separation
representation
can
retrieved
client
mechanism
might
used
server
store
generate
retrieve
content
representation
individual
server
may
map
part
namespace
filesystem
turn
maps
equivalent
inode
can
mapped
disk
location
underlying
mechanisms
provide
means
associating
resource
set
representations
rather
identifying
resource
many
different
resources
map
representation
resources
may
representation
mapped
order
author
existing
resource
author
must
first
obtain
specific
source
resource
uri
set
uri
bind
handler's
underlying
representation
target
resource
resource
always
map
singular
file
resources
static
derived
resources
following
derivation
tree
author
can
eventually
find
source
resources
must
edited
order
modify
representation
resource
principles
apply
form
derived
representation
whether
content
negotiation
scripts
servlets
managed
configurations
versioning
etc
resource
storage
object
resource
mechanism
server
uses
handle
storage
object
resource
conceptual
mapping
server
receives
identifier
identifies
mapping
applies
current
mapping
implementation
usually
combination
collection
specific
deep
tree
traversal
hash
tables
find
currently
responsible
handler
implementation
handler
implementation
selects
appropriate
action
response
based
request
content
implementation
specific
issues
hidden
behind
web
interface
nature
assumed
client
access
web
interface
example
consider
happens
web
site
grows
user
base
decides
replace
old
brand
server
based
xos
platform
new
apache
server
running
freebsd
disk
storage
hardware
replaced
operating
system
replaced
http
server
replaced
perhaps
even
method
generating
responses
content
replaced
however
need
change
web
interface
designed
correctly
namespace
new
server
can
mirror
old
meaning
client's
perspective
knows
resources
implemented
nothing
changed
aside
improved
robustness
site
6
2
4
binding
semantics
uri
mentioned
resource
can
many
identifiers
words
may
exist
two
different
uri
equivalent
semantics
used
access
server
also
possible
two
uri
result
mechanism
used
upon
access
server
yet
uri
identify
two
different
resources
mean
thing
semantics
product
act
assigning
resource
identifiers
populating
resources
representations
time
whatsoever
server
client
software
need
know
understand
meaning
uri
merely
act
conduit
creator
resource
human
naming
authority
can
associate
representations
semantics
identified
uri
words
resources
server
just
mechanisms
supply
answers
across
abstract
interface
defined
resources
may
seem
odd
essence
makes
web
work
across
many
different
implementations
nature
every
engineer
define
things
terms
characteristics
components
will
used
compose
finished
product
web
work
way
web
architecture
consists
constraints
communication
model
components
based
role
component
application
action
prevents
components
assuming
anything
beyond
resource
abstraction
thus
hiding
actual
mechanisms
either
side
abstract
interface
6
2
5
rest
mismatches
uri
like
real
world
systems
components
deployed
web
architecture
obey
every
constraint
present
architectural
design
rest
used
means
define
architectural
improvements
identify
architectural
mismatches
mismatches
occur
due
ignorance
oversight
software
implementation
deployed
violates
architectural
constraints
mismatches
avoided
general
possible
identify
become
standardized
although
uri
design
matches
rest's
architectural
notion
identifiers
syntax
alone
insufficient
force
naming
authorities
define
uri
according
resource
model
one
form
abuse
include
information
identifies
current
user
within
uri
referenced
hypermedia
response
representation
embedded
user
ids
can
used
maintain
session
state
server
track
user
behavior
logging
actions
carry
user
preferences
across
multiple
actions
hyper
g's
gateways
84
however
violating
rest's
constraints
systems
also
cause
shared
caching
become
ineffective
reduce
server
scalability
result
undesirable
effects
user
shares
references
others
another
conflict
resource
interface
rest
occurs
software
attempts
treat
web
distributed
file
system
since
file
systems
expose
implementation
information
tools
exist
mirror
information
across
multiple
sites
means
load
balancing
redistributing
content
closer
users
however
can
files
fixed
set
semantics
named
sequence
bytes
can
duplicated
easily
contrast
attempts
mirror
content
web
server
files
will
fail
resource
interface
always
match
semantics
file
system
data
metadata
included
within
significant
semantics
representation
web
server
content
can
replicated
remote
sites
replicating
entire
server
mechanism
configuration
selectively
replicating
resources
representations
known
static
cache
networks
contract
web
sites
replicate
specific
resource
representations
edges
overall
internet
order
reduce
latency
distribute
load
away
origin
server
6
3
rest
applied
http
hypertext
transfer
protocol
http
special
role
web
architecture
primary
application
level
protocol
communication
web
components
protocol
designed
specifically
transfer
resource
representations
unlike
uri
large
number
changes
needed
order
http
support
modern
web
architecture
developers
http
implementations
conservative
adoption
proposed
enhancements
thus
extensions
needed
proven
subjected
standards
review
deployed
rest
used
identify
problems
existing
http
implementations
specify
interoperable
subset
protocol
http
1
0
19
analyze
proposed
extensions
http
1
1
42
provide
motivating
rationale
deploying
http
1
1
key
problem
areas
http
identified
rest
included
planning
deployment
new
protocol
versions
separating
message
parsing
http
semantics
underlying
transport
layer
tcp
distinguishing
authoritative
non
authoritative
responses
fine
grained
control
caching
various
aspects
protocol
failed
self
descriptive
rest
also
used
model
performance
web
applications
based
http
anticipate
impact
extensions
persistent
connections
content
negotiation
finally
rest
used
limit
scope
standardized
http
extensions
fit
within
architectural
model
rather
allowing
applications
misuse
http
equally
influence
standard
6
3
1
extensibility
one
major
goals
rest
support
gradual
fragmented
deployment
changes
within
already
deployed
architecture
http
modified
support
goal
introduction
versioning
requirements
rules
extending
protocol's
syntax
elements
6
3
1
1
protocol
versioning
http
family
protocols
distinguished
major
minor
version
numbers
share
name
primarily
correspond
protocol
expected
communicating
directly
service
based
http
url
namespace
connector
must
obey
constraints
placed
http
version
protocol
element
included
message
90
http
version
message
represents
protocol
capabilities
sender
gross
compatibility
major
version
number
message
sent
allows
client
use
reduced
http
1
0
subset
features
making
normal
http
1
1
request
time
indicating
recipient
capable
supporting
full
http
1
1
communication
words
provides
tentative
form
protocol
negotiation
http
scale
connection
request
response
chain
can
operate
best
protocol
level
spite
limitations
clients
servers
parts
chain
intention
protocol
server
always
respond
highest
minor
version
protocol
understands
within
major
version
client's
request
message
restriction
server
use
optional
features
higher
level
protocol
forbidden
sent
older
version
client
required
features
protocol
used
minor
versions
within
major
version
since
incompatible
change
thus
require
change
major
version
features
http
can
depend
minor
version
number
change
interpreted
immediate
neighbors
communication
http
require
entire
request
response
chain
intermediary
components
speak
version
rules
exist
assist
deployment
multiple
protocol
revisions
prevent
http
architects
forgetting
deployment
protocol
important
aspect
design
making
easy
differentiate
compatible
changes
protocol
incompatible
changes
compatible
changes
easy
deploy
communication
differences
can
achieved
within
protocol
stream
incompatible
changes
difficult
deploy
require
determination
acceptance
protocol
protocol
stream
can
commence
6
3
1
2
extensible
protocol
elements
http
includes
number
separate
namespaces
differing
constraints
share
requirement
extensible
without
bound
namespaces
governed
separate
internet
standards
shared
multiple
protocols
uri
schemes
21
media
types
48
mime
header
field
names
47
charset
values
language
tags
others
governed
http
including
namespaces
method
names
response
status
codes
non
mime
header
field
names
values
within
standard
http
header
fields
since
early
http
define
consistent
set
rules
changes
within
namespaces
deployed
one
first
problems
tackled
specification
effort
http
request
semantics
signified
request
method
name
method
extension
allowed
whenever
standardizable
set
semantics
can
shared
client
server
intermediaries
may
unfortunately
early
http
extensions
specifically
head
method
made
parsing
http
response
message
dependent
knowing
semantics
request
method
led
deployment
contradiction
recipient
needs
know
semantics
method
can
safely
forwarded
intermediary
intermediaries
must
updated
new
method
can
deployed
deployment
problem
fixed
separating
rules
parsing
forwarding
http
messages
semantics
associated
new
http
protocol
elements
example
head
method
content
length
header
field
meaning
signifying
message
body
length
new
method
can
change
message
length
calculation
get
head
also
methods
conditional
request
header
fields
semantics
cache
refresh
whereas
methods
meaning
precondition
likewise
http
needed
general
rule
interpreting
new
response
status
codes
new
responses
deployed
without
significantly
harming
older
clients
therefore
expanded
upon
rule
status
code
belonged
class
signified
first
digit
three
digit
decimal
number
100
199
indicating
message
contains
provisional
information
response
200
299
indicating
request
succeeded
300
399
indicating
request
needs
redirected
another
resource
400
499
indicating
client
made
error
repeated
500
599
indicating
server
encountered
error
client
may
get
better
response
later
via
server
recipient
understand
specific
semantics
status
code
given
message
must
treat
way
x00
code
within
class
like
rule
method
names
extensibility
rule
places
requirement
current
architecture
anticipates
future
change
changes
can
therefore
deployed
onto
existing
architecture
less
fear
adverse
component
reactions
6
3
1
3
upgrade
addition
upgrade
header
field
http
1
1
reduces
difficulty
deploying
incompatible
changes
allowing
client
advertise
willingness
better
protocol
communicating
older
protocol
stream
upgrade
specifically
added
support
selective
replacement
http
1
future
protocols
might
efficient
tasks
thus
http
supports
internal
extensibility
also
complete
replacement
active
connection
server
supports
improved
protocol
desires
switch
simply
responds
101
status
continues
request
received
upgraded
protocol
6
3
2
self
descriptive
messages
rest
constrains
messages
components
self
descriptive
order
support
intermediate
processing
interactions
however
aspects
early
http
failed
self
descriptive
including
lack
host
identification
within
requests
failure
syntactically
distinguish
message
control
data
representation
metadata
failure
differentiate
control
data
intended
immediate
connection
peer
versus
metadata
intended
recipients
lack
support
mandatory
extensions
need
metadata
describe
representations
layered
encodings
6
3
2
1
host
one
worst
mistakes
early
http
design
decision
send
complete
uri
target
request
message
rather
send
portions
used
setting
connection
assumption
server
know
naming
authority
based
ip
address
tcp
port
connection
however
failed
anticipate
multiple
naming
authorities
might
exist
single
server
became
critical
problem
web
grew
exponential
rate
new
domain
names
basis
naming
authority
within
http
url
namespace
far
exceeded
availability
new
ip
addresses
solution
defined
deployed
http
1
0
http
1
1
include
target
url's
host
information
within
host
header
field
request
message
deployment
feature
considered
important
http
1
1
specification
requires
servers
reject
http
1
1
request
include
host
field
result
now
exist
many
large
isp
servers
run
tens
thousands
name
based
virtual
host
websites
single
ip
address
6
3
2
2
layered
encodings
http
inherited
syntax
describing
representation
metadata
multipurpose
internet
mail
extensions
mime
47
mime
define
layered
media
types
preferring
instead
include
label
outermost
media
type
within
content
type
field
value
however
prevents
recipient
determining
nature
encoded
message
without
decoding
layers
early
http
extension
worked
around
failing
listing
outer
encodings
separately
within
content
encoding
field
placing
label
innermost
media
type
content
type
poor
design
decision
since
changed
semantics
content
type
without
changing
field
name
resulting
confusion
whenever
older
user
agents
encountered
extension
better
solution
continue
treating
content
type
outermost
media
type
use
new
field
describe
nested
types
within
type
unfortunately
first
extension
deployed
faults
identified
rest
identify
need
another
layer
encodings
placed
message
connector
order
improve
transferability
network
new
layer
called
transfer
encoding
reference
similar
concept
mime
allows
messages
encoded
transfer
without
implying
representation
encoded
nature
transfer
encodings
can
added
removed
transfer
agents
whatever
reason
without
changing
semantics
representation
6
3
2
3
semantic
independence
described
http
message
parsing
separated
semantics
message
parsing
including
finding
globbing
together
header
fields
occurs
entirely
separate
process
parsing
header
field
contents
way
intermediaries
can
quickly
process
forward
http
messages
extensions
can
deployed
without
breaking
existing
parsers
6
3
2
4
transport
independence
early
http
including
implementations
http
1
0
used
underlying
transport
protocol
means
signaling
end
response
message
server
indicate
end
response
message
body
closing
tcp
connection
unfortunately
created
significant
failure
condition
protocol
client
means
distinguishing
completed
response
one
truncated
erroneous
network
failure
solve
content
length
header
fields
redefined
within
http
1
0
indicate
message
body
length
bytes
whenever
length
known
advance
chunked
transfer
encoding
introduced
http
1
1
chunked
encoding
allows
representation
whose
size
unknown
beginning
generation
header
fields
sent
boundaries
delineated
series
chunks
can
individually
sized
sent
also
allows
metadata
sent
end
message
trailers
enabling
creation
optional
metadata
origin
message
generated
without
adding
response
latency
6
3
2
5
size
limits
frequent
barrier
flexibility
application
layer
protocols
tendency
specify
size
limits
protocol
parameters
although
always
exist
practical
limits
within
implementations
protocol
available
memory
specifying
limits
within
protocol
restricts
applications
limits
regardless
implementation
result
often
lowest
common
denominator
protocol
extended
much
beyond
envisioning
original
creator
limit
http
protocol
length
uri
length
header
fields
length
representation
length
field
value
consists
list
items
although
older
web
clients
well
known
problem
uri
consist
255
characters
sufficient
note
problem
http
specification
rather
require
servers
limited
reason
make
protocol
maximum
applications
within
controlled
context
intranet
can
avoid
limits
replacing
older
components
although
need
invent
artificial
limitations
http
1
1
need
define
appropriate
set
response
status
codes
indicating
given
protocol
element
long
server
process
response
codes
added
conditions
request
uri
long
header
field
long
body
long
unfortunately
way
client
indicate
server
may
resource
limits
leads
problems
resource
constrained
devices
pdas
attempt
use
http
without
device
specific
intermediary
adjusting
communication
6
3
2
6
cache
control
rest
tries
balance
need
efficient
low
latency
behavior
desire
semantically
transparent
cache
behavior
critical
http
allow
application
determine
caching
requirements
rather
hard
code
protocol
important
thing
protocol
fully
accurately
describe
data
transferred
application
fooled
thinking
one
thing
actually
something
else
http
1
1
addition
cache
control
age
etag
vary
header
fields
6
3
2
7
content
negotiation
resources
map
request
consisting
method
identifier
request
header
fields
sometimes
representation
response
consisting
status
code
response
header
fields
sometimes
representation
http
request
maps
multiple
representations
server
server
may
engage
content
negotiation
client
order
determine
one
best
meets
client's
needs
really
content
selection
process
negotiation
although
several
deployed
implementations
content
negotiation
included
specification
http
1
0
interoperable
subset
implementations
time
published
partly
due
poor
implementation
within
ncsa
mosaic
send
1kb
preference
information
header
fields
every
request
regardless
negotiability
resource
125
since
far
less
0
01
uri
negotiable
content
result
substantially
increased
request
latency
little
gain
led
later
browsers
disregarding
negotiation
features
http
1
0
preemptive
server
driven
negotiation
occurs
server
varies
response
representation
particular
request
method
identifier
status
code
combination
according
value
request
header
fields
something
external
normal
request
parameters
client
needs
notified
occurs
cache
can
know
semantically
transparent
use
particular
cached
response
future
request
also
user
agent
can
supply
detailed
preferences
might
normally
send
knows
effect
response
received
http
1
1
introduced
vary
header
field
purpose
vary
simply
lists
request
header
field
dimensions
response
may
vary
preemptive
negotiation
user
agent
tells
server
capable
accepting
server
supposed
select
representation
best
matches
user
agent
claims
capabilities
however
non
tractable
problem
requires
information
ua
will
accept
also
well
accepts
feature
purpose
user
intends
put
representation
example
user
wants
view
image
screen
might
prefer
simple
bitmap
representation
user
browser
may
prefer
postscript
representation
intend
send
printer
instead
also
depends
user
correctly
configuring
browser
according
personal
content
preferences
short
server
rarely
able
make
effective
use
preemptive
negotiation
form
automated
content
selection
defined
early
http
http
1
1
added
notion
reactive
agent
driven
negotiation
case
user
agent
requests
negotiated
resource
server
responds
list
available
representations
user
agent
can
choose
one
best
according
capabilities
purpose
information
available
representations
may
supplied
via
separate
representation
300
response
inside
response
data
conditional
html
supplement
likely
response
latter
works
best
web
additional
interaction
becomes
necessary
user
agent
decides
one
variants
better
reactive
negotiation
simply
automated
reflection
normal
browser
model
means
can
take
full
advantage
performance
benefits
rest
preemptive
reactive
negotiation
suffer
difficulty
communicating
actual
characteristics
representation
dimensions
say
browser
supports
html
tables
insert
element
however
reactive
negotiation
distinct
advantages
send
preferences
every
request
context
information
make
decision
faced
alternatives
interfering
caches
third
form
negotiation
transparent
negotiation
64
license
intermediary
cache
act
agent
behalf
agents
selecting
better
representation
initiating
requests
retrieve
representation
request
may
resolved
internally
another
cache
hit
thus
possible
additional
network
request
will
made
however
performing
server
driven
negotiation
must
therefore
add
appropriate
vary
information
outbound
caches
confused
6
3
3
performance
http
1
1
focused
improving
semantics
communication
components
also
improvements
user
perceived
performance
albeit
limited
requirement
syntax
compatibility
http
1
0
6
3
3
1
persistent
connections
although
early
http's
single
request
response
per
connection
behavior
made
simple
implementations
resulted
inefficient
use
underlying
tcp
transport
due
overhead
per
interaction
set
costs
nature
tcp's
slow
start
congestion
control
algorithm
63
125
result
several
extensions
proposed
combine
multiple
requests
responses
within
single
connection
first
proposal
define
new
set
methods
encapsulating
multiple
requests
within
single
message
mget
mhead
etc
returning
response
mime
multipart
rejected
violated
several
rest
constraints
first
client
need
know
requests
wanted
package
first
request
written
network
since
request
body
must
length
delimited
content
length
field
set
initial
request
header
fields
second
intermediaries
extract
messages
determine
ones
satisfy
locally
finally
effectively
doubles
number
request
methods
complicates
mechanisms
selectively
denying
access
certain
methods
instead
adopted
form
persistent
connections
uses
length
delimited
messages
order
send
multiple
http
messages
single
connection
100
http
1
0
done
using
keep
alive
directive
within
connection
header
field
unfortunately
work
general
header
field
forwarded
intermediaries
intermediaries
understand
keep
alive
resulting
dead
lock
condition
http
1
1
eventually
settled
making
persistent
connections
default
thus
signaling
presence
via
http
version
value
using
connection
directive
close
reverse
default
important
note
persistent
connections
became
possible
http
messages
redefined
self
descriptive
independent
underlying
transport
protocol
6
3
3
2
write
caching
http
support
write
back
caching
http
cache
assume
gets
written
retrievable
subsequent
request
resource
thus
cache
put
request
body
reuse
later
get
response
two
reasons
rule
1
metadata
might
generated
behind
scenes
2
access
control
later
get
requests
determined
put
request
however
since
write
actions
using
web
extremely
rare
lack
write
back
caching
significant
impact
performance
6
3
4
rest
mismatches
http
several
architectural
mismatches
present
within
http
due
3rd
party
extensions
deployed
external
standards
process
others
due
necessity
remaining
compatible
deployed
http
1
0
components
6
3
4
1
differentiating
non
authoritative
responses
one
weakness
still
exists
http
consistent
mechanism
differentiating
authoritative
responses
generated
origin
server
response
current
request
non
authoritative
responses
obtained
intermediary
cache
without
accessing
origin
server
distinction
can
important
applications
require
authoritative
responses
safety
critical
information
appliances
used
within
health
industry
times
error
response
returned
client
left
wondering
whether
error
due
origin
intermediary
attempts
solve
using
additional
status
codes
succeed
since
authoritative
nature
usually
orthogonal
response
status
http
1
1
add
mechanism
control
cache
behavior
desire
authoritative
response
can
indicated
'no
cache'
directive
request
message
requires
cache
forward
request
toward
origin
server
even
cached
copy
requested
allows
client
refresh
cached
copy
known
corrupted
stale
however
using
field
regular
basis
interferes
performance
benefits
caching
general
solution
require
responses
marked
non
authoritative
whenever
action
result
contacting
origin
server
warning
response
header
field
defined
http
1
1
purpose
others
widely
implemented
practice
6
3
4
2
cookies
example
inappropriate
extension
made
protocol
support
features
contradict
desired
properties
generic
interface
introduction
site
wide
state
information
form
http
cookies
73
cookie
interaction
fails
match
rest's
model
application
state
often
resulting
confusion
typical
browser
application
http
cookie
opaque
data
can
assigned
origin
server
user
agent
including
within
set
cookie
response
header
field
intention
user
agent
include
cookie
future
requests
server
replaced
expires
cookies
typically
contain
array
user
specific
configuration
choices
token
matched
server's
database
future
requests
problem
cookie
defined
attached
future
requests
given
set
resource
identifiers
usually
encompassing
entire
site
rather
associated
particular
application
state
set
currently
rendered
representations
browser
browser's
history
functionality
back
button
subsequently
used
back
view
prior
reflected
cookie
browser's
application
state
longer
matches
stored
state
represented
within
cookie
therefore
next
request
sent
server
will
contain
cookie
misrepresents
current
application
context
leading
confusion
sides
cookies
also
violate
rest
allow
data
passed
without
sufficiently
identifying
semantics
thus
becoming
concern
security
privacy
combination
cookies
referer
sic
header
field
makes
possible
track
user
browse
sites
result
cookie
based
applications
web
will
never
reliable
functionality
accomplished
via
anonymous
authentication
true
client
side
state
state
mechanism
involves
preferences
can
efficiently
implemented
using
judicious
use
context
setting
uri
rather
cookies
judicious
means
one
uri
per
state
rather
unbounded
number
uri
due
embedding
user
id
likewise
use
cookies
identify
user
specific
shopping
basket
within
server
side
database
efficiently
implemented
defining
semantics
shopping
items
within
hypermedia
data
formats
allowing
user
agent
select
store
items
within
client
side
shopping
basket
complete
uri
used
check
client
ready
purchase
6
3
4
3
mandatory
extensions
http
header
field
names
can
extended
will
information
contain
required
proper
understanding
message
mandatory
header
field
extensions
require
major
protocol
revision
substantial
change
method
semantics
proposed
94
aspect
modern
web
architecture
yet
match
self
descriptive
messaging
constraints
rest
architectural
style
primarily
cost
implementing
mandatory
extension
framework
within
existing
http
syntax
exceeds
clear
benefits
might
gain
mandatory
extensions
however
reasonable
expect
mandatory
field
name
extensions
will
supported
next
major
revision
http
existing
constraints
backwards
compatibility
syntax
longer
apply
6
3
4
4
mixing
metadata
http
designed
extend
generic
connector
interface
across
network
connection
intended
match
characteristics
interface
including
delineation
parameters
control
data
metadata
representation
however
two
significant
limitations
http
1
protocol
family
fails
syntactically
distinguish
representation
metadata
message
control
information
transmitted
header
fields
allow
metadata
effectively
layered
message
integrity
checks
rest
identified
limitations
protocol
early
standardization
process
anticipating
lead
problems
deployment
features
persistent
connections
digest
authentication
workarounds
developed
including
adding
connection
header
field
identify
per
connection
control
data
unsafe
forwarded
intermediaries
well
algorithm
canonical
treatment
header
field
digests
46
6
3
4
5
mime
syntax
http
inherited
message
syntax
mime
47
order
retain
commonality
internet
protocols
reuse
many
standardized
fields
describing
media
types
messages
unfortunately
mime
http
different
goals
syntax
designed
mime's
goals
mime
user
agent
sending
bunch
information
intended
treated
coherent
whole
unknown
recipient
never
directly
interact
mime
assumes
agent
want
send
information
one
message
since
sending
multiple
messages
across
internet
mail
less
efficient
thus
mime
syntax
constructed
package
messages
within
part
multipart
much
way
postal
carriers
wrap
packages
extra
paper
http
packaging
different
objects
within
single
message
make
sense
secure
encapsulation
packaged
archives
since
efficient
make
separate
requests
documents
already
cached
thus
http
applications
use
media
types
like
html
containers
references
package
user
agent
can
choose
parts
package
retrieve
separate
requests
although
possible
http
use
multipart
package
non
uri
resources
included
first
part
much
demand
problem
mime
syntax
assumes
transport
lossy
deliberately
corrupting
things
like
line
breaks
content
lengths
syntax
therefore
verbose
inefficient
system
based
lossy
transport
makes
inappropriate
http
since
http
1
1
capability
support
deployment
incompatible
protocols
retaining
mime
syntax
necessary
next
major
version
http
even
though
will
likely
continue
use
many
standardized
protocol
elements
representation
metadata
6
3
5
matching
responses
requests
http
messages
fail
self
descriptive
comes
describing
response
belongs
request
early
http
based
single
request
response
per
connection
perceived
need
message
control
data
tie
response
back
request
invoked
therefore
ordering
requests
determines
ordering
responses
means
http
relies
transport
connection
determine
match
http
1
1
though
defined
independent
transport
protocol
still
assumes
communication
takes
place
synchronous
transport
easily
extended
work
asynchronous
transport
mail
addition
request
identifier
extension
useful
agents
broadcast
multicast
situation
responses
might
received
channel
different
request
also
situation
many
requests
pending
allow
server
choose
order
responses
transferred
smaller
significant
responses
sent
first
6
4
technology
transfer
although
rest
direct
influence
authoring
web
standards
validation
use
architectural
design
model
came
deployment
standards
form
commercial
grade
implementations
6
4
1
deployment
experience
libwww
perl
involvement
definition
web
standards
began
development
maintenance
robot
momspider
39
associated
protocol
library
libwww
perl
modeled
original
libwww
developed
tim
berners
lee
www
project
cern
libwww
perl
provided
uniform
interface
making
web
requests
interpreting
web
responses
client
applications
written
perl
language
134
first
web
protocol
library
developed
independent
original
cern
project
reflecting
modern
interpretation
web
interface
present
older
code
bases
interface
became
basis
designing
rest
libwww
perl
consisted
single
request
interface
used
perl's
self
evaluating
code
features
dynamically
load
appropriate
transport
protocol
package
based
scheme
requested
uri
example
asked
make
get
request
url
http
www
ebuilt
com
libwww
perl
extract
scheme
url
http
use
construct
call
wwwhttp'request
using
interface
common
types
resources
http
ftp
wais
local
files
etc
order
achieve
generic
interface
library
treated
calls
much
way
http
proxy
provided
interface
using
perl
data
structures
semantics
http
request
regardless
type
resource
libwww
perl
demonstrated
benefits
generic
interface
within
year
initial
release
600
independent
software
developers
using
library
client
tools
ranging
command
line
download
scripts
full
blown
browsers
currently
basis
web
system
administration
tools
6
4
2
deployment
experience
apache
specification
effort
http
began
take
form
complete
specifications
needed
server
software
effectively
demonstrate
proposed
standard
protocol
serve
test
bed
worthwhile
extensions
time
popular
http
server
httpd
public
domain
software
developed
rob
mccool
national
center
supercomputing
applications
university
illinois
urbana
champaign
ncsa
however
development
stalled
rob
left
ncsa
mid
1994
many
webmasters
developed
extensions
bug
fixes
need
common
distribution
group
us
created
mailing
list
purpose
coordinating
changes
patches
original
source
process
created
apache
http
server
project
89
apache
project
collaborative
software
development
effort
aimed
creating
robust
commercial
grade
full
featured
open
source
software
implementation
http
server
project
jointly
managed
group
volunteers
located
around
world
using
internet
web
communicate
plan
develop
server
related
documentation
volunteers
known
apache
group
recently
group
formed
nonprofit
apache
software
foundation
act
legal
financial
umbrella
organization
supporting
continued
development
apache
open
source
projects
apache
became
known
robust
behavior
response
varied
demands
internet
service
rigorous
implementation
http
protocol
standards
served
protocol
cop
within
apache
group
writing
code
core
http
parsing
functions
supporting
efforts
others
explaining
standards
acting
advocate
apache
developers'
views
right
way
implement
http
within
standards
forums
many
lessons
described
chapter
learned
result
creating
testing
various
implementations
http
within
apache
project
subjecting
theories
behind
protocol
apache
group's
critical
review
apache
httpd
widely
regarded
one
successful
software
projects
one
first
open
source
software
products
dominate
market
exists
significant
commercial
competition
july
2000
netcraft
survey
public
internet
websites
found
20
million
sites
based
apache
software
representing
65
sites
surveyed
http
www
netcraft
com
survey
apache
first
major
server
support
http
1
1
protocol
generally
considered
reference
implementation
client
software
tested
apache
group
received
1999
acm
software
system
award
recognition
impact
standards
web
architecture
6
4
3
deployment
uri
http
1
1
compliant
software
addition
apache
many
projects
commercial
open
source
nature
adopted
deployed
software
products
based
protocols
modern
web
architecture
though
may
coincidence
microsoft
internet
explorer
surpassed
netscape
navigator
web
browser
market
share
shortly
first
major
browser
implement
http
1
1
client
standard
addition
many
individual
http
extensions
defined
standardization
process
host
header
field
now
reached
universal
deployment
rest
architectural
style
succeeded
guiding
design
deployment
modern
web
architecture
date
significant
problems
caused
introduction
new
standards
even
though
subject
gradual
fragmented
deployment
alongside
legacy
web
applications
furthermore
new
standards
positive
effect
robustness
web
enabled
new
methods
improving
user
perceived
performance
caching
hierarchies
content
distribution
networks
6
5
architectural
lessons
number
general
architectural
lessons
learned
modern
web
architecture
problems
identified
rest
6
5
1
advantages
network
based
api
distinguishes
modern
web
middleware
22
way
uses
http
network
based
application
programming
interface
api
always
case
early
web
design
made
use
library
package
cern
libwww
single
implementation
library
clients
servers
cern
libwww
provided
library
based
api
building
interoperable
web
components
library
based
api
provides
set
code
entry
points
associated
symbol
parameter
sets
programmer
can
use
someone
else's
code
dirty
work
maintaining
actual
interface
like
systems
provided
programmer
obeys
architectural
language
restrictions
come
code
assumption
sides
communication
use
api
therefore
internals
interface
important
api
developer
application
developer
single
library
approach
ended
1993
match
social
dynamics
organizations
involved
developing
web
team
ncsa
increased
pace
web
development
much
larger
development
team
ever
present
cern
libwww
source
forked
split
separately
maintained
code
bases
folks
ncsa
wait
cern
catch
improvements
time
independent
developers
began
developing
protocol
libraries
languages
platforms
yet
supported
cern
code
design
web
shift
development
reference
protocol
library
development
network
based
api
extending
desired
semantics
web
across
multiple
platforms
implementations
network
based
api
wire
syntax
defined
semantics
application
interactions
network
based
api
place
restrictions
application
code
aside
need
read
write
network
place
restrictions
set
semantics
can
effectively
communicated
across
interface
plus
side
performance
bounded
protocol
design
particular
implementation
design
library
based
api
lot
programmer
creates
great
deal
complexity
baggage
needed
one
system
less
portable
heterogeneous
network
always
results
genericity
preferred
performance
side
effect
also
leads
lazy
development
blaming
api
code
everything
failure
account
non
cooperative
behavior
parties
communication
however
important
keep
mind
various
layers
involved
architecture
including
modern
web
systems
like
web
use
one
library
api
sockets
order
access
several
network
based
apis
http
ftp
socket
api
application
layer
likewise
libwww
interesting
cross
breed
evolved
library
based
api
accessing
network
based
api
thus
provides
reusable
code
without
assuming
communicating
applications
using
libwww
well
contrast
middleware
like
corba
97
since
corba
allows
communication
via
orb
transfer
protocol
iiop
assumes
much
parties
communicating
http
request
messages
include
standardized
application
semantics
whereas
iiop
messages
request
token
iiop
supplies
directionality
orb
can
route
according
whether
orb
supposed
reply
locaterequest
will
interpreted
object
semantics
expressed
combination
object
key
operation
object
specific
rather
standardized
across
objects
independent
developer
can
generate
bits
iiop
request
without
using
orb
bits
defined
corba
api
interface
definition
language
idl
need
uuid
generated
idl
compiler
structured
binary
content
mirrors
idl
operation's
signature
definition
reply
data
type
according
idl
specification
semantics
thus
defined
network
interface
iiop
object's
idl
spec
whether
good
thing
depends
application
distributed
objects
necessity
web
important
differentiates
system
network
intermediaries
can
effective
agents
system
can
routers
kind
difference
also
seen
interpretation
message
unit
stream
http
allows
recipient
sender
decide
corba
idl
even
allow
streams
yet
even
get
extended
support
streams
sides
communication
will
tied
api
rather
free
use
whatever
appropriate
type
application
6
5
2
http
rpc
people
often
mistakenly
refer
http
remote
procedure
call
rpc
23
mechanism
simply
involves
requests
responses
distinguishes
rpc
forms
network
based
application
communication
notion
invoking
procedure
remote
machine
wherein
protocol
identifies
procedure
passes
fixed
set
parameters
waits
answer
supplied
within
return
message
using
interface
remote
method
invocation
rmi
similar
except
procedure
identified
object
method
tuple
rather
service
procedure
brokered
rmi
adds
name
service
indirection
tricks
interface
basically
distinguishes
http
rpc
syntax
even
different
characteristics
gained
using
stream
parameter
though
helps
explain
existing
rpc
mechanisms
usable
web
makes
http
significantly
different
rpc
requests
directed
resources
using
generic
interface
standard
semantics
can
interpreted
intermediaries
almost
well
machines
originate
services
result
application
allows
layers
transformation
indirection
independent
information
origin
useful
internet
scale
multi
organization
anarchically
scalable
information
system
rpc
mechanisms
contrast
defined
terms
language
apis
network
based
applications
6
5
3
http
transport
protocol
http
designed
transport
protocol
transfer
protocol
messages
reflect
semantics
web
architecture
performing
actions
resources
transfer
manipulation
representations
resources
possible
achieve
wide
range
functionality
using
simple
interface
following
interface
required
order
http
semantics
remain
visible
intermediaries
http
goes
firewalls
recently
proposed
extensions
http
aside
webdav
60
merely
used
http
way
move
application
protocols
firewall
fundamentally
misguided
idea
defeat
purpose
firewall
work
long
term
firewall
vendors
will
simply
perform
additional
protocol
filtering
therefore
makes
sense
extensions
top
http
since
thing
http
accomplishes
situation
add
overhead
legacy
syntax
true
application
http
maps
protocol
user's
actions
something
can
expressed
using
http
semantics
thus
creating
network
based
api
services
can
understood
agents
intermediaries
without
knowledge
application
6
5
4
design
media
types
one
aspect
rest
unusual
architectural
style
degree
influences
definition
data
elements
within
web
architecture
6
5
4
1
application
state
network
based
system
rest
defines
model
expected
application
behavior
supports
simple
robust
applications
largely
immune
partial
failure
conditions
beset
network
based
applications
however
stop
application
developers
introducing
features
violate
model
frequent
violations
regard
constraints
application
state
stateless
interaction
architectural
mismatches
due
misplaced
application
state
limited
http
cookies
introduction
frames
hypertext
markup
language
html
caused
similar
confusion
frames
allow
browser
window
partitioned
subwindows
navigational
state
link
selections
within
subwindow
indistinguishable
normal
transitions
resulting
response
representation
rendered
within
subwindow
instead
full
browser
application
workspace
fine
provided
link
exits
realm
information
intended
subwindow
treatment
occur
user
finds
themself
viewing
one
application
wedged
within
subcontext
another
application
frames
cookies
failure
providing
indirect
application
state
managed
interpreted
user
agent
design
placed
information
within
primary
representation
thereby
informing
user
agent
manage
hypermedia
workspace
specified
realm
resources
accomplished
tasks
without
violating
rest
constraints
leading
better
user
interface
less
interference
caching
6
5
4
2
incremental
processing
including
latency
reduction
architectural
goal
rest
can
differentiate
media
types
data
format
representations
according
user
perceived
performance
size
structure
capacity
incremental
rendering
impact
latency
encountered
transferring
rendering
manipulating
representation
media
types
thus
can
significantly
impact
system
performance
html
18
example
media
type
part
good
latency
characteristics
information
within
early
html
rendered
received
rendering
information
available
early
within
standardized
definitions
small
set
mark
tags
made
html
however
aspects
html
designed
well
latency
examples
include
placement
embedded
metadata
within
head
document
resulting
optional
information
needing
transferred
processed
rendering
engine
can
read
parts
display
something
useful
user
93
embedded
images
without
rendering
size
hints
requiring
first
bytes
image
part
contains
layout
size
received
rest
surrounding
html
can
displayed
dynamically
sized
table
columns
requiring
renderer
read
determine
sizes
entire
table
can
start
displaying
top
lazy
rules
regarding
parsing
malformed
mark
syntax
often
requiring
rendering
engine
parse
entire
file
can
determine
one
key
mark
character
missing
6
5
4
3
java
versus
javascript
rest
can
also
used
gain
insight
media
types
greater
adoption
within
web
architecture
others
even
balance
developer
opinion
favor
case
java
applets
versus
javascript
one
example
javatm
45
popular
programming
language
originally
developed
applications
within
television
set
top
boxes
first
gained
notoriety
introduced
web
means
implementing
code
demand
functionality
although
language
received
tremendous
amount
press
support
owner
sun
microsystems
inc
rave
reviews
software
developers
seeking
alternative
language
failed
widely
adopted
application
developers
code
demand
within
web
shortly
java's
introduction
developers
netscape
communications
corporation
created
separate
language
embedded
code
demand
originally
called
livescript
later
changed
name
javascript
marketing
reasons
two
languages
relatively
little
common
44
although
initially
derided
embedded
html
yet
compatible
proper
html
syntax
javascript
usage
steadily
increased
ever
since
introduction
question
javascript
successful
web
java
certainly
technical
quality
language
since
syntax
execution
environment
considered
poor
compared
java
also
marketing
sun
far
outspent
netscape
regard
continues
intrinsic
characteristics
languages
either
since
java
successful
javascript
within
programming
areas
stand
alone
applications
servlets
etc
order
better
understand
reasons
discrepancy
need
evaluate
java
terms
characteristics
representation
media
type
within
rest
javascript
better
fits
deployment
model
web
technology
much
lower
entry
barrier
terms
overall
complexity
language
amount
initial
effort
required
novice
programmer
put
together
first
piece
working
code
javascript
also
less
impact
visibility
interactions
independent
organizations
can
read
verify
copy
javascript
source
code
way
copy
html
java
contrast
downloaded
binary
packaged
archives
user
therefore
left
trust
security
restrictions
within
java
execution
environment
likewise
java
many
features
considered
questionable
allow
within
secure
environment
including
ability
send
rmi
requests
back
origin
server
rmi
support
visibility
intermediaries
perhaps
important
distinction
two
however
javascript
causes
less
user
perceived
latency
javascript
usually
downloaded
part
primary
representation
whereas
java
applets
require
separate
request
java
code
converted
byte
code
format
much
larger
typical
javascript
finally
whereas
javascript
can
executed
rest
html
page
downloading
java
requires
complete
package
class
files
downloaded
installed
application
can
begin
java
therefore
support
incremental
rendering
characteristics
languages
laid
along
lines
rationale
behind
rest's
constraints
becomes
much
easier
evaluate
technologies
terms
behavior
within
modern
web
architecture
6
6
summary
chapter
described
experiences
lessons
learned
applying
rest
authoring
internet
standards
hypertext
transfer
protocol
http
uniform
resource
identifiers
uri
two
specifications
define
generic
interface
used
component
interactions
web
addition
described
experiences
lessons
learned
deployment
technologies
form
libwww
perl
client
library
apache
http
server
project
implementations
protocol
standards
top
prev
next
roy
thomas
fielding
2000
rights
reserved
reference
work
