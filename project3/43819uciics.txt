variables operators 

variables
operators
expressions
introduction
computer
science
iii
ics
21
22
23
introduction
lecture
will
first
learn
declare
visualize
variables
storing
type
data
primitive
reference
types
will
learn
variety
operators
arithmetic
relational
logical
textual
state
change
methods
compute
results
produce
values
data
along
way
will
introduce
new
terminology
discussing
operators
methods
generally
finally
will
learn
combine
literals
variables
operators
methods
like
function
calls
build
arbitrarily
complicated
expresions
formulas
java
can
evaluate
examining
structure
evaluation
process
expressions
including
concepts
operator
precedence
operator
associativity
will
learn
build
oval
diagrams
main
analytic
tool
will
use
investigate
understand
large
expressions
along
knowledge
prototypes
understand
translate
complicated
formulas
equivalent
java
expressions
verify
translation
correct
declaring
variables
programs
declare
variables
store
remember
information
manipulate
examine
update
information
run
simple
variables
typically
store
value
input
user
value
calculated
program
user
inputs
program
runs
values
variables
change
thus
value
stored
variable
can
vary
program
runs
ebnf
rules
variable
declaration
appear
declaration
statement
complete
command
computer
computer
executes
will
cover
many
java's
statements
next
lecture
primitive
type
reference
type
type
primitive
type
reference
type
expression
literal
will
generalize
rule
later
variable
declarator
identifier
expression
variable
declarators
variable
declarator
variable
declarator
local
variable
declaration
statement
type
variable
declarators
declarations
simple
statements
means
end
semicolon
see
last
rule
variables
always
declared
type
primitive
type
like
int
reference
type
like
string
one
names
identifier
programmmer
chooses
can
optionally
initialized
store
specified
value
simplest
form
declaration
int
sum
declares
one
variable
named
sum
type
int
meaning
sum
stores
int
values
notice
semicolon
ending
statement
variable
declared
way
value
initially
stores
undefined
will
say
java
undefined
variables
later
mistake
declare
certain
variables
without
initializing
want
declare
variable
time
initialize
can
write
something
like
int
gamesplayed
0
explicitly
telling
java
declare
variable
named
gamesplayed
store
zero
value
initially
fact
can
declare
variables
declaration
double
angle
magnitude
declares
two
variables
type
double
storing
undefined
values
multi
variable
declarations
variables
declared
type
one
type
starts
declaration
want
declare
initialize
multiple
variables
single
declaration
using
repetition
variable
declarators
ebnf
rule
must
explicitly
specify
initial
value
variable
example
int
0
sum
0
initializes
variable
zero
warning
int
sum
0
initializes
sum
zero
leaves
uninitialized
making
mistake
common
beginning
programmers
fact
java
always
executes
declarations
multiple
variables
sequence
declarations
single
variables
executing
int
sum
0
equivalent
executing
int
int
sum
0
makes
problem
obvious
java
imposes
syntax
constraint
initialized
variables
declared
type
variable
specified
start
declaration
must
compatible
type
expression
will
discuss
compatibility
discuss
implicit
conversions
now
assume
compatible
means
two
types
must
declaration
int
true
although
ebnf
rules
correctly
followed
java
compiler
will
detect
report
syntax
constraint
error
true
boolean
literal
int
value
likewise
boolean
atcapacity
0
exhibits
kind
error
reverse
truthful
java
will
fact
automatically
convert
int
value
double
necessary
double
1
legal
treated
equivalently
double
1
obscurely
java
will
automatically
convert
char
value
int
value
vice
versa
necessary
will
learn
implicit
type
conversion
later
lecture
programmers
often
use
line
oriented
comments
called
side
bar
comments
declarations
document
interesting
facet
variable
captured
even
well
chosen
name
example
declarations
statements
double
tanksize
gallons
double
mileage
miles
gallon
programmer
used
comments
describe
units
quantity
variable
stores
extending
variable
name
tanksizeingallons
probably
making
bit
long
note
style
declaration
comment
declare
just
one
variable
per
declaration
statement
pragmatically
declarations
declare
just
one
variable
drawing
declarations
primitive
reference
types
throughout
semester
will
learn
variety
graphic
aids
help
us
understand
analyze
meanings
java
language
constructs
will
start
learning
draw
simple
pictures
illustrate
meanings
declarations
students
fail
appreciate
power
simple
pictures
drawn
correctly
time
time
pictures
often
used
much
complicated
contexts
class
instance
variables
can
provide
insight
meaning
semantics
java
language
will
see
repeatedly
illustrate
meaning
declaration
draw
box
label
box
top
left
variable's
type
top
right
variable's
name
store
initial
value
inside
box
declarator
specifies
initialization
option
write
question
mark
inside
box
always
write
something
box
value
right
type
question
mark
char
string
literal
just
question
mark
two
major
categories
types
java
primitive
reference
primitive
types
fixed
language
named
keywords
will
learn
repeatedly
use
primitive
types
int
double
boolean
char
reference
types
come
class
libraries
written
programmers
right
now
reference
type
currently
know
string
declared
standard
java
library
will
learn
reference
types
soon
declare
new
reference
types
bit
later
string
reference
type
special
one
also
literal
values
difference
primitive
reference
types
can
appear
inside
box
picture
variable
variables
declared
primitive
type
store
values
variables
declared
reference
type
store
references
variable
primitive
type
write
box
either
question
mark
literal
declared
type
variable
reference
type
write
box
either
question
mark
literal
value
null
usable
reference
types
means
variable
refers
nothing
arrow
called
reference
leads
object
oval
labelled
type
stores
collection
data
strings
collection
characters
comprise
string's
value
will
learn
much
much
primitive
reference
types
later
now
critical
just
understand
given
declaration
illustrate
meaning
picture
pictures
illustate
meaning
following
declarations
int
int
0
boolean
false
string
string
null
string
hello
will
explore
illustrations
learn
state
change
operators
lecture
will
extend
use
illustrations
later
learn
using
kinds
variables
parameter
variables
declared
methods
instance
variables
declared
bjects
constructed
classes
operator
prototypes
signatures
introducing
exceptions
two
aspects
describing
operators
java
describe
syntax
via
prototypes
type
operand
work
type
result
produce
whether
can
throw
exceptions
describe
semantics
meaning
english
compute
value
result
operand
conditions
throw
exception
can
specify
syntax
prototype
formally
return
type
type
operand
types
type
type
exception
identifier
exception
types
exception
identifier
exception
identifier
prototype
return
type
operator
operand
types
throws
exception
types
prototypes
start
type
result
returned
operator
followed
operator
followed
pair
parentheses
type
operand
separated
commas
inside
example
following
lines
specifies
operator
prototype
int
int
int
double
double
int
int
int
double
double
double
first
prototype
means
java
adds
two
ints
operator
result
int
second
prototype
means
java
negates
double
operator
result
double
third
prototype
means
java
multiplies
two
ints
operator
result
int
fourth
prototype
meants
java
multiplies
two
doubles
operator
result
double
course
already
know
semantics
meanings
addition
negation
multiplication
mathematics
need
discuss
will
soon
see
prototypes
interesting
operators
boolean
int
int
boolean
boolean
boolean
first
prototype
means
java
compares
two
ints
operator
result
boolean
probably
already
know
semantics
kind
comparison
second
prototype
means
java
ands
together
operator
pronounced
two
booleans
result
boolean
studied
logic
truth
tables
will
might
know
semantics
operation
result
produced
operands
learn
operators
java
will
first
present
syntax
prototypes
semantics
using
english
tools
finally
operators
specify
throw
exceptions
operator
throws
exception
correctly
compute
result
operand
example
integer
division
operator
java
compute
result
denominator
zero
prototype
indicates
information
using
keyword
throws
followed
identifier
arithmeticexception
will
learn
many
details
later
prototype
integer
division
fully
written
int
int
int
throws
arithmeticexception
signature
subset
information
prototype
includes
just
information
types
operands
return
type
exceptions
can
specify
syntax
signature
formally
reusing
ebnf
rules
written
signature
operator
operand
types
fact
using
ebnf
rule
rewrite
prototype
rule
simply
prototype
return
type
signature
throws
exception
types
operator
terminology
bit
terminology
will
make
easier
discuss
explore
operators
number
prototypes
operator
overloaded
one
prototype
operator
one
prototype
int
operands
one
double
operands
hence
overloaded
term
overloaded
bad
term
fact
java
operators
overloaded
overloaded
operators
must
different
signatures
either
different
number
operands
number
different
types
operands
given
restriction
java
can
use
types
operands
determine
prototype
use
note
following
two
prototypes
int
int
int
double
int
int
signature
int
int
number
operands
unary
operators
one
operand
negate
operator
think
unicycle
one
wheel
binary
operators
two
operands
multiply
operator
think
bicycle
two
wheels
operator
location
infix
operators
written
operands
3
5
infix
operators
binary
prefix
operators
written
operand
5
prefix
operators
unary
postfix
operators
written
operand
count
postfix
perators
unary
important
gain
intuitive
understanding
terms
now
will
use
repeatedly
throughout
semester
operators
java
java
contains
large
number
operators
fall
categories
arithmetic
relational
logical
state
change
textual
lecture
will
examine
categories
operators
first
examining
syntax
prototypes
examining
semantics
using
english
operand
result
tables
etc
although
operators
java
far
common
useful
ones
operator
add
catenate
operator
overloaded
java
following
arithmetic
prototypes
int
int
double
double
int
int
int
double
double
double
let
us
take
look
semantics
prototypes
say
java
evaluates
operators
produce
results
operands
prototypesemanticsexamplesint
int
unary
prefix
operator
result
operand
7
evaluates
7double
double
unary
prefix
operator
result
operand
7
25
evaluates
7
25int
int
int
binary
infix
operator
result
sum
operands
3
5
evaluates
8double
double
double
binary
infix
operator
result
sum
operands
2
4
5
1
evaluates
7
5
operator
also
textual
operator
called
catenate
following
prototypes
highly
overloaded
notice
case
least
one
operand
string
final
result
always
string
string
string
int
string
string
double
string
string
boolean
string
string
char
string
string
string
string
int
string
string
double
string
string
boolean
string
string
char
string
semantically
string
string
case
simplest
builds
string
containing
characters
first
operand
followed
characters
second
operand
example
hi
low
evaluates
hilow
next
simplest
catenation
string
char
regardless
order
example
'a'
string
evaluates
astring
cases
value
whether
type
int
double
boolean
first
automatically
converted
equivalent
string
catenated
operand
already
string
example
12
dozen
evaluates
12
dozen
int
value
12
first
automatically
converted
string
value
12
note
1
1
results
2
1
1
1
1
result
11
finally
note
true
boolean
results
true
boolean
boolean
value
true
first
automatically
converted
string
value
true
using
catenation
common
java
outputing
various
types
information
console
will
become
familiar
operator
start
writing
programs
operator
negate
subtract
operator
overloaded
java
following
prototypes
int
int
double
double
int
int
int
double
double
double
let
us
take
look
semantics
prototypes
prototypesemanticsexamplesint
int
unary
prefix
operator
result
negated
value
operand
7
evaluates
negative
7double
double
unary
prefix
operator
result
negated
value
operand
7
25
evaluates
negative
7
25int
int
int
binary
infix
operator
result
difference
first
second
operands
8
3
evaluates
5double
double
double
binary
infix
operator
result
difference
first
second
operands
7
5
2
4
evaluates
5
1
note
java
writing
6
means
negate
literal
6
recall
literals
non
negative
6
technically
literal
operator
literal
still
will
write
6
often
pretend
purely
value
example
writing
values
inside
variables
seem
confusing
worry
detail
much
let
weird
tree
stop
seeing
forest
operator
multiply
multiply
operator
overloaded
java
following
prototypes
int
int
int
double
double
double
note
unlike
unary
version
operator
let
us
take
look
semantics
prototypes
prototypesemanticsexamplesint
int
int
binary
infix
operator
result
product
operands
3
5
evaluates
15double
double
double
binary
infix
operator
result
product
operands
4
2
5
8
evaluates
24
36
note
unlike
mathematics
implicit
multiplication
java
assuming
declare
int
3a
3
legal
expressions
written
explicitly
operator
3
3
will
study
expressions
arbitrarily
complicated
combinations
operators
discussing
later
lecture
operator
divide
divide
operator
overloaded
java
following
prototypes
int
int
int
throws
arithmeticexception
double
double
double
note
like
operator
unary
version
operator
let
us
take
look
semantics
prototypes
prototypesemanticsexamplesint
int
int
binary
infix
operator
result
integer
part
first
operand
divided
second
ignore
remainder
second
operand
0
operator
throws
exception
13
5
evaluates
2double
double
double
binary
infix
operator
result
first
operand
divided
second
second
operand
0
operator
returns
result
infinity
first
operand
positive
infinity
first
operand
negative
nan
number
first
operand
also
zero
13
5
evaluates
2
6
first
nonintuitive
semantics
java
arithmetic
operator
java
divides
two
int
values
13
5
prototype
tells
us
result
must
int
java
takes
mathematical
answer
2
6
one
intuitive
us
truncates
throws
away
6
non
integral
part
two
double
values
divided
java
keep
decimal
part
returned
result
students
find
difference
strange
nonintuitive
often
careful
using
operator
programs
distinguish
int
double
operands
finally
second
operand
operator
int
operands
zero
operator
compute
result
instead
throws
exception
throwing
exception
like
throwing
hands
saying
computation
end
study
java
statements
will
learn
catch
handle
thrown
exceptions
throwing
exception
mean
program
must
stop
case
result
division
two
double
values
stranger
long
tortured
history
computers
deal
related
problems
involving
anomalous
operations
double
values
finally
resolved
ieee
754
standard
will
ignore
issue
now
problem
come
simple
programs
remember
print
double
appears
infinity
infinity
nan
means
divided
zero
probably
means
made
mistake
program
operator
remainder
remainder
operator
overloaded
java
following
two
prototypes
int
int
int
throws
arithmeticexception
double
double
double
prototypesemanticsexamplesint
int
int
binary
infix
operator
result
remainder
left
first
operand
divided
second
technically
result's
sign
sign
first
operand
result's
magnitude
remainder
absolute
values
operands
divided
second
operand
0
operator
throws
arithmeticexception
13
5
evaluates
3
5
goes
13
just
2
times
13
5
evaluates
2
leaving
remainder
3
13
5
evaluates
3
sign
first
operand
negative
magnitude
13
5
13
5
evaluates
3
sign
first
operand
positive
magnitude
13
5
13
5
evaluates
3
sign
first
operand
negative
magnitude
13
5double
double
double
space
intentionally
left
blank
space
intentionally
left
blank
although
students
never
seen
operator
mathematics
seen
remainders
long
division
sometimes
useful
java
programming
certainly
hard
understand
least
case
non
negative
integers
therefore
must
know
prototype
semantics
non
negative
integers
obviously
operators
int
operands
related
can
call
quotient
operator
remainder
operator
generally
non
negative
integers
returns
value
try
evaluating
second
formula
values
remember
truncate
division
two
interesting
facts
declare
int
store
non
negative
value
10
last
digit
number
10
every
digit
last
one
example
declare
int
4125
10
evaluates
5
10
evaluates
412
must
able
understand
use
division
operators
program
finally
operator
operator
throws
arithmeticexception
second
operand
zero
relational
operators
primitive
types
java
includes
sixth
relational
operators
first
pair
known
equality
operators
final
four
known
inequality
operators
equality
operators
overloaded
pairs
primitive
type
inequality
operators
overloaded
likewise
except
boolean
type
result
produced
boolean
value
prototypes
operator
shown
relational
operators
similar
prototypes
note
computes
equal
computes
equal
computes
less
computes
less
equal
computes
greather
computes
greater
equal
boolean
int
int
boolean
double
double
boolean
boolean
boolean
boolean
char
char
relational
operator
compares
two
values
type
produces
boolean
result
must
learn
think
operator
like
just
think
operator
like
take
two
operands
computes
result
former
case
boolean
later
case
numeric
value
say
3
5
computes
result
true
just
say
3
5
computes
result
8
must
learn
think
java
operators
regardless
operand
result
types
computing
value
way
semantically
operators
work
expect
numeric
int
double
values
one
can
compare
boolean
values
four
relational
operators
text
type
char
values
compare
according
ascii
values
char
value
can
convert
small
int
according
ascii
conversion
table
certainly
memorize
ascii
table
programmers
know
'0'
ascii
inequality
operators
work
reference
types
equality
operators
work
straightforward
way
variables
values
type
string
recall
class
type
primitive
type
will
discuss
later
various
methods
comparing
string
values
logical
operators
java
includes
three
logical
operators
overloaded
just
one
prototype
boolean
operands
boolean
result
operator
read
operator
read
operator
read
boolean
boolean
boolean
boolean
boolean
boolean
boolean
boolean
semantically
operators
described
following
truth
table
aba
ba
bfalsefalsefalsefalsetruefalsetruefalsetruefalsetruefalsefalsetruetruetruetruetrue
programmers
must
memorize
tables
able
analyze
expressions
use
operators
short
cuts
note
result
operator
true
operands
true
note
result
operator
false
operands
false
note
operator
just
one
operand
looks
bit
different
truth
table
implicit
conversion
java
make
3
5
2
seen
arithmetic
operator
two
binary
prototypes
either
operands
int
double
fact
actually
two
different
circuits
computers
arithmetic
one
adding
pairs
ints
one
adding
pairs
doubles
every
addition
must
go
one
two
circuits
java
just
rejectusing
combination
operator
operands
instead
java
sees
binary
operator
one
int
operand
one
double
operand
automatically
converts
int
value
double
uses
double
operands
prototype
related
circuit
addition
called
implicit
conversion
java
implicit
conversion
always
int
double
whenever
binary
arithmetic
operator
different
numeric
types
operands
java
performs
one
implicit
conversion
necessary
char
implicitly
converted
int
according
value
ascii
table
'a'
1
char
'a'
first
implicitly
converted
int
65
can
added
int
1
finally
producing
int
result
66
fact
expression
1
5
'a'
'a'
first
implicitly
converted
int
65
implicitly
converted
double
65
finally
producing
double
66
5
result
finally
expression
'5'
'0'
implicitly
converts
char
values
int
53
48
respectively
see
ascii
table
performs
subtraction
result
case
int
5
fact
declare
char
'8'
initialize
character
digit
writing
'0'
results
int
equivalent
digit
case
8
note
ascii
value
'8'
56
'0'
48
collectively
implicit
conversion
called
promotion
always
works
just
one
way
char
promoted
int
promoted
double
promotion
loses
information
every
char
can
represented
equivalent
int
every
int
can
represented
equivalent
double
notice
remaining
primitive
type
boolean
plays
part
promotion
state
change
operators
primitive
types
operators
java
just
examine
operands
produce
result
produces
result
product
two
operands
special
category
java
operators
produce
result
also
change
state
one
operands
restricted
syntax
constraint
name
variable
operators
category
called
state
change
operators
common
state
change
operator
java
operator
operator
known
assignment
stores
operator
overloaded
primitive
types
know
java
following
prototypes
int
int
int
double
double
double
boolean
boolean
boolean
char
char
char
binary
operators
java
restricts
first
operand
name
variable
0
legal
expression
0
illegal
according
restriction
semantically
value
right
operand
can
expression
stored
variable
specified
left
operand
restricted
variable
name
value
also
result
expression
can
use
state
change
operators
change
state
value
stored
variable
example
declare
int
0
evaluate
expression
1
java
first
computes
1
will
soon
learn
lower
precedence
operator
evaluated
first
whose
result
1
java
uses
operator
changes
value
stored
1
result
entire
expression
1
also
evaluate
expression
1
java
changes
value
stored
2
result
entire
expression
2
also
char
char
char
state
chance
operators
syntax
constraint
first
operand
name
variable
semantically
expression
simpler
way
write
similarly
operators
2
computes
2
stores
result
new
result
also
resuklt
entire
expression
equivalent
2
finally
java
includes
two
special
operators
increment
decrement
variables
1
operators
can
used
prefix
postfix
form
overloaded
following
types
restricted
operate
variables
names
write
0
int
int
int
int
double
double
double
double
char
char
char
char
semantically
prefix
postfix
value
variable
gets
incremented
1
written
variable
prefix
operator
result
operator
new
current
value
stored
variable
written
variable
postfix
operator
result
operator
old
original
value
stored
variable
likewise
subtracts
1
decrements
variable
variable
type
char
changed
store
character
one
higher
one
lower
declare
int
0
write
incremented
0
1
result
produced
operator
0
old
original
value
stored
stored
value
0
result
entire
expression
instead
write
incremented
0
1
result
1
new
current
value
stored
stored
value
1
result
entire
expression
prefix
postfix
distinction
operators
may
seem
strange
useful
will
see
important
uses
soon
illustrate
state
change
operators
often
use
pictures
kind
pictures
used
illustrate
variable
declarations
example
can
illustrate
meaning
follows
next
can
illustrate
meaning
follows
finally
can
illustrate
meaning
follows
vs
programming
must
careful
distinguish
operator
operator
many
people
pronounce
equals
leaving
hearer
disambiguate
context
careful
java
programmers
pronounce
second
equals
equals
double
equals
weeks
using
seem
confusing
just
learned
state
change
operator
changes
state
left
operand
must
variable
store
value
right
operand
value
type
value
derived
implicit
conversion
result
also
value
stored
thus
expression
1
serves
increment
value
stored
1
yes
ways
well
hand
state
change
operator
compares
two
values
operands
must
type
neither
variable
result
always
type
boolean
changes
neither
operand
expression
1
syntactically
legal
completely
useless
always
computes
value
false
effect
changes
states
variables
involved
confusing
common
lookout
mistakes
can
cause
subtle
bugs
programs
many
cases
java
compiler
will
issue
warning
suspects
misused
one
operators
will
see
examples
next
lecture
mathematical
methods
can
use
variety
mathematical
methods
java's
name
functions
java
using
math
class
will
examine
read
classes
soon
write
classes
bit
later
course
will
specify
syntax
methods
also
using
prototypes
just
operators
instead
operator
tokens
methods
named
class
name
math
followed
period
separator
followed
method
name
learn
classes
will
discuss
naming
convention
sampling
prototypes
useful
methods
math
class
int
math
abs
int
double
math
abs
double
int
math
min
int
int
double
math
min
double
double
int
math
max
int
int
double
math
max
double
double
double
math
pow
double
double
double
math
sqrt
double
double
math
log
double
double
math
log10
double
double
math
exp
double
double
math
cos
double
double
math
sin
double
double
math
tan
double
double
math
random
semantically
abs
returns
absolute
value
operand
overloaded
int
double
min
returns
minimum
two
operands
overloaded
int
double
max
returns
maximum
two
operands
overloaded
int
double
pow
returns
first
operand
must
non
negative
unless
second
operand
integral
3
raised
power
second
operand
pow
3
5
computes
x3
5
non
negative
otherwise
returns
nan
sqrt
returns
square
root
operand
must
positive
otherwise
returns
nan
sqrt
better
pow
5
faster
accurate
although
legal
log
returns
logarithm
base
operand
must
positive
otherwise
returns
nan
log10
returns
logarithm
base
10
operand
must
positive
otherwise
returns
nan
exp
returns
raised
power
operand
cos
returns
cosine
operand
expressed
radians
degrees
sin
returns
sine
operand
expressed
radians
degrees
random
returns
random
number
range
0
1
semi
open
interval
specifies
can
return
value
0
returns
value
always
strictly
less
never
equal
1
call
invoke
methods
specifying
full
name
class
method
separated
period
enclosing
required
operands
parentheses
separated
commas
correct
syntax
calling
invoking
method
writing
math
max
3
4
results
int
4
random
method
interesting
first
one
seen
whose
prototype
specifies
operands
yet
still
must
call
parentheses
must
methods
math
random
will
effectively
return
different
random
result
time
called
note
none
methods
state
change
methods
produce
values
change
stored
variables
used
operands
given
int
3
4
math
max
also
results
int
4
neither
changed
still
store
3
4
respectively
fact
java
programming
language
prohibits
writing
methods
change
states
operands
bit
subtle
understand
will
examine
statement
ramifications
soo
input
output
java
uses
two
methods
outputing
information
onto
console
print
println
methods
funny
prefixes
system
learn
classes
fields
will
discuss
prefixes
now
scan
overloaded
prototypes
methods
void
system
print
int
void
system
print
double
void
system
print
boolean
void
system
print
char
void
system
print
string
void
system
println
void
system
println
int
void
system
println
double
void
system
println
boolean
void
system
println
char
void
system
println
string
void
return
type
means
method
performs
command
action
case
displaying
something
console
resulting
value
returned
ask
son
school
today
expect
answer
ask
clean
room
expect
answer
just
perform
action
actually
expect
clean
room
either
semantics
son
print
methods
displays
value
console
window
stays
line
subsequent
output
will
continue
displayed
line
println
methods
displays
value
console
window
goes
beginning
next
line
fact
writing
just
system
println
program
supplying
operands
method
call
will
print
nothing
go
beginning
next
line
system
print
system
println
system
println
system
print
system
print
displays
output
ab
de
next
output
following
line
can
also
accomplish
equivalent
carefully
using
newline
escape
characters
system
print
ab
nc
nde
print
method
processes
escape
character
'
n'
finishing
current
line
starting
new
line
system
print
nb
displays
output
frequently
use
catenation
operator
always
produces
string
inside
methods
declare
int
gamesplayed
0
give
command
system
println
games
played
far
gamesplayed
java
will
print
games
played
far
0
prompt
class
contains
variety
methods
inputing
information
prototypes
simplest
methods
int
prompt
forint
string
int
prompt
forint
string
int
int
double
prompt
fordouble
string
char
prompt
forchar
string
string
string
prompt
forstring
string
case
string
operand
specifies
message
user
sees
prompting
information
enter
prompt
forint
overloaded
second
version
allows
programmer
specify
smallest
largest
allowable
values
user
inputs
value
outside
range
reprompted
likewise
second
string
prompt
forchar
method
specifies
characters
user
allowed
enter
user
inputs
value
outside
range
reprompted
typical
use
prompt
method
program
might
initialization
part
declartion
int
cashtobet
prompt
forint
enter
amount
cash
bet
char
action
prompt
forchar
action
withdraw
deposit
wd
experiment
questions
operators
write
tiny
program
perform
experiment
test
understanding
like
performing
small
physics
chemistry
experiment
example
happens
try
add
two
characters
simple
code
put
program
perform
experiment
system
println
'a'
'b'
can
guess
answer
printed
answer
different
one
expected
can
revise
understanding
implicit
conversion
semantics
operator
reconcile
result
produced
important
get
habit
early
shy
running
experiments
computer
even
simple
one
fact
thinking
simplest
experiment
perform
check
java
features
requires
deep
understanding
programming
learning
java
run
hundreds
small
experiments
including
many
technical
points
lecture
low
threshold
start
eclipse
project
tiny
program
test
understanding
java
structure
evaluation
expressions
section
begin
examination
build
simple
complicated
expressions
literals
variables
operators
methods
ebnf
rules
specifying
structure
expressions
overly
complicated
instead
will
just
describe
syntax
english
one
times
shall
three
structural
rules
expressions
rule
concerns
syntax
legal
expressions
type
s1
literal
legal
expression
type
type
literal
s2
variable
legal
expression
type
declared
type
variable
s3
operator
method
whose
operands
must
legal
expression
match
prototypes
possibly
aid
automatic
conversion
legal
expression
type
result
type
specified
prototype
looking
expression
knowing
types
literals
variables
knowing
prototypes
operators
methods
can
determine
expression
well
formed
according
structural
rules
java
determine
type
results
evaluating
expression
java
even
know
values
stored
variables
just
need
know
types
semantics
operators
methods
just
need
know
prototypes
syntax
rule
companion
semantic
rule
evaluating
expressions
sense
expression
question
value
java
answers
evaluating
expression
e1
literal
evaluates
trivial
noteworthy
rule
sake
completeness
e2
variable
evaluates
current
value
stored
remember
evaluating
expressions
state
change
operators
can
change
values
stored
variables
e3
operator
method
evaluates
operands
legal
expressions
performs
implicit
conversions
needed
match
prototype
applies
operator
method
operands
compute
result
based
semantics
operator
method
e1
e2
simple
rules
power
rule
e3
example
assume
declare
int
3
program
want
determine
whether
expression
3
1
legal
expression
resulting
type
value
entire
proof
follows
can
prove
3
legal
expression
type
int
s1
value
3
e1
can
prove
legal
expression
type
int
s2
value
3
e2
can
prove
3
legal
expression
type
int
s3
just
proved
3
legal
expressions
type
int
one
prototypes
int
int
int
result
type
int
value
9
e3
applying
semantics
multiply
operator
can
prove
1
legal
expression
type
int
s1
value
1
e1
finally
can
prove
3
1
legal
expression
type
int
s3
just
proved
3
1
legal
expressions
type
int
one
prototypes
int
int
int
result
type
int
values
10
e3
applying
semantics
add
operator
fact
three
rules
allow
us
identify
structure
evaluate
arbitrarily
complicated
expressions
built
literals
variables
operators
methods
oval
diagrams
illustate
understand
java
structures
evaluates
expressions
importantly
give
us
tool
analyze
debug
incorrectly
written
expressions
will
study
illustrate
expression
oval
diagram
write
expressions
many
operators
methods
mixing
many
types
tool
will
become
important
create
oval
diagram
first
circle
draw
oval
around
every
literal
variable
expression
expressions
like
atoms
chemistry
contain
smaller
constituents
next
label
types
top
label
values
know
bottom
draw
oval
around
operator
method
operands
label
type
result
type
matching
prototype
operator
label
bottom
result
value
know
compute
semantics
note
even
know
values
stored
variables
can
still
produce
oval
diagram
verified
legality
expression
just
determine
value
computed
outermost
oval
labelled
type
entire
expression
example
oval
diagram
previously
discussed
expression
3
1
operator
precedence
associativity
examine
oval
diagram
exactly
tokens
oval
diagram
ovals
bit
different
seem
follow
rules
forming
evaluating
expressions
ovals
different
positions
ultimately
produce
different
results
questions
oval
diagram
correct
way
java
analyzes
evaluates
expressions
extra
rules
need
know
construct
correct
oval
diagrams
answers
concepts
operator
precedence
operator
associativity
operators
take
precedence
operators
operators
circled
evaluated
first
expression
will
learn
can
also
use
parentheses
override
standard
operator
precedence
need
operator
precedence
association
table
includes
operators
learned
far
java
will
learn
just
course
operatornameprecedenceassociativity
postfix
increment
decrement15none
unary
unary
plus
minus
negateprefix
increment
decrement14none
unary
type
expressioncasting
see
13left
multiply
divide
remainder12left
add
subtract11left
instanceofinequality
relational9left
equality
relational8left
logical
and4left
logical
or3left
state
change1right
rules
using
tables
expressions
o1
expression
contains
two
consecutive
operators
neither
appearing
parentheses
java
applies
higher
precedence
operator
first
o2
expression
contains
two
consecutive
operators
neither
appearing
parentheses
precedence
java
applies
left
associative
operators
left
right
applies
right
associative
operators
right
left
o3
java
always
evaluates
expressions
parentheses
uses
operands
expressions
can
use
parentheses
override
precedence
forcing
operators
inside
parentheses
evaluated
operators
outside
parentheses
o4
java
always
evaluates
operands
method
left
right
order
applies
method
computes
method's
result
thus
expression
3
1
start
circling
literals
variables
see
two
consecutive
operators
parentheses
operator
higher
precedence
operator
operands
circled
first
operator
operands
circled
completing
oval
diagram
remember
lower
precedence
operators
evaluated
last
expression
3
1
subexpression
1
appears
parentheses
start
circling
literals
variables
see
two
consecutive
operators
time
second
one
parentheses
rule
o3
must
handle
operators
inside
parentheses
first
circling
operator
first
circling
operator
last
operand
circled
complete
oval
diagram
fact
parentheses
suggestive
two
sides
oval
can
always
draw
ovals
around
parenthesized
expressions
can
used
represent
result
computed
last
operator
inside
parentheses
common
mistakes
note
expression
looks
like
divided
product
operators
precedence
left
associative
redundant
white
space
meaningless
tokenized
expression
exactly
java
first
expression
equivalent
formula
product
denominator
according
rules
operator
precedence
associativity
must
use
parentheses
denominator
students
attempt
avoid
parentheses
write
expression
think
form
uglier
harder
understand
next
examine
following
four
expression
attempt
compute
volume
sphere
radius
difference
among
expressions
types
literals
used
ones
without
decimal
points
int
ones
decimal
points
double
assume
already
declared
double
pi
3
1416
4
3
pi
math
pow
3
4
3
pi
math
pow
3
4
3
pi
math
pow
3
4
3
pi
math
pow
3
assume
double
2
correct
answer
33
510314
answer
computed
bottom
right
expression
correct
expressions
every
operator
operands
double
implicitly
converted
double
bottom
right
expression
two
ints
divided
first
creating
int
result
implicitly
converted
double
multiplying
double
variable
pi
note
1
1
shows
exactly
implicit
conversion
occurs
oval
diagram
final
result
incorrect
answer
thus
can
use
oval
diagrams
compute
type
value
expression
can
use
debug
incorrectly
formed
expressions
one
correct
version
expression
also
involving
implicit
conversion
theright
time
place
appears
note
integer
division
expression
combining
relational
logical
operators
easy
make
mistakes
generally
good
intuition
arithmetic
operators
easily
extend
kinds
operators
standard
mathematics
learned
example
suppose
want
determine
whether
int
variable
named
0
10
inclusive
evaluate
expression
storing
5
result
true
evaluate
expression
storing
20
result
false
examine
following
expression
looks
like
good
mathematics
oval
diagrams
see
correct
0
expression
two
operators
therefore
precedence
left
associative
like
plus
operators
java
evaluates
left
operator
first
boolean
result
tries
evaluate
right
operator
java
find
prototype
even
implicit
conversion
boolean
values
implicitly
convert
anything
thus
although
expression
makes
perfect
sense
us
using
notations
mathematics
will
rejected
java
least
subtle
error
implicit
conversion
previous
example
correct
expression
test
condition
0
whose
oval
diagram
shown
two
given
examples
notice
need
implicit
conversions
expression
generally
implicit
conversion
can
lead
kinds
errors
avoided
analyzing
oval
diagrams
play
close
attention
implicit
conversion
study
carefully
whether
always
works
correctly
following
complicated
oval
diagram
analyzes
expression
1
8
contains
three
state
change
operators
two
one
notice
precedence
operators
use
parentheses
force
evaluation
inner
operator
lowest
precedence
operator
will
examine
various
complicated
expressions
including
others
multiple
state
change
operators
class
learn
apply
rules
create
oval
diagrams
best
see
process
rather
static
pictures
make
sure
awake
paying
attention
explicit
conversion
casting
sometimes
useful
convert
value
one
type
another
make
conversion
explicit
implicit
called
casting
java
notice
casting
considered
high
precedence
operator
higher
precedence
unary
operators
example
sometimes
case
program
declares
int
counters
must
compute
ratios
counters
avoid
truncation
occurs
int
division
can
explicitly
convert
int
value
double
example
suppose
declared
int
attendance
78
capacity
100
writing
double
attendance
double
capacity
first
converts
int
value
double
state
changes
variables
converted
performs
double
division
values
computing
exact
double
answer
without
truncation
78
course
writing
either
double
attendance
capacity
attendance
double
capacity
work
one
's
operands
double
java
will
implicitly
convert
double
might
well
write
casts
though
make
conversions
occur
clear
note
double
attendance
capacity
job
first
performs
integer
division
equivalent
double
0
whose
result
0
sometimes
casts
necessary
satisfy
syntax
constraints
suppose
wanted
generate
random
integer
1
6
store
variable
named
choice
write
int
choice
1
6
math
random
expression
java
implicitly
convert
6
double
perform
multiplication
returning
double
result
java
implicitly
convert
1
double
perform
addition
returning
double
result
finally
store
double
value
int
variable
instead
can
write
expression
correctly
int
choice
1
int
6
math
random
case
compiler
will
report
syntax
constraint
error
explicitly
casted
6
math
random
int
thus
value
ultimately
stored
choice
integer
1
6
inclusive
casting
change
values
stored
variables
write
oval
diagram
expression
compute
result
stored
choice
different
random
numbers
0
can
generated
1
generated
try
values
including
0
something
tad
less
1
use
oval
diagrams
understand
1
6
int
math
random
1
int
6
math
random
always
compute
correct
results
int
1
6
math
random
work
use
oval
diagram
find
expression
pragmatics
write
expressions
correctly
computers
clearly
people
including
use
suggestive
spacing
redundant
parentheses
clarify
person
meanings
complicated
expressions
suggestive
spacing
use
extra
whitespace
around
lower
precedence
operators
suggest
evaluated
later
recall
whitespace
change
meaning
program
tokens
remain
redundant
parentheses
use
unneeded
parentheses
override
precedence
operators
around
higher
precedence
operators
suggest
evaluated
earlier
expressionsuggestive
spacingredundant
5
5
5
also
use
literals
correct
type
avoid
implicit
conversion
often
leads
hard
find
errors
want
conversion
occur
use
casting
make
explicit
change
java
evaluates
expression
implicit
conversion
casting
thing
anyone
reading
program
expression
will
easier
understand
can
check
expressions
write
analyzing
oval
diagrams
evaluating
different
values
ensure
compute
right
answers
cast
literals
see
students
write
double
5
pains
greatly
write
just
5
instead
problem
set
ensure
understand
material
lecture
please
solve
announced
problems
read
lecture
get
stumped
problem
go
back
read
relevant
part
lecture
still
questions
please
get
help
instructor
ca
tutor
student
show
different
ways
declare
int
variables
initially
storing
0
1
respectively
one
declaration
statement
two
declaration
statments
write
slightly
different
variants
still
accomplish
job
following
illegal
declarations
according
ebnf
int
0
boolean
isok
false
int
0
explain
write
legal
declarations
accomplish
trying
write
prototypes
following
methods
infer
information
needed
prototype
function's
description
countprimesbetween
returns
number
primes
occuring
two
integers
countprimesbetween
11
24
evaluates
5
11
13
17
19
23
prime
distance
returns
euclidean
distance
two
points
plane
point
represented
two
doubles
insamequandrant
returns
whether
two
points
lie
quadrant
point
represented
two
doubles
shuffle
returns
interleaved
characters
operands
shuffle
abcd
efgh
returns
aebfcgdh
results
following
operators
7
10
7
10
7
10
7
10
7
10
57
10
157
10
2157
10
7
10
57
10
157
10
2157
10
show
result
produced
following
operators
methods
indicate
syntax
error
present
state
variable
changed
show
indicate
implicit
conversions
assume
int
0
string
abc
call
false
false
'a'
'z'
'a'
'a'
true
true
true
false
true
false
1
1
1
'a'
math
abs
3
5
math
abs
3
5
math
max
3
5
8
math
sqrt
1
math
pow
3
2
math
pow
3
5
system
println
hi
assume
declare
int
1
stored
evaluating
stored
evaluating
think
programmer
trying
accomplish
easy
way
accomplish
printed
following
method
calls
system
println
1
1
1
system
println
1
1
1
system
println
'1'
1
analyze
following
expressions
assuming
int
1
2
write
oval
diagram
2
2
100
100
100
assume
declare
double
evaluate
expression
math
abs
2
stores
3
stores
5
stores
5
stores
3
try
example
values
describe
general
terms
expression
evaluates
assume
declare
int
also
assume
method
whose
prototype
int
util
characteristic
boolean
returns
1
operand
true
0
operand
false
evaluate
expression
util
characteristic
util
characteristic
stores
3
stores
5
stores
5
stores
3
try
example
values
describe
general
terms
expression
evaluates
translate
following
mathematical
formulas
7
top
line
3
middle
bottom
lines
java
expressions
assume
variables
subscripts
declared
type
double
writing
means
absolute
value
analyze
expression
writing
oval
diagram
suppose
declare
int
attendance
3000
capacity
10000
number
fans
attending
event
stadium
maximum
number
fans
possible
stadium
respectively
following
java
expressions
evaluates
30
percentage
fans
stadium
incorrect
expressions
evaluate
attendance
capacity
100
attendance
capacity
100
attendance
capacity
attendance
capacity
100
expression
10
compute
whether
less
10
show
syntax
expression
incorrect
far
can
java
get
discovers
error
find
way
correctly
test
less
10
less
assume
declare
int
50
20
draw
oval
diagram
shows
value
java
computes
expression
evaluate
false
less
computes
assume
declare
int
write
expression
whose
result
rounded
nearest
10
1432
result
1430
1437
result
1440
1435
round
result
1440
also
use
standard
arithmetic
operators
casting
assume
declare
double
write
expression
whose
result
int
value
closest
3
2
result
3
3
9
result
4
3
5
round
result
4
also
just
casting
work
truncation
3
9
cast
3
assume
declare
int
year
write
expression
whose
result
true
whenever
year
stores
leap
year
false
otherwise
define
leap
year
year
perfect
multiple
4
perfect
multiple
100
unless
also
perfect
multiple
400
note
one
number
perfect
multiple
another
remainder
division
equals
zero
assume
declare
int
2
5
values
entire
expression
evaluating
expression
question
expression
assume
declare
int
write
expression
computes
whether
odd
multiple
20
20
40
60
assume
zero
positive
number
write
expression
computes
whether
positive
sign
positive
negative
different
signs
one
positive
one
negative
write
expression
computes
whether
three
variables
store
value
three
variables
store
different
values
none
two
variables
store
value
third
one
different
assume
declare
char
write
expression
evaluates
true
stores
lower
case
letter
lower
case
upper
case
letter
character
digit
upper
case
vowel
assume
specify
two
points
place
declaration
double
x1
y1
x2
y2
write
expression
computes
distance
points
slope
line
first
point
second
whether
points
lie
line
origin
whether
first
point
second
quadrant
first
point
lies
1st
2nd
3rd
4th
whether
two
points
lie
quadrant
assume
specify
circle
declaration
double
centerx
centery
radius
point
declaration
double
write
expression
computes
whether
point
lies
inside
circle
including
boundary
assume
specify
interval
pair
int
values
ones
beginning
end
interval
place
declaration
5
8
specify
interval
containing
numbers
5
6
7
8
inclusive
declare
int
b1
e1
b2
e2
represent
beginning
end
two
intervals
int
represent
value
note
will
guarantee
intervals
well
formed
b1
b2
write
expression
computes
number
values
interval
beginning
b1
ending
e1
write
expression
computes
whether
inside
first
interval
inside
first
interval
inside
first
interval
second
inside
either
first
second
interval
inside
either
first
second
interval
write
expression
computes
whether
first
interval
second
first
interval
ends
second
one
begins
first
interval
ends
value
second
one
begins
first
interval
inside
second
one
first
interval
second
interval
overlap
least
one
common
value
first
interval
second
interval
overlap
common
values
draw
pictures
help
visualize
relationships
choose
relational
logical
operators
carefully
try
examples
convince
expressions
correct
example
following
picture
shows
first
interval
inside
second
assume
declare
int
write
expression
computes
minimum
three
values
may
use
math
min
method
assume
declare
char
guarantee
stores
character
corresponding
digit
'0'
'1'
'2'
'9'
write
expression
computes
int
equivalent
value
0
'0'
1
'1'
etc
note
int
converts
char
int
right
one
ascii
table
int
'0'
results
48
int
'1'
results
49
give
clue
assume
declare
char
guarantee
stores
character
corresponding
lower
case
letter
'a'
'b'
'c'
'z'
write
expression
computes
upper
case
equivalent
value
'a'
'a'
'b'
'b'
etc
eventually
must
use
casting
assume
declare
int
low
high
guarantee
low
write
expression
whose
result
low
smaller
low
high
greater
high
values
may
use
math
min
math
max
methods
