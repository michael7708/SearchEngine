program 3 
program 3 implementing collections trees 
program
3
trees
implementing
collections
priority
queue
via
max
heap
map
via
bst
fundamental
data
structures
ics
23
introduction
programming
assignment
designed
ensure
know
write
code
processes
trees
implementing
efficient
versions
collection
classes
studying
first
will
write
priority
queue
add
remove
methods
log
instead
one
1
one
add
remove
values
priority
queue
complexity
log
instead
2
gives
us
way
sort
time
log
second
will
write
map
get
put
methods
log
well
balanced
tree
random
bsts
well
balanced
instead
array
implementation
worst
case
pathological
trees
writing
classes
will
run
junit
tests
verify
bit
strong
word
correct
may
also
find
useful
test
classes
driverfororderedcollection
driverformap
can
run
collection
jar
build
path
library
project
driver
can
individually
test
methods
classes
interactively
see
results
returned
values
state
changes
mostly
using
tostring
download
unzip
following
eclipse
project
start
use
start
working
program
part
assignmnment
will
update
turn
single
java
file
project
see
checkmate
submission
assignment
details
one
student
submit
assignment
student's
names
appear
comments
top
submitted
program
please
turn
program
finish
can
accurately
assess
progress
class
whole
assignment
print
document
carefully
read
marking
parts
contain
important
detailed
information
find
review
work
assignment
turn
files
problem
1
priority
queue
via
max
heap
program
will
write
efficient
version
priority
queue
implementing
max
heap
maximum
value
root
can
test
program
testpriorityqueue
junit
test
will
ultimately
grade
supermarket
shopping
simulation
driverfororderedcollection
program
can
individually
test
methods
classes
interactively
see
results
returned
values
state
changes
mostly
using
tostring
heappriorityqueue
class
must
implement
priorityqueue
interface
using
standard
priority
queue
semantics
highest
priority
already
implemented
behavior
using
linked
lists
underlying
data
structure
heap
uses
array
represent
tree
compactly
similarities
priority
queue
implemented
array
one
implemented
linked
list
representation
index
child
node
can
computed
index
parent
node
vice
versa
formulas
discussed
class
reviewed
think
tree
program
array
main
data
structure
array
even
though
think
tree
examine
code
arraypriorityqueue
class
pay
special
attention
tostring
shallowcopy
ensurecapacity
trimtosize
methods
issues
think
writing
class
array
length
size
mapping
recall
simple
mapping
indexes
parent
left
child
2
right
2
1
child
either
left
right
parent
2
first
node
heap
must
stored
index
1
array
index
0
changes
underlying
array
must
allocated
array
must
store
values
must
allocated
size
1
0
indexes
1
store
values
can
simplify
array
allocation
using
familiar
0
1
allocation
store
values
make
mapping
indexes
complex
parent
left
child
2
1
right
2
2
child
either
left
right
parent
1
2
become
familiar
mapping
looking
example
heap
10
15
values
may
use
either
mapping
one
described
given
ensurecapacity
trimtosize
methods
work
arrays
indexes
0
1
recommend
using
mapping
explained
paragraph
choose
way
will
represent
array
mapping
see
carefully
allocating
using
array
can
big
source
bugs
careful
suggest
putting
mappings
four
simple
private
static
methods
inheap
leftchild
rightchild
parent
first
determining
whether
index
heap
stored
final
three
taking
int
index
returning
another
int
index
simplify
code
hiding
mapping
details
matter
approach
take
slight
decrease
speed
can
put
raw
calculations
directly
code
one
interesting
approach
use
methods
first
make
debugging
code
easier
code
works
remove
methods
hardwire
calculation
find
much
speed
difference
go
back
using
methdods
makes
code
clearer
finally
also
write
private
helper
methods
following
three
operations
call
wherever
necessary
swap
called
two
indexes
swaps
values
stored
indexes
array
representing
heap
percolateup
called
one
index
percolates
value
index
high
go
percolatedown
called
one
index
percolates
value
index
low
go
percolate
methods
interesting
work
maintaining
heaps
code
trivial
write
can
written
simply
wrote
percolateup
2
lines
percolatedown
10
lines
although
lines
dense
suggest
constantly
think
simplifying
code
methods
aid
writing
correctly
course
must
really
understand
going
percolation
phases
hint
hand
simulation
recall
second
mapping
value
reaches
index
0
parent
index
process
value
index
left
child
2
1
objectcount
right
child
2
2
objectcount
alternative
mapping
bounds
bit
different
based
different
mapping
fact
values
stored
indexes
1
instead
0
1
attempt
process
non
existant
children
especially
true
percolate
find
biggest
child
possible
swap
may
check
just
one
children
constructors
first
two
constructors
create
arrays
appropriate
lengths
remember
based
mapping
using
array
version
linear
offline
operation
build
heap
discussed
class
rather
adding
values
heap
one
time
iterable
version
put
values
simple
collection
convert
array
use
array
constructor
actually
build
heap
tostring
tostring
method
return
heap
values
array
example
method
returns
using
second
mapping
using
driverfororderedcollection
tostring
heappriorityqueue
3
4
0
1
2
example
method
return
used
first
mapping
using
driverfororderedcollection
tostring
heappriorityqueue
3
5
0
used
1
2
3
notice
array
length
5
code
index
0
used
room
4
values
heap
heap
lengths
go
2
3
5
9
17
etc
always
1
bigger
power
2
iterator
hasnext
next
recall
iterator
iterate
values
priority
order
highest
lowest
unlike
array
linked
implementations
heap
implementation
never
stores
values
order
array
just
traverse
array
call
next
method
taking
1
time
two
ways
can
think
implement
iterator
constructing
iterator
actually
allocate
another
array
iterator
contains
values
heap
array
sort
approach
creating
iterator
even
used
requires
log
time
sorting
given
sorted
array
can
traverse
iterator
one
traverse
array
call
next
requiring
1
time
constructing
iterator
actually
store
shallow
copy
heappriorityqueue
iterator
approach
creating
iterator
even
used
requires
time
given
shallow
copy
call
next
can
call
remove
copy
heap
get
next
value
requiring
log
time
shallowcopy
must
work
correctly
method
work
since
copying
array
easy
write
approaches
array
storing
real
priority
queue
different
array
storing
one
iterated
constructing
iterator
iterating
values
log
case
careful
try
use
iterator
constructing
iterator
see
infinite
recursion
run
storage
space
might
problem
iterator
remove
might
expect
going
complicated
describe
turns
hard
implement
recall
know
remove
value
top
heap
put
value
end
array
top
swap
correct
position
can
remove
value
middle
heap
almost
simply
put
value
end
array
middle
overwriting
value
swap
correct
position
depending
compares
parent
children
might
think
value
swapped
middle
will
always
less
parent
construct
example
heap
last
value
greater
parent
value
removed
example
heap
6
nodes
think
minmal
keep
track
value
seen
asked
iterator
remove
can
linear
search
real
heap
array
one
iterator
using
gone
returned
next
find
value
use
total
operation
might
take
use
algorithm
remove
real
heap
fact
discover
remove
heap
remove
iterator
share
code
can
made
parameterized
private
method
usable
places
precolate
correct
position
see
percolateup
percolatedown
described
first
section
document
implement
next
hasnext
first
remove
end
feel
free
ask
questions
help
understand
just
one
many
things
questions
problems
getting
iterator
correct
just
implement
test
methods
driverfororderedcollection
recall
junit
test
testing
using
toarray
method
will
work
unless
iterator
works
finally
try
running
supermarket
simulation
program
arraypriorityqueue
working
heappriorityqueue
choose
2
checkout
lines
one
default
number
times
effectively
infinite
one
6
fewer
items
run
simulation
5
shoppers
tracing
set
true
help
understand
happening
run
50
000
100
000
shoppers
50
000
shoppers
speedup
using
heappriorityqueue
arraypriorityqueue
24
seconds
1
27
seconds
problem
2
map
via
bst
program
will
write
efficient
version
map
implementing
binary
search
tree
seen
pathological
trees
randomly
built
trees
much
closer
well
balanced
pathological
operations
operations
complexity
log
can
say
tree
height
play
safe
can
test
program
testmap
junit
test
will
ultimately
grade
updated
version
wordgenerator
program
included
download
program
1
part
6
file
huck
txt
also
included
download
driverformap
program
can
individually
test
methods
classes
interactively
see
results
returned
values
state
changes
mostly
using
tostring
will
supply
tostring
method
uses
recursion
return
string
prints
tree
rotated
90
degress
left
can
easily
see
structure
tree
building
running
junit
test
must
get
iterator's
hasnext
next
methods
working
correctly
otherwise
many
tests
will
fail
many
tests
use
iterator
indirectly
construct
sets
values
iterating
maps
iterator
works
incorrectly
sets
will
constructed
correctly
junit
test
will
fail
reason
operations
really
tested
incorrect
bstmap
class
must
implement
map
interface
using
standard
map
semantics
look
arraymap
class
contains
code
implements
map
interface
code
like
will
belong
bst
implementation
underlying
data
structure
binary
search
tree
whose
node
class
complete
within
implementation
also
includes
helper
methods
like
locate
add
remove
either
completley
written
just
header
specified
issues
think
writing
class
multiple
tree
searches
recursive
helper
methods
mutate
bst
like
insert
must
return
bst
node
found
convenient
first
call
locate
helper
method
based
result
call
call
one
recursive
mutator
method
sometimes
can
manipulate
located
reference
directly
example
put
method
code
first
tries
locate
key
tree
successful
code
changes
value
associated
key
changing
structure
tree
fails
code
inserts
new
entry
tree
appropriate
key
value
worst
two
searches
slow
methods
put
remove
map
remove
iterator
factor
two
way
squeeze
bit
speed
code
avoiding
duplicate
searches
required
carefully
changing
recursive
methods
using
another
instance
variable
suggest
code
using
double
search
approach
everything
working
inclination
time
explore
writing
complicated
code
wait
even
start
thinking
improvement
number
changes
small
high
technical
complexity
map
entry
recall
map
interface
defines
entry
interface
refer
map
entry
build
tree
need
use
class
implements
map
entry
node
note
abstractmap
class
classes
implement
map
use
superclass
defines
concrete
class
called
simpleentry
implements
map
entry
code
can
construct
use
simpleentry
objects
see
constructor
tostring
written
tostring
method
returns
2
picture
bst
rotated
left
90
degrees
usefull
quickly
quickly
looking
small
bst
example
method
returns
using
driverformap
showing
5
keys
values
tostring
bstmap
5
5
4
3
2
1
root
3
nodes
left
subtree
whose
root
key
1
node
right
subtree
whose
root
key
iterator
hasnext
next
heap
priority
queue
iterator
class
will
iterate
another
data
structure
case
stack
maximum
size
will
height
tree
discussed
kind
iterator
end
notes
covering
binary
search
trees
class
summarize
algorithm
see
notes
details
construct
iterator
allocate
stack
use
arraystack
data
structure
add
root
bst
empty
left
descendants
root
hasnext
returns
whether
stack
empty
next
removes
returns
reference
top
stack
adds
stack
root
right
subtree
empty
left
descendants
root
right
subtree
see
code
wrote
constructor
also
remembers
reference
case
iterator's
remove
called
iterator
remove
use
removeat
method
delete
bst
previous
value
returned
next
operation
affect
stack
also
run
updated
wordgenerator
program
large
text
file
huck
txt
update
allows
comment
code
select
either
arraymap
bstmap
appropriate
comparator
simple
change
data
structure
implements
data
type
also
tracks
prints
amount
time
needed
build
map
machine
took
18
minutes
using
arraymap
1
second
using
bstmap
speed
factor
1
000
used
order
statistic
3
ultimately
producing
map
contains
90
705
keys
key
mapping
list
1
46
words
