ics 142 winter 2004 assignment 3 
assignment 3 
ics
142
winter
2004
news
course
reference
schedule
lab
manual
ics
142
newsgroup
alex
ics
142
winter
2004
assignment
3
due
date
time
monday
february
23
11
59pm
introduction
tasks
scanning
parsing
largely
centered
around
program
language
permitted
look
like
often
called
language's
syntax
course
just
program
syntactically
correct
make
legal
program
semantics
programming
language
rules
describe
meaning
syntactically
legal
programs
additionally
semantic
rules
may
render
many
syntactically
legal
problems
erroneous
variety
reasons
example
following
java
program
syntactically
legal
public
class
public
static
void
main
string
args
int
0
system
println
parser
will
accept
program
legal
program
according
rules
java
syntax
course
know
program
legal
java
program
since
attempts
print
value
undeclared
variable
can
shown
context
free
grammars
used
express
rules
one
requires
variable
declared
use
rather
complicate
parsing
using
powerful
formalism
context
free
grammars
makes
sense
let
parsers
best
check
syntactic
correctness
defer
checking
semantic
rules
later
stage
compilation
using
traditional
programming
techniques
assignment
will
implement
semantic
analyzer
monkie2004
language
will
check
violations
semantic
rules
example
facilitate
analysis
will
first
augment
provided
parser
actions
build
intermediate
data
structure
called
abstract
syntax
tree
thanks
java's
object
oriented
features
code
perform
tasks
will
remarkably
concise
designed
well
substantial
portion
design
provided
starting
point
help
stay
right
track
cup
lalr
parser
generator
java
cup
lalr
parser
generator
takes
input
script
describes
parser
centrally
built
around
grammar
language
output
two
java
classes
together
implement
lalr
parser
language
lalr
parser
shift
reduce
parser
uses
similar
significantly
optimized
turns
slightly
less
powerful
techniques
discussed
lecture
generating
lr
1
parsing
tables
needs
general
structure
cup
script
cup
script
broken
informally
four
parts
import
package
directives
customization
code
listing
symbols
associated
types
grammar
annotated
actions
example
follows
import
package
directives
import
java
cup
runtime
customization
code
action
code
public
void
output
integer
dohcount
system
println
doh
count
dohcount
intvalue
symbol
listing
terminal
doh
nonterminal
goal
nonterminal
integer
homer
start
goal
specification
unique
start
symbol
grammar
annotated
actions
goal
homer
output
homer
doh
homer
result
new
integer
1
intvalue
doh
result
new
integer
1
combined
scanner
returns
doh
tokens
cup
script
generates
parser
counts
number
doh
tokens
input
program
outputs
total
system
cup
generated
parser
work
cup
generates
shift
reduce
parser
similar
ones
described
class
parser
will
maintain
stack
parser
states
symbols
make
sequence
decisions
either
shift
reduce
case
based
next
token
input
wanted
indication
whether
sentence
legal
need
input
accepted
parser
see
output
input
accepted
parser
see
simple
message
parse
error
parser
quit
soon
error
detected
however
complete
compiler
parser's
job
just
determine
acceptance
rejection
input
also
must
additional
work
seed
future
stages
compilation
boiled
version
input
program
means
additional
calculations
building
abstract
syntax
tree
maintaining
collection
declared
variables
types
must
done
simultaneously
first
might
seem
complicate
matters
tremendously
can
nicely
split
work
parsing
additional
calculations
shift
reduce
parser
sensible
time
kind
work
whenever
reduction
occurs
reduction
time
two
things
true
parser
just
completely
recognized
say
variabledeclaration
yet
recognized
code
follows
relevant
information
variabledeclaration
names
identifiers
colon
available
parser
stack
given
two
facts
reduction
variabledeclaration
accompanied
creation
object
stores
information
variable
declaration
identifiers
variable's
name
type
action
taken
parsing
continue
normally
support
kinds
actions
every
symbol
parser
stack
accompanied
value
represented
java
object
different
types
symbols
accompanied
different
types
objects
accompanied
objects
symbol
listing
cup
script
specifies
symbols
accompanied
types
example
homer
symbol
accompanied
integer
object
symbols
accompanied
object
step
step
example
cup
parser
working
input
string
doh
doh
doh
sake
clarity
left
parser
states
example
occurrence
homer
parser
stack
accompanied
integer
object
shown
example
homer
accompanied
integer
3
shown
stack
homer
3
bottom
stack
represented
parser
actionstackremaining
input
doh
doh
dohshift
dohdoh
dohshift
doh
dohdohshift
doh
doh
dohreduce
homer
¡÷
doh
doh
doh
homer
1reduce
homer
¡÷
doh
homer
doh
homer
2reduce
homer
¡÷
doh
homer
homer
3reduce
goal
¡÷
homer
3
printed
system
goal
effect
storing
objects
every
symbol
parser
stack
executing
actions
reduction
rule
grammar
acts
ways
like
function
programming
language
rule
reduced
information
accompanying
symbols
right
hand
side
synthesized
result
stored
symbol
left
hand
side
input
program
completely
parsed
information
will
synthesized
one
object
associated
start
symbol
turns
convenient
way
build
intermediate
representations
program
abstract
syntax
trees
discuss
bit
later
write
accessing
objects
stored
symbols
stack
requires
giving
names
example
consider
fragment
example
homer
doh
homer
result
new
integer
1
intvalue
rule
homer
¡÷
doh
homer
used
reduction
want
action
add
1
value
associated
homer
right
hand
side
store
result
homer
left
hand
side
object
associated
symbol
left
hand
side
rule
always
accessible
via
variable
called
result
objects
associated
symbols
right
hand
side
rule
can
accessed
give
names
example
given
homer
right
hand
side
name
writing
homer
action
rule
can
refer
object
associated
homer
right
hand
side
simply
using
name
wait
want
see
complete
example
action
problem
link
complete
version
homer
example
including
jflex
scanner
cup
parser
driver
program
sample
input
file
homerexample
zip
run
example
unzip
archive
folder
start
command
prompt
change
folder
unzipped
archive
run
following
commands
jflex
homer
flex
cup
homer
cup
javac
java
java
driver
inputfile
using
cup
ics
labs
cup
already
installed
windows
workstations
ics
labs
cup
primarily
driven
via
command
line
use
start
bringing
command
prompt
window
lab
machines
cup
configured
work
default
time
start
command
prompt
need
load
settings
executing
two
commands
cd
opt
ics142
start142
note
machines
lab
start142
bat
file
might
called
start
bat
instead
installation
bug
eradicated
fully
since
machines
always
time
update
case
execute
command
instead
start
dot
backslash
necessary
start
actually
windows
shell
command
installing
cup
home
prepared
installation
provided
part
assignment
1
contained
jflex
cup
assuming
installed
working
assignment
1
already
ready
use
cup
check
assignment
1
write
follow
installation
instructions
therein
compiling
cup
script
can
compile
cup
script
blah
cup
like
java
java
cup
main
blah
cup
cumbersome
type
also
gives
lousy
names
start
lowercase
letters
classes
generates
prefer
case
assignment
require
calling
parser
class
parser
symbol
class
tokens
requires
much
longer
command
java
java
cup
main
parser
parser
symbols
tokens
blah
cup
since
way
cumbersome
type
provided
batch
file
called
cup
bat
starting
point
homer
example
will
allow
use
command
compile
cup
script
instead
cup
blah
cup
will
create
two
java
source
files
parser
java
tokens
java
forget
compile
java
files
executing
program
unix
linux
users
can
write
shell
script
use
alias
accomplish
goal
windows
batch
file
changes
monkie2004
language
assignment
monkie2004
language
much
last
assignment
operators
added
rules
expressions
operators
took
order
keep
grammar
simpler
hand
coded
parser
now
using
cup
generate
parser
us
adding
operators
overburden
complexity
makes
monkie2004
much
expressive
changes
made
existing
operators
part
language
newly
added
operators
logical
boolean
operators
xor
added
operators
pretty
much
expect
pointed
xor
intended
short
circuited
meaning
operands
will
always
evaluated
short
circuited
versions
called
else
added
well
short
circuiting
affect
program
will
likely
affect
future
assignments
one
logical
operator
implies
added
takes
two
boolean
operands
evaluating
true
either
left
operand
false
left
operand
true
right
operand
true
like
else
implies
short
circuited
relational
operators
added
back
language
behavior
expect
precedence
associativity
new
operators
can
inferred
unambiguous
grammar
cup
script
provided
starting
point
static
semantic
rules
monkie2004
language
addition
lexically
syntactically
correct
monkie2004
program
must
follow
static
semantic
rules
order
considered
valid
program
violates
rules
considered
invalid
variables
procedures
functions
must
scope
wherever
used
following
rules
can
used
determine
whether
variable
procedure
function
scope
scope
local
variable
begins
declaration
continues
end
block
statement
declared
scope
global
variable
begins
declaration
continues
end
program
scope
formal
parameters
procedure
function
entire
block
statement
makes
body
procedure
function
scope
procedure
function
begins
declaration
continues
end
program
notably
allows
recursion
since
procedure
considered
scope
point
just
body
declared
identifier
procedure
function
may
redeclared
variable
procedure
function
redeclaration
considered
error
declared
scope
including
global
scope
variable
may
redeclared
scope
variable
procedure
function
redeclaration
considered
error
variable
declared
scoping
level
globally
block
statement
may
redeclared
deeper
scoping
level
block
statement
within
scope
originally
declared
oddly
rule
applies
formal
parameters
may
redeclared
within
body
procedure
function
since
formal
parameters
declared
outside
block
statement
makes
body
procedure
function
variable
used
declaration
found
using
static
scoping
rules
meaning
local
scope
searched
first
enclosing
scope
searched
next
none
enclosing
scopes
including
global
scope
contains
declaration
variable
use
variable
considered
error
every
function
variable
called
result
implicitly
declared
whose
type
represents
return
value
function
order
return
value
function
assign
value
result
let
function
end
normally
fall
bottom
result
scope
beginning
end
function
however
like
formal
parameters
legal
redeclare
within
function
hides
declaration
result
makes
impossible
return
value
three
data
types
monkie2004
integer
string
boolean
identifiers
reserved
meaning
variable
procedure
function
may
declared
names
declaration
considered
error
seven
pre
defined
procedures
functions
monkie2004
following
signatures
function
read
string
stringprocedure
print
string
string
function
read
integer
integerprocedure
print
integer
integer
function
read
boolean
booleanprocedure
print
boolean
boolean
procedure
print
endline
surprisingly
pre
defined
procedures
functions
used
console
input
output
exact
run
time
semantics
important
assignment
though
intended
pretty
much
expect
every
expression
subexpression
monkie2004
considered
type
integer
string
boolean
assignment
statement
variable
left
hand
side
must
declared
type
expression
right
hand
side
must
type
variable
left
hand
side
statement
type
conditional
expression
must
boolean
loop
type
conditional
expression
must
boolean
call
statement
foo
1
identifier
case
foo
must
declared
procedure
identifier
declared
function
variable
identifier
declared
call
statement
considered
error
call
made
expression
identifier
case
bar
must
declared
function
identifier
declared
procedure
variable
identifier
declared
call
considered
error
call
procedure
function
number
actual
parameters
must
match
number
formal
parameters
type
actual
parameter
must
match
type
formal
parameter
parameters
matched
order
listed
type
first
actual
parameter
must
match
type
first
formal
parameter
second
must
match
type
second
type
function
call
expression
return
type
function
called
type
integer
literal
expression
integer
type
string
literal
expression
string
type
constants
true
false
expression
boolean
type
identifier
expression
type
variable
refers
variable
declared
use
identifier
expression
considered
error
operand
operator
must
integer
type
expression
integer
operand
operator
must
boolean
type
expression
boolean
operands
operators
must
integers
types
expressions
integer
operands
operator
must
strings
type
expression
string
operands
operators
must
though
can
integer
string
boolean
types
expressions
boolean
operands
operators
must
must
either
integers
strings
types
expressions
boolean
operands
else
xor
implies
operators
must
boolean
types
expressions
boolean
wow
enjoyed
reading
supposed
program
will
perform
complete
static
analysis
input
program
provided
working
scanner
working
parser
actions
can
assume
lexical
syntactic
analysis
already
working
task
augment
parser
build
intermediate
form
called
abstract
syntax
tree
will
passed
semantic
analyzer
will
write
finished
assignment
program
capable
finding
compile
time
errors
monkie2004
program
know
find
exceedingly
cool
part
1
augmenting
parser
build
abstract
syntax
tree
ast
30
points
ast
abstract
syntax
tree
ast
tree
sense
binary
search
tree
nodes
type
however
tree
like
structure
contains
relevant
information
input
program
example
consider
brief
monkie2004
program
var
global
integer
procedure
program
global
abstract
syntax
tree
might
constructed
list
definitions
first
definition
variable
declaration
declaring
variable
global
type
integer
second
definition
procedure
declaring
procedure
called
program
contains
empty
list
parameters
block
statement
block
statement
list
four
statements
assignment
statement
three
procedure
calls
relevant
information
stored
nodes
object
oriented
languages
like
java
existed
building
abstract
syntax
tree
difficult
proposition
since
different
nodes
tree
represent
different
constructs
input
program
assignment
statements
function
calls
etc
thus
needed
stored
different
kinds
structures
using
java
building
abstract
syntax
tree
relatively
straightforward
thanks
inheritance
polymorphism
entire
abstract
syntax
tree
can
stored
list
structure
arraylist
object
arraylist
kind
definition
object
two
subclasses
variabledeclaration
subprogramdeclaration
subprogramdeclaration
objects
contain
information
either
procedure
function
course
something
object
tell
whether
represented
procedure
function
one
way
store
string
variable
containing
identifier
return
type
functions
containing
null
empty
string
procedures
continuing
line
thinking
probably
also
want
two
superclasses
statement
expression
statement
subclasses
assignmentstatement
blockstatement
ifstatement
expression
subclasses
orexpression
concatenationexpression
examples
assignmentstatement
object
might
contain
string
identifier
left
expression
object
expression
right
concatenationexpression
might
contain
two
expression
objects
one
left
right
operands
since
might
useful
error
reporting
nodes
keep
track
beginning
location
input
program
might
event
want
definition
statement
expression
extend
superclass
like
construct
constructs
two
integers
line
column
stored
solution
provided
classes
like
construct
definition
statement
expression
starting
point
building
ast
cup
parser
ast
takes
structure
simplified
version
structure
parse
tree
building
ast
cup
parser
relatively
straightforward
nonterminal
symbol
grammar
carry
ast
node
type
will
carry
specific
ast
node
types
ifstatement
whileloop
others
will
carry
less
specific
nodes
type
expression
definition
arraylist
parser
action
one
two
things
uses
information
right
hand
side
rule
construct
new
ast
node
appropriate
type
cases
add
list
structure
arraylist
passes
ast
node
right
hand
side
rule
directly
left
hand
side
nothing
done
cup
code
fragments
together
create
ast
node
global
variable
declaration
solution
may
differ
greatly
depending
design
ast
node
classes
give
general
idea
approach
use
case
nothing
added
ast
node
since
variabledeclaration's
action
something
led
presumably
created
ast
node
say
variabledeclaration
object
definition
variabledeclaration
vd
result
vd
enough
information
create
ast
node
variable
declaration
since
need
store
identifiers
variable's
name
type
typedeclaration
actions
create
object
just
use
action
pass
parse
tree
variabledeclaration
var
typedeclaration
td
semicolon
result
td
create
pass
variabledeclaration
object
solution
variabledeclaration
object
contained
four
fields
name
variable
name
variable's
type
line
column
beginning
construct
can
discovered
asking
first
identifier
line
column
supplied
scanner
typedeclaration
identifier
name
colon
identifier
typename
result
new
variabledeclaration
name
getvalue
typename
getvalue
name
getline
name
getcolumn
task
task
part
1
twofold
design
write
classes
ast
construct
language
decide
information
need
store
reuse
classes
much
can
example
blockstatement
class
extend
statement
likely
contain
collection
say
arraylist
statement
objects
use
construct
definition
statement
expression
classes
gave
start
modify
analyze
method
inherited
definition
statement
can
simply
left
blank
analyze
method
inherited
expression
returns
type
object
just
return
null
point
write
methods
part
2
add
actions
provided
cup
grammar
build
ast
place
node
representing
entire
ast
program
nonterminal
provided
driver
program
assumes
program's
nonterminal
will
given
arraylist
definition
objects
obey
convention
conclusion
work
part
1
program
will
output
anything
will
ready
add
code
part
2
couple
things
know
terminal
symbols
already
given
object
types
provided
cup
script
must
changed
since
scanner
one
creates
provides
objects
three
kinds
objects
associated
terminal
symbols
tokeninfo
object
contains
two
fields
line
column
corresponding
accessor
methods
getline
getcolumn
inttokeninfo
extends
tokeninfo
object
addition
line
column
tokeninfo
provides
additional
integer
value
type
used
integer
literal
tokens
scanner
can
pass
along
token's
integer
value
can
access
integer
value
inttokeninfo
object
calling
getvalue
stringtokeninfo
extends
tokeninfo
object
addition
line
column
tokeninfo
provides
additional
string
value
type
used
string
literal
identifier
tokens
scanner
can
pass
along
string
value
associated
tokens
can
access
string
value
stringtokeninfo
object
calling
getvalue
hand
need
specify
object
types
nonterminals
according
ast
design
part
2
performing
semantic
checking
ast
70
points
built
ast
time
write
semantic
analyzer
semantic
analyzer's
job
traverse
ast
call
analyze
method
nodes
therein
discussed
part
1
three
main
types
nodes
ast
definition
objects
statement
objects
expression
objects
order
analysis
need
additional
supporting
data
structure
called
symbol
table
symbol
table
keeps
track
declarations
identifiers
given
point
analysis
input
program
variables
types
subprograms
two
main
operations
can
perform
symbol
table
declare
lookup
declare
adds
new
declaration
symbol
table
lookup
finds
existing
one
provided
complete
efficient
implementation
symboltable
class
starting
point
keep
things
clear
since
different
kinds
declarations
monkie2004
program
separated
declare
operation
three
methods
declarevariable
declaresubprogram
declaretype
latter
doubt
use
since
monkie2004
allow
type
declarations
similarly
three
kinds
lookups
lookupsubprogram
lookuptype
lookupvariable
along
fourth
lookuplocalvariable
useful
times
addition
two
methods
enterscope
exitscope
need
call
whenever
enter
exit
scope
respectively
take
look
comments
symboltable
java
file
provided
want
know
class
symbol
table
passed
analyze
methods
parameter
will
always
available
analysis
symbol
table
already
done
implementing
semantic
analyzer
will
matter
writing
code
analyze
methods
left
blank
return
null
part
1
analyze
method
want
two
things
perform
semantic
checks
make
sure
node
represents
legal
operation
monkie2004
naturally
checking
depends
kind
operation
local
variable
declaration
check
variable
already
declared
scope
call
statement
check
right
number
types
actual
parameters
passed
call
procedure
function
nodes
global
local
variable
declarations
procedure
function
definitions
want
add
declaration
symbol
table
declaration
deemed
legal
case
expression
need
one
thing
analyze
return
type
expression
necessary
performing
analysis
nested
expressions
done
bottom
types
inner
expressions
used
part
analysis
outer
expressions
important
point
semantic
errors
reported
calling
reportsemanticerror
inherited
construct
class
see
comments
provided
code
details
throw
exception
semantic
error
found
since
program
needs
find
many
semantic
errors
can
discussed
next
section
error
reporting
error
recovery
requirements
provided
program
will
automatically
abort
error
message
lexical
error
detected
scanner
similarly
cup
script
already
configured
abort
program
error
message
syntax
error
detected
parser
behaviors
acceptable
left
neither
required
permitted
add
error
recovery
parser
keep
things
simple
plenty
program
determined
syntactically
legal
abstract
syntax
tree
built
semantic
analyzer
required
find
many
errors
can
input
program
may
simply
abort
finds
first
error
example
monkie2004
program
number
semantic
errors
challenge
might
first
want
find
errors
reading
see
sample
output
var
globalinteger
integer
function
factorial
integer
integer
0
result
given
sample
input
program
semantic
analyzer
gives
following
output
semantic
error
5
8
incompatible
operands
'
'
semantic
error
7
9
source
target
types
assignment
match
semantic
error
11
9
'resul'
declared
variable
semantic
error
11
22
argument
1
function
'factorial'
wrong
type
semantic
error
22
5
loop
condition
must
boolean
expression
semantic
error
26
9
procedure
'print
strin'
declared
semantic
error
28
13
'hoorah'
type
7
semantic
error
found
semantic
analyzer
required
print
exactly
error
messages
though
find
least
problems
input
program
error
messages
must
understandable
must
state
error
required
exactly
mine
obviously
preceding
example
contain
every
possible
semantic
error
can
arise
monkie2004
program
program
required
find
errors
implied
static
semantic
rules
listed
previously
write
ideally
analyzer
will
print
many
spurious
error
messages
example
consider
following
monkie2004
code
fragment
var
integer
var
integer
var
integer
var
boolean
var
boolean
var
boolean
var
string
var
string
var
string
assume
variables
initialized
somehow
expression
appear
lots
places
implies
alex
couple
problems
expression
left
operand
implies
expression
evaluates
integer
right
operand
expression
alex
evaluates
string
analyzer
report
two
errors
additional
errors
right
operand
implies
expression
incorrect
easiest
way
ensure
analyzer
report
many
error
messages
expression
involving
operator
type
check
operands
reporting
errors
find
assume
overall
expression's
type
whatever
supposed
result
3
8
though
erroneous
will
considered
type
string
expression
whose
type
determine
undeclared
variable
consider
type
type
easily
implemented
java
null
type
reference
type
checking
code
never
report
errors
caused
expression's
type
type
course
care
required
choose
approach
since
might
easily
cause
nullpointerexceptions
forgetting
check
null
might
instead
use
approach
special
type
object
starting
point
great
deal
code
provided
order
get
started
available
zip
archive
startingpoint
zip
deliverables
place
completed
cup
script
java
files
comprise
program
including
gave
zip
archive
submit
zip
archive
need
include
java
files
created
cup
parser
java
tokens
java
penalize
however
aware
regenerating
grading
process
sure
really
come
cup
script
please
include
files
class
files
zip
archive
follow
link
discussion
submit
assignment
remember
accept
paper
submissions
assignments
accept
via
email
circumstances
order
keep
grading
process
relatively
simple
require
keep
program
designed
way
can
compiled
executed
following
set
commands
cup
monkie
cup
javac
java
java
driver
inputfile
word
advice
know
always
say
stress
enough
assignment
start
early
amount
code
will
much
sounds
complete
solution
approximately
2000
lines
code
providing
good
percentage
quite
bit
complexity
get
mind
around
order
implement
program
starting
early
getting
questions
answered
come
will
paramount
wait
last
day
two
wonder
abstract
syntax
tree
almost
certainly
going
bomb
assignment
hand
starting
early
understanding
concepts
one
time
likely
find
figure
key
concepts
code
can
written
relatively
easiliy
assignment
will
challenging
tractable
satisfying
end
good
luck
limitations
may
make
changes
monkie2004
grammar
given
except
writing
actions
adding
names
symbols
need
refer
associated
values
example
rule
given
grammar
variabledeclaration
var
typedeclaration
semicolon
may
change
look
like
variabledeclaration
var
typedeclaration
typedec
semicolon
action
code
goes
may
restructure
rewrite
rules
way
naturally
required
add
object
types
nonterminal
symbols
given
cup
script
changing
nonterminal
program
nonterminal
arraylist
program
changes
cup
script
permitted
originally
written
alex
thornton
winter
2004
