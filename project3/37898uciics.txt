ics 180 january 14 1999 
position evaluation 
ics
180a
spring
1997
strategy
board
game
programming
lecture
notes
april
10
1997
evaluation
functions
general
considerations
evaluation
function
game
specific
knowledge
goes
program
start
two
basic
assumptions
can
represent
quality
position
number
instance
number
might
estimate
probability
can
win
game
programs
try
make
number
mean
anything
specific
just
number
quality
measure
quality
opponent
measures
think
good
position
opponent
thinks
bad
position
vice
versa
unlikely
really
true
needed
make
search
algorithms
work
well
practice
comes
pretty
close
truth
evaluation
can
less
complicated
depending
much
knowledge
build
complicated
knowledge
encodes
slower
likely
typically
performance
program
well
plays
estimated
behaving
like
product
knowledge
speed
fast
dumb
program
can
often
make
better
adding
knowledge
slowing
little
additional
knowledge
slowdown
might
actually
make
smart
slow
program
worse
diminishing
rate
return
performance
knowledge
similarly
speed
program
past
certain
point
diminishing
improvement
adding
speed
better
balancing
speed
knowledge
somewhere
closer
middle
chart
balance
point
varies
somewhat
depending
kind
opponent
expect
face
speed
works
better
defeating
computers
human
opponents
good
exploiting
holes
knowledge
easily
defeated
knowledge
based
programs
implementation
methods
two
major
types
evaluation
function
method
first
end
point
evaluation
simply
evaluate
position
independently
position
using
favorite
evaluation
algorithm
can
give
good
results
slow
programmers
resorted
following
trick
known
pre
computation
first
order
evaluation
piece
square
tables
begin
search
best
move
position
examine
carefully
position
compute
values
store
array
square
piece
type
evaluation
position
found
search
will
simply
sum
array
values
pieces
position
compute
sum
scratch
step
instead
moving
piece
one
square
another
update
score
using
formula
score
new
square
piece
old
square
piece
examples
piece
square
table
values
chess
king
castled
corner
board
pawns
front
useful
defending
attacks
ability
defend
becomes
less
move
forward
king
corner
starting
position
search
might
build
piece
square
tables
pawns
values
1
1
1
1
1
1
1
1
1
1
1
1
1
2
1
2
1
2
three
rows
front
king
encourage
pawns
stay
close
king
giving
greater
value
usual
one
point
nearby
unfortunately
piece
square
tables
blindingly
fast
can
incorporate
interesting
kinds
knowledge
way
piece
square
tables
pretty
stupid
general
take
account
interactions
several
moving
pieces
interactions
approximated
looking
pieces
piece
square
table
computed
instance
search
long
sequence
moves
king
goes
different
part
board
piece
square
table
values
inaccurate
making
pawns
defend
place
king
used
rather
defending
king
programs
use
piece
square
tables
often
combine
amount
end
point
evaluation
another
strategy
making
piece
square
table
methods
accurate
delay
building
tables
later
search
searching
9
move
sequences
build
tables
sequences
5
moves
use
remaining
4
move
search
though
careful
make
tables
resulting
one
5
move
sequence
consistent
sequences
overall
evaluation
scores
can
compared
meaningfully
class
dave
suggested
another
possible
improvement
make
incremental
modifications
piece
square
tables
move
bonuses
pawns
front
kings
kings
move
seems
like
good
idea
know
whether
implemented
well
worked
combine
evaluation
terms
typically
like
first
order
evaluations
evaluation
function
sum
several
terms
term
result
function
looks
certain
specific
information
position
sums
relatively
simple
way
combining
information
works
ok
practice
feeling
game
programmers
really
try
carefully
model
evaluation
functions
probabilities
combine
terms
determine
probabilities
winning
soon
carrying
kind
attack
moderate
number
moves
endgame
say
taking
advantage
passed
pawn
chess
combine
probabilities
appropriately
probability
winning
soon
black
bs
white
ws
probability
winning
moderate
number
moves
assuming
sooner
win
bm
wm
probability
winning
endgame
overall
probability
winning
bs
1
bs
ws
bm
1
bs
ws
bm
wm
ws
1
bs
ws
wm
1
bs
ws
bm
wm
think
might
useful
idea
evaluation
function
compute
terms
estimating
individual
probabilities
combine
formulas
like
ones
well
probability
estimated
tested
comparing
program's
estimates
actual
results
databases
games
give
program
ability
rudimentary
planning
judging
whether
go
certain
attack
based
likely
work
purely
speculation
tested
real
program
go
far
wrong
just
using
sums
kinds
information
go
evaluation
functions
evaluation
functions
typically
combine
terms
encoding
knowledge
different
types
material
sum
point
values
chess
number
pieces
player
board
go
othello
often
useful
othello
provides
interesting
counterexample
game
based
end
material
count
middle
game
positions
pretty
bad
idea
base
evaluation
material
since
often
player
better
position
will
actually
fewer
pieces
games
go
moku
material
irrelevant
since
function
move
good
board
position
space
games
one
can
partition
board
regions
controlled
one
player
regions
controlled
player
regions
still
dispute
instance
main
idea
go
also
comes
games
including
chess
one
player's
region
consists
squares
attacked
protected
pieces
attacked
protected
opponent's
othello
one
player
connected
group
pieces
surrounding
corner
pieces
can
never
taken
form
part
player's
territory
space
evaluation
simply
sizes
regions
less
simply
total
importance
regions
way
saying
one
square
important
another
mobility
many
different
moves
player
available
idea
choices
move
much
likely
least
one
will
lead
good
position
works
well
othello
useful
chess
used
chess
programmers
taken
programs
seem
help
quality
overall
evaluation
tempo
closely
related
mobility
comes
games
like
othello
connect
4
certain
chess
endgames
can
often
disadvantage
forced
move
unlike
mobility
terms
often
parity
number
available
moves
whether
odd
even
matters
total
number
instance
consider
connect
4
position
columns
1
3
4
7
filled
move
must
columns
2
5
6
moves
column
6
neutral
either
player
can
make
without
winning
losing
black
controls
column
2
red
can
play
safely
let
black
win
getting
four
row
neither
player
can
move
safely
column
4
player
immediately
win
red
plays
next
three
moves
column
6
black
will
forced
move
column
2
giving
control
column
three
moves
later
black
will
move
column
5
red
will
win
black
one
play
next
three
moves
later
red
will
forced
make
losing
move
connect
4
endgames
columns
even
number
spaces
left
unimportant
important
quantity
measure
number
odd
columns
one
player
can
move
one
player
controls
odd
columns
likely
win
number
odd
columns
controlled
player
equal
board
shown
red
controls
none
columns
black
controls
even
column
important
quantity
number
odd
neutral
columns
odd
next
player
play
will
win
even
next
player
will
lose
course
simple
analysis
needs
made
sophisticated
handle
positions
one
player
controls
positions
higher
columns
games
go
strict
parity
rules
important
still
matters
initiative
player
can
choose
play
player
forced
respond
area
board
often
good
idea
make
sequence
moves
take
small
amount
space
force
opponent
respond
making
larger
move
takes
space
allows
opponent
take
initiative
threats
opponent
something
bad
something
good
chess
go
pieces
likely
captured
go
moku
connect
4
either
player
number
pieces
lined
chess
checkers
pawn
queened
kinged
othello
one
player
take
corner
sort
term
vary
according
immediacy
strength
threat
shape
go
connected
groups
pieces
safe
capture
surround
two
separate
regions
territory
called
eyes
chess
side
side
pawns
generally
much
stronger
pawns
stacked
column
shape
based
terms
especially
important
measure
long
term
qualities
position
change
much
moves
covered
search
searching
finds
short
range
tactics
attempt
improve
overall
evaluation
evaluation
needs
include
long
term
features
search
trying
make
happen
motifs
particular
patterns
pieces
common
enough
worth
including
special
case
terms
cover
chess
example
bishop
can
often
capture
pawn
outside
column
trapped
moving
another
pawn
forward
bishop
trapped
may
still
take
many
moves
opponent
maneuver
piece
position
capture
fact
trapped
may
obvious
computer's
search
routine
programs
included
special
evaluation
terms
warn
computer
taking
pawn
might
mistake
othello
sometimes
useful
sacrifice
one
corner
placing
stone
next
corner
opponent
takes
corner
one
can
put
another
stone
next
corner
way
taken
leads
win
different
corner
white
sacrificed
bottom
left
corner
black
plays
bottom
left
white
will
play
next
win
bottom
right
corner
might
worthwhile
special
evaluation
code
examine
sacrifices
determine
extent
worthwhile
make
include
measure
quality
position
vulnerability
edge
pieces
sacrifice
david
eppstein
dept
information
computer
science
uc
irvine
monday
22
feb
1999
18
11
25
pst
