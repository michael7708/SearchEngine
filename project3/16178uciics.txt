sorting divide conquer 
three divide conquer sorting algorithms 
ics
161
design
analysis
algorithms
lecture
notes
january
18
1996
three
divide
conquer
sorting
algorithms
today
finish
heapsort
describe
mergesort
quicksort
need
multiple
sorting
algorithms
different
methods
work
better
different
applications
heapsort
uses
close
right
number
comparisons
needs
move
data
around
quite
bit
can
done
way
uses
little
extra
memory
probably
good
memory
tight
sorting
many
small
items
come
stored
array
merge
sort
good
data
big
memory
pattern
storage
access
regular
also
uses
even
fewer
comparisons
heapsort
especially
suited
data
stored
linked
lists
quicksort
also
uses
comparisons
somewhat
two
like
heapsort
can
sort
place
moving
data
array
heapification
recall
idea
heapsort
heapsort
list
make
heap
make
empty
list
nonempty
remove
smallest
add
return
remember
heap
just
balanced
binary
tree
value
node
smaller
values
children
went
last
time
total
number
comparisons
log
however
many
needed
make
missing
step
make
heap
start
can
set
binary
tree
right
size
shape
put
objects
tree
old
order
easy
require
comparisons
now
switch
objects
around
get
back
order
divide
conquer
idea
find
natural
subproblems
solve
recursively
combine
get
overall
solution
obvious
subproblems
subtrees
solve
recursively
get
something
close
heap
except
perhaps
root
satisfy
heap
property
make
whole
thing
heap
merely
percolate
value
lower
level
tree
heapify
tree
nonempty
heapify
left
subtree
heapify
right
subtree
let
value
tree
root
node
containing
satisfy
heap
propert
switch
values
node
smallest
child
loop
performs
two
comparisons
per
iteration
takes
log
iterations
time
satisfies
recurrence
2
2
2
log
solve
divide
conquer
recurrences
general
divide
conquer
based
following
idea
whole
problem
want
solve
may
big
understand
solve
break
smaller
pieces
solve
pieces
separately
combine
separate
pieces
together
analyze
generality
suppose
pieces
size
merging
takes
time
heapification
example
2
log
will
always
true
sometimes
pieces
will
overlap
easiest
way
understand
going
draw
tree
nodes
corresponding
subproblems
labeled
size
subproblem
simplicity
assume
power
recursion
stops
1
notice
size
node
depends
level
size
time
taken
node
level
time
many
levels
can
get
1
bottom
level
1
log
log
many
items
level
putting
together
log
log
sum
0
looks
messy
bad
terms
logarithmically
many
often
sum
dominated
terms
one
end
log
log
fact
will
generally
logarithmic
factor
away
truth
approximate
solution
sum
two
log
log
use
analyze
heapification
plugging
parameters
2
log
get
log
2
sum
2
log
2
0
rewriting
terms
opposite
order
turns
equal
log
2
sum
2
log
2
0
log
2n
sum
2
0
infty
2n
sum
2
0
4n
heapification
takes
4n
comparisons
heapsort
takes
log
4n
log
1
44n
lower
bound
within
absolute
best
possible
example
sorting
algorithm
one
part
used
divide
conquer
whole
algorithm
way
merge
sort
according
knuth
merge
sort
one
earliest
sorting
algorithms
invented
john
von
neumann
1945
look
combine
step
first
suppose
data
close
sorted
forms
two
sorted
lists
want
merge
two
sorted
lists
quickly
rather
resort
general
purpose
sorting
algorithm
easy
enough
merge
l1
l2
list
empty
neither
l1
l2
empty
compare
first
items
l1
l2
remove
smaller
two
list
add
end
catenate
remaining
list
end
return
time
analysis
worst
case
lists
empty
time
everything
compared
comparison
adds
one
item
worst
case
1
l1
l2
1
comparisons
one
can
little
better
sometimes
l1
smaller
l2
know
combine
two
sorted
lists
can
construct
divide
conquer
sorting
algorithm
simply
divides
list
two
sorts
two
recursively
merges
results
merge
sort
length
2
return
else
split
lists
l1
l2
2
elements
l1
merge
sort
l1
l2
merge
sort
l2
return
merge
l1
l2
simpler
heapsort
easier
program
works
pretty
well
many
comparisons
use
can
use
analysis
merge
step
write
recurrence
1
2c
2
saw
homework
1
31
power
2
solution
log
1
similar
complicated
prove
least
power
2
version
can
use
formula
produce
log
sum
2
2
1
0
log
sum
2
0
log
1
2n
1
log
1
number
comparisons
even
less
heapsort
quicksort
quicksort
invented
tony
hoare
follows
similar
divide
conquer
idea
partition
two
lists
put
back
together
work
divide
side
less
combine
side
merge
sort
worked
matter
split
lists
one
obvious
way
take
first
2
last
2
elements
another
take
every
element
perform
splits
everything
one
list
smaller
everything
information
used
make
merging
much
easier
merge
just
concatenating
lists
split
one
list
smaller
alphabetical
order
split
use
split
depending
data
looks
like
want
comparison
sorting
algorithm
works
data
quicksort
uses
simple
idea
pick
one
object
list
split
rest
quicksort
length
2
return
else
pick
l1
l2
l3
quicksort
l1
quicksort
l2
return
concatenation
l1
l3
l2
need
sort
l3
everything
equal
quicksort
analysis
partition
step
quicksort
takes
1
comparisons
can
write
recurrence
total
number
comparisons
done
quicksort
1
sizes
l1
l2
generally
satisfying
1
worst
case
might
pick
minimum
element
0
1
recurrence
simplifies
1
1
2
seems
like
bad
algorithm
call
quicksort
can
make
less
bad
randomization
suppose
pick
chosen
randomly
value
equally
likely
0
1
average
case
analysis
write
sum
possible
random
choices
probability
choice
times
time
choice
choices
values
probabilities
1
times
can
described
formulas
involving
time
recursive
calls
algorithm
average
case
analysis
randomized
algorithm
gives
randomized
recurrence
1
sum
1
1
1
0
simplify
recurrence
note
occurs
one
place
sum
number
will
occur
1
another
term
rearrange
sum
group
two
together
can
also
take
1
parts
sum
since
sum
1
copies
1
times
1
just
1
1
1
sum
2
0
book
gives
two
proofs
log
induction
easier
one
useful
idea
want
prove
hides
much
information
instead
need
prove
know
value
take
work
left
variable
use
analysis
see
values
work
1
0
1
log
1
suppose
log
1
sum
2
1
sum
2
ai
log
1
2a
sum
2
1
log
1
2a
integral
2
log
1
2a
2
log
2
2
4
2
ln
2
1
1
log
2
1
will
work
1
2
particular
2
can
conclude
2
log
note
worse
either
merge
sort
heap
sort
requires
random
number
generator
avoid
really
bad
pretty
commonly
used
can
tuned
various
ways
work
better
instance
let
median
three
randomly
chosen
values
rather
just
one
value
ics
161
dept
information
computer
science
uc
irvine
last
update
02
may
2000
20
17
36
pdt
