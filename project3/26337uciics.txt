domains concern software architectures 
html 
domains
concern
software
architectures
architecture
description
languages
nenad
medvidovic
david
rosenblum
department
information
computer
science
university
california
irvine
irvine
california
92697
3425
neno
dsr
ics
uci
edu
abstract
software
architectures
shift
focus
developers
lines
code
coarser
grained
elements
interconnection
structure
architecture
description
languages
adls
proposed
domain
specific
languages
domain
software
architecture
still
little
consensus
research
community
problems
important
address
study
software
architecture
aspects
architecture
modeled
adl
even
adl
shed
light
issues
provide
framework
architectural
domains
areas
concern
study
software
architectures
evaluate
existing
adls
respect
framework
study
relationship
architectural
application
domains
one
conclusion
architectural
domains
perspective
enables
one
approach
architectures
adls
new
structured
manner
understanding
architectural
domains
tie
application
domains
specific
influence
adls
needed
keywords
software
architecture
architecture
description
language
domain
domain
specific
language
architectural
domain
contents
1
introduction
2
overview
adls
2
1
definitions
architecture
style
2
2
definition
adls
2
3
categorizing
adls
2
4
applications
adls
2
5
architecture
vs
design
3
architectural
domains
3
1
representation
3
2
design
process
support
3
3
analysis
3
3
1
static
analysis
3
3
2
dynamic
analysis
3
4
evolution
3
4
1
specification
time
evolution
3
4
2
execution
time
evolution
3
5
refinement
3
6
traceability
3
7
simulation
executability
4
adl
support
architectural
domains
4
1
representation
4
2
design
process
support
4
3
analysis
4
3
1
static
analysis
4
3
2
dynamic
analysis
4
4
evolution
4
4
1
specification
time
evolution
4
4
2
execution
time
evolution
4
5
refinement
4
6
traceability
4
7
simulation
executability
4
8
summary
5
architectural
vs
application
domains
6
conclusions
7
acknowledgements
8
references
footnotes
1
introduction
software
architecture
aspect
software
engineering
directed
reducing
costs
developing
applications
increasing
potential
commonality
among
different
members
closely
related
product
family
pw92
gs93
software
development
based
common
architectural
idioms
focus
shifted
lines
code
coarser
grained
architectural
elements
overall
interconnection
structure
enables
developers
abstract
away
unnecessary
details
focus
big
picture
system
structure
high
level
communication
protocols
assignment
software
components
connectors
hardware
components
development
process
many
researchers
realized
obtain
benefits
architectural
focus
software
architecture
must
provided
body
specification
languages
analysis
techniques
gar95
gpt95
wolf96
languages
needed
demonstrate
properties
system
upstream
thus
minimizing
costs
errors
also
needed
provide
abstractions
adequate
modeling
large
system
ensuring
sufficient
detail
establishing
properties
interest
large
number
architecture
description
languages
adls
proposed
embodies
particular
approach
specification
evolution
architecture
examples
rapide
lka
95
lv95
aesop
gao94
metah
ves96
unicon
sdk
95
darwin
mdek95
mk96
wright
ag94a
ag94b
c2
mtw96
mort96
med96
sadl
mqr95
recently
initial
work
done
architecture
interchange
language
acme
gmw95
gmw97
intended
support
mapping
architectural
specifications
one
adl
another
hence
provide
bridge
different
foci
resulting
support
tools
still
much
lack
consensus
research
community
adl
aspects
architecture
modeled
adl
interchanged
interchange
language
divergence
resulted
wide
variation
approaches
found
first
generation
adls
perhaps
even
significantly
wide
difference
opinions
problems
important
address
study
software
architecture
previous
research
provided
foundation
understanding
defining
classifying
comparing
adls
med97
mt97
paper
build
upon
results
identifying
characterizing
architectural
domains
problems
areas
concern
need
addressed
adls
understanding
domains
properties
key
better
understanding
needs
software
architectures
architecture
based
development
architectural
description
interchange
study
architectural
domains
also
needed
guide
development
next
generation
adls
paper
presents
framework
architectural
domains
demonstrate
existing
adl
currently
supports
small
subset
domains
discuss
possible
reasons
finally
consider
relationship
architectural
domains
application
domains
draw
previous
adl
work
reference
number
adls
significant
contribution
paper
framework
architectural
domains
provides
structure
field
approached
largely
ad
hoc
fashion
thus
far
framework
gives
architect
sound
foundation
selecting
adl
orients
discourse
away
arguments
notation
towards
solving
important
engineering
problems
remainder
paper
organized
follows
section
2
provides
short
discussion
adls
section
3
presents
motivates
architectural
domain
section
4
discusses
support
architectural
domains
existing
adls
section
5
expounds
relationship
application
domains
architectural
domains
discussion
conclusions
round
paper
2
overview
adls
properly
enable
discussion
several
definitions
needed
section
define
software
architectures
architectural
styles
adls
footnote
1
categorize
adls
differentiate
similar
notations
discuss
examples
use
adls
actual
projects
finally
provide
short
discussion
use
terms
architecture
design
2
1
definitions
architecture
style
standard
definition
architecture
will
use
working
definition
one
provided
garlan
shaw
gs93
software
architecture
level
design
goes
beyond
algorithms
data
structures
computation
designing
specifying
overall
system
structure
emerges
new
kind
problem
structural
issues
include
gross
organization
global
control
structure
protocols
communication
synchronization
data
access
assignment
functionality
design
elements
physical
distribution
composition
design
elements
scaling
performance
selection
among
design
alternatives
architectural
style
set
design
rules
identify
kinds
components
connectors
may
used
compose
system
subsystem
together
local
global
constraints
way
composition
done
sc96
2
2
definition
adls
loosely
defined
adl
software
applications
focuses
high
level
structure
overall
application
rather
implementation
details
specific
source
module
ves93
adls
provide
concrete
syntax
conceptual
framework
modeling
software
system's
conceptual
architecture
building
blocks
architectural
description
components
units
computation
data
stores
connectors
architectural
building
blocks
used
model
interactions
among
components
rules
govern
interactions
architectural
configurations
connected
graphs
components
connectors
describe
architectural
structure
adl
must
provide
means
explicit
specification
criterion
enables
one
determine
whether
particular
notation
adl
order
infer
kind
information
architecture
minimum
interfaces
constituent
components
must
also
modeled
formally
without
information
architectural
description
becomes
collection
interconnected
identifiers
adl's
conceptual
framework
typically
subsumes
formal
semantic
theory
theory
part
adl's
underlying
framework
characterizing
architectures
influences
adl's
suitability
modeling
particular
kinds
systems
highly
concurrent
systems
particular
aspects
given
system
static
properties
examples
formal
specification
theories
petri
nets
pet62
statecharts
har87
partially
ordered
event
sets
lvb
93
communicating
sequential
processes
csp
hoa85
model
based
formalisms
chemical
abstract
machine
iw95
spi89
algebraic
formalisms
obj
gw88
axiomatic
formalisms
anna
luc87
finally
even
though
suitability
given
language
modeling
architectures
independent
whether
kinds
tool
support
provides
accompanying
toolset
will
render
adl
usable
useful
furthermore
capabilities
provided
toolset
often
direct
reflection
adl's
intended
use
2
3
categorizing
adls
existing
languages
commonly
referred
adls
can
grouped
three
categories
based
model
configurations
implicit
configuration
languages
model
configurations
implicitly
interconnection
information
distributed
across
definitions
individual
components
connectors
line
configuration
languages
model
configurations
explicitly
specify
connector
information
part
configuration
line
explicit
configuration
languages
model
components
connectors
separately
configurations
first
category
implicit
configuration
languages
definition
given
paper
adls
although
may
serve
useful
tools
modeling
certain
aspects
architectures
example
implicit
configuration
language
artek
tlpd95
artek
configuration
specification
instead
connector
specifies
component
ports
attached
focus
conceptual
architecture
explicit
treatment
connectors
first
class
entities
differentiate
adls
module
interconnection
languages
mils
dk76
pn86
programming
languages
object
oriented
notations
languages
unified
method
br95
mils
typically
describe
uses
relationships
among
modules
implemented
system
support
one
type
connection
ag94a
sg94
programming
languages
describe
system's
implementation
whose
architecture
typically
implicit
subprogram
definitions
calls
explicit
treatment
connectors
also
distinguishes
adls
oo
languages
demonstrated
lvm95
important
note
however
less
firm
boundary
adls
mils
certain
adls
wright
rapide
model
components
connectors
high
level
abstraction
assume
prescribe
particular
relationship
architectural
description
implementation
refer
languages
implementation
independent
hand
several
adls
unicon
metah
enforce
high
degree
fidelity
implementation
architecture
components
modeled
languages
directly
related
implementations
module
interconnection
specification
may
indistinguishable
architectural
description
language
implementation
constraining
languages
2
4
applications
adls
adls
special
purpose
notations
whose
specific
foci
render
suitable
powerful
analyses
simulation
automated
code
generation
however
yet
find
place
mainstream
software
development
although
current
research
way
bridge
gap
separates
adls
widely
used
design
notations
rmrr97
small
number
existing
adls
applied
large
scale
real
world
examples
date
examples
demonstrate
potential
effective
use
adls
software
projects
wright
used
model
analyze
runtime
infrastructure
rti
department
defense
dod
high
level
architecture
simulations
hla
all96
original
specification
rti
100
pages
long
wright
able
substantially
condense
specification
reveal
several
inconsistencies
weaknesses
sadl
applied
operational
power
control
system
used
tokyo
electric
power
company
system
implemented
200
000
lines
fortran
77
code
sadl
used
formalize
system's
reference
architecture
ensure
consistency
implementation
architecture
finally
rapide
used
several
large
scale
projects
thus
far
representative
example
open
distributed
transaction
processing
dtp
industry
standard
documentation
standard
400
pages
long
reference
architecture
subsequent
extensions
successfully
specified
simulated
rapide
lka
95
2
5
architecture
vs
design
given
definition
software
architectures
adls
issue
worth
addressing
relationship
architecture
design
current
literature
leaves
question
largely
unanswered
allowing
several
interpretations
architecture
design
architecture
level
abstraction
design
simply
another
step
artifact
software
development
process
architecture
something
new
somehow
different
design
just
remains
unspecified
three
interpretations
partially
correct
large
extent
architectures
serve
purpose
design
however
explicit
focus
connectors
configurations
distinguishes
traditional
software
design
time
high
level
architecture
refined
connectors
lose
prominence
becoming
distributed
across
lower
level
architecture's
elements
lower
level
architecture
may
indeed
considered
design
keeping
relationship
mind
reasons
simplicity
will
simply
refer
architectures
high
level
low
level
forth
remainder
paper
design
will
refer
process
results
architecture
3
architectural
domains
adls
typically
share
syntactic
constructs
enable
model
components
component
interfaces
connectors
configurations
footnote
2
much
greater
source
divergence
different
adls'
conceptual
frameworks
consequently
support
modeling
architectural
semantics
adl
developers
typically
decided
focus
specific
aspect
architectures
architectural
domain
guides
selection
underlying
semantic
model
set
related
formal
specification
notations
formal
notations
turn
restrict
types
problems
adl
suitable
relationship
architectural
domain
candidate
formal
notations
rarely
straightforward
fully
understood
absence
objective
criteria
adl
researchers
forced
base
decisions
intuition
experience
biases
arising
past
research
accomplishments
unfortunately
intuition
can
often
misleading
experience
insufficient
young
discipline
software
architectures
paper
attempt
fill
void
remainder
section
motivates
formulates
framework
classifying
problems
architectural
models
focus
architectural
domains
shown
figure
1
architectural
domains
represent
broad
classes
problems
likely
reflected
many
adls
associated
formal
specification
language
constructs
proper
understanding
thus
necessary
furthermore
heuristics
may
developed
time
will
enable
easier
interchange
architectures
modeled
adls
focus
particular
architectural
domains
finally
framework
can
used
guide
developing
future
adls
figure
1
architectural
domains
3
1
representation
key
role
explicit
representation
architecture
aid
understanding
communication
software
system
among
different
stakeholders
reason
important
architectural
descriptions
simple
understandable
possibly
graphical
well
understood
necessarily
formally
defined
semantics
architectural
models
typically
comprise
multiple
views
high
level
graphical
view
lower
level
view
formal
specifications
components
connectors
conceptual
architecture
one
implementation
architectures
corresponding
development
process
data
control
flow
view
different
stakeholders
architects
developers
managers
customers
may
require
different
views
architecture
customers
may
satisfied
high
level
boxes
arrows
description
developers
may
want
detailed
component
connector
models
managers
may
require
view
development
process
3
2
design
process
support
software
architects
decompose
large
distributed
heterogeneous
systems
smaller
building
blocks
consider
many
issues
make
many
decisions
utilize
many
design
techniques
methodologies
tools
modeling
architectures
multiple
perspectives
discussed
previous
subsection
one
way
supporting
software
architects'
cognitive
processes
others
include
delivering
design
guidance
timely
understandable
fashion
capturing
design
rationale
revisiting
past
design
steps
3
3
analysis
architectures
often
intended
model
large
distributed
concurrent
systems
ability
evaluate
properties
systems
upstream
architectural
level
can
substantially
lessen
number
errors
passed
downstream
given
unnecessary
details
abstracted
away
architectures
analysis
task
may
also
easier
perform
source
code
level
analysis
architectures
may
performed
statically
execution
dynamically
runtime
certain
types
analysis
can
performed
statically
dynamically
3
3
1
static
analysis
examples
static
analysis
internal
consistency
checks
whether
appropriate
components
connected
interfaces
match
whether
connectors
enable
desired
communication
whether
constraints
satisfied
whether
combined
semantics
components
connectors
result
desired
system
behavior
certain
concurrent
distributed
aspects
architecture
can
also
assessed
statically
potential
deadlocks
starvation
performance
reliability
security
finally
architectures
can
statically
analyzed
adherence
design
heuristics
style
rules
3
3
2
dynamic
analysis
examples
dynamic
analysis
testing
debugging
assertion
checking
assessment
performance
reliability
schedulability
executing
architecture
saying
architecture
executing
can
mean
two
different
things
system
built
based
architecture
executing
runtime
behavior
architecture
simulated
clearly
certain
analyses
performance
reliability
meaningful
even
possible
former
case
however
implementation
system
may
yet
exist
furthermore
may
substantially
less
expensive
perform
dynamic
analyses
latter
case
particularly
relationship
architecture
implemented
system
well
understood
3
4
evolution
support
software
evolution
key
aspect
architecture
based
development
architectures
evolve
reflect
evolution
single
software
system
also
evolve
families
related
systems
design
elements
individual
components
connectors
within
architecture
may
also
evolve
evolution
components
connectors
architectures
can
occur
specification
time
execution
time
3
4
1
specification
time
evolution
consider
components
connectors
types
instantiated
every
time
used
architecture
evolution
can
viewed
simply
terms
subtyping
since
components
connectors
modeled
high
level
abstraction
flexible
subtyping
methods
may
employed
example
may
useful
evolve
single
component
multiple
ways
using
different
subtyping
mechanisms
interface
behavior
combination
two
mort96
level
architectures
evolution
focused
incremental
development
support
system
families
incrementality
architecture
can
viewed
two
different
perspectives
one
ability
accommodate
addition
new
components
resulting
issues
scale
specification
incomplete
architectures
3
4
2
execution
time
evolution
explicit
modeling
architectures
intended
support
development
evolution
large
potentially
long
running
systems
able
evolve
systems
execution
may
thus
desirable
cases
necessary
architectures
exhibit
dynamism
allowing
replication
insertion
removal
reconnection
architectural
elements
subarchitectures
execution
dynamic
changes
architecture
may
either
planned
architecture
specification
time
unplanned
types
dynamic
change
must
constrained
ensure
desired
architectural
properties
violated
3
5
refinement
common
argument
creating
using
formal
architectural
models
necessary
bridge
gap
informal
boxes
arrows
diagrams
programming
languages
deemed
low
level
designing
system
architectural
models
may
need
specified
several
levels
abstraction
different
purposes
example
high
level
specification
architecture
can
used
understanding
communication
tool
subsequent
lower
level
may
analyzed
consistency
interconnections
even
lower
level
may
used
simulation
therefore
correct
consistent
refinement
architectures
subsequently
lower
levels
abstraction
imperative
note
sense
code
generation
simply
special
case
architectural
refinement
3
6
traceability
discussed
software
architecture
often
consists
multiple
views
may
modeled
multiple
levels
abstraction
figure
2
call
particular
view
architecture
given
level
abstraction
single
point
two
dimensional
space
figure
2
architectural
cross
section
critical
changes
one
cross
section
correctly
reflected
others
particular
architectural
cross
section
can
considered
dominant
changes
architecture
made
reflected
others
however
changes
will
frequently
made
appropriate
convenient
cross
section
traceability
support
will
hence
need
exist
across
pertinent
cross
sections
one
final
issue
consistency
architecture
system
requirements
changes
requirements
must
appropriately
reflected
architecture
changes
architecture
must
validated
requirements
therefore
even
though
system
requirements
problem
domain
architecture
solution
domain
traceability
two
crucial
purposes
traceability
requirements
can
considered
high
level
architectural
abstraction
shown
figure
2
figure
2
two
dimensional
space
architectural
views
levels
abstraction
vertical
axis
set
discrete
values
nominal
ordering
horizontal
axis
continuum
ordinal
ordering
values
system
requirements
considered
highest
level
abstraction
source
code
lowest
one
possible
dominant
cross
section
graphical
view
high
level
architecture
shown
3
7
simulation
executability
static
architectural
models
useful
establishing
static
properties
modeled
system
certain
dynamic
properties
may
also
predicted
static
models
specific
assumptions
hold
example
architect
can
correctly
predict
execution
time
criticality
component
schedulability
encompassing
architecture
can
evaluated
hand
dynamic
properties
reliability
may
definition
require
running
system
also
developers
may
want
produce
early
prototype
attempt
allocation
architectural
elements
components
physical
system
stakeholders
customers
managers
may
want
verify
early
architecture
conforms
wishes
simulating
dynamic
behavior
high
level
architecture
may
thus
preferred
implementing
system
quicker
cheaper
flexible
way
arriving
desired
information
special
case
architectural
simulation
execution
complete
implemented
system
ultimate
goal
software
design
modeling
endeavor
produce
system
elegant
effective
architectural
model
limited
value
unless
can
converted
running
application
simulation
can
partially
depict
final
system's
dynamic
behavior
manually
transforming
architecture
running
system
may
result
many
already
discussed
problems
consistency
traceability
architecture
implementation
techniques
refinement
traceability
discussed
must
employed
properly
accomplish
task
4
adl
support
architectural
domains
previous
section
motivated
described
different
architectural
domains
terms
characteristics
needs
software
architectures
another
way
viewing
architectural
domains
terms
modeling
languages
specific
language
features
needed
support
different
domains
time
useful
way
understanding
classifying
architecture
modeling
languages
terms
architectural
domains
intended
support
reasons
section
studies
kinds
language
facilities
needed
support
architectural
domain
well
specific
features
existing
adls
employ
end
hope
discussion
will
shed
light
relationships
among
different
architectural
domains
resulting
adl
features
point
can
effectively
combined
can
expect
difficulties
4
1
representation
ideally
adl
make
structure
system
clear
configuration
specification
alone
without
study
component
connector
specifications
architecture
descriptions
line
configuration
adls
darwin
metah
rapide
tend
encumbered
connector
details
explicit
configuration
adls
acme
aesop
c2
sadl
unicon
wright
best
potential
facilitate
understandability
architectural
structure
one
common
way
facilitating
understandability
communication
providing
graphical
notation
addition
textual
notation
however
case
precise
relationship
graphical
description
underlying
semantic
model
example
aesop
c2
darwin
metah
rapide
unicon
support
semantically
sound
graphical
notations
acme
sadl
wright
adls
must
also
able
model
architecture
multiple
perspectives
discussed
several
adls
support
least
two
views
architecture
textual
graphical
adls
also
allows
top
level
detailed
views
composite
elements
aesop
metah
unicon
distinguish
different
types
components
connectors
iconically
support
views
sparse
c2
provides
view
development
process
corresponds
architecture
rr96
darwin's
software
architect's
assistant
nkm96
provides
hierarchical
view
architecture
shows
component
types
include
relationships
among
tree
structure
rapide
allows
visualization
architecture's
execution
behavior
building
simulation
animating
execution
rapide
also
provides
tool
viewing
filtering
events
generated
simulation
4
2
design
process
support
examples
c2's
darwin's
rapide's
support
tools
indicate
language
features
can
go
far
supporting
software
architects
adequate
tools
also
needed
category
tools
critical
adequately
supporting
design
process
active
specification
tools
can
significantly
reduce
cognitive
load
architects
handful
existing
adls
provide
tools
actively
support
specification
architectures
general
tools
can
proactive
reactive
unicon's
graphical
editor
proactive
invokes
unicon's
language
processing
facilities
prevent
errors
design
reactive
specification
tools
detect
existing
errors
may
either
inform
architect
error
non
intrusive
also
force
architect
correct
moving
intrusive
example
former
c2's
design
environment
argo
metah's
graphical
editor
example
latter
4
3
analysis
types
analyses
adl
well
suited
depend
underlying
semantic
model
lesser
extent
specification
features
semantic
model
will
largely
influence
whether
adl
can
analyzed
statically
dynamically
example
wright
based
communicating
sequential
processes
csp
hoa85
allows
static
deadlock
analysis
individual
connectors
components
attached
hand
rapide
architectures
modeled
partially
ordered
event
sets
posets
lvb
93
can
analyzed
dynamically
4
3
1
static
analysis
common
type
static
analysis
tools
language
parsers
compilers
parsers
analyze
architectures
syntactic
correctness
compilers
establish
semantic
correctness
existing
adls
parsers
darwin
metah
rapide
unicon
also
compilers
enable
languages
generate
executable
systems
architectural
descriptions
wright
compiler
uses
fdr
for92
model
checker
establish
type
conformance
numerous
possible
types
static
analysis
architectures
several
examples
provided
current
adls
aesop
provides
facilities
checking
type
consistency
cycles
resource
conflicts
scheduling
feasibility
architectures
c2
uses
critics
establish
adherence
style
rules
design
guidelines
metah
unicon
currently
support
schedulability
analysis
specifying
non
functional
properties
criticality
priority
finally
given
two
architectures
sadl
can
establish
relative
correctness
respect
refinement
map
4
3
2
dynamic
analysis
ability
analyze
architecture
dynamically
directly
depends
adl's
ability
model
dynamic
behavior
end
adls
can
employ
specification
mechanisms
event
posets
cham
temporal
logic
can
express
dynamic
properties
system
another
aspect
dynamic
analysis
enforcement
constraints
runtime
existing
adls
tend
view
architectures
statically
current
support
dynamic
modeling
analysis
scarce
darwin
enables
dynamic
analysis
architectures
instantiating
parameters
components
enact
scenarios
similarly
rapide
poset
browser's
event
filtering
features
animation
tools
facilitate
analysis
architectures
simulation
rapide's
constraint
checker
also
analyzes
conformance
rapide
simulation
formal
constraints
defined
architecture
finally
runtime
systems
adls
provide
architecture
compilation
support
can
viewed
dynamic
analysis
facilities
4
4
evolution
architecture
can
evolve
two
different
dimensions
evolution
individual
components
connectors
structure
architecture
affected
although
behavior
may
evolution
entire
architecture
affects
structure
behavior
architecture
evolution
two
dimensions
can
occur
architecture
specification
time
architecture
executing
footnote
3
4
4
1
specification
time
evolution
adls
can
support
specification
time
evolution
individual
components
connectors
subtyping
subset
existing
adls
provide
facilities
even
evolution
support
limited
often
relies
chosen
implementation
programming
language
remainder
adls
view
model
components
connectors
inherently
static
aesop
supports
behavior
preserving
subtyping
components
connectors
create
substyles
given
architectural
style
rapide
allows
interface
types
inherit
types
using
oo
methods
resulting
structural
subtyping
acme
also
supports
structural
subtyping
via
extends
feature
c2
provides
sophisticated
subtyping
type
checking
mechanism
multiple
subtyping
relationships
among
components
allowed
name
interface
behavior
implementation
subtyping
well
combinations
mort96
specification
time
evolution
complete
architectures
two
facets
support
incremental
development
support
system
families
incrementality
architecture
can
viewed
two
different
perspectives
one
ability
accommodate
addition
new
components
architecture
general
explicit
configuration
adls
can
support
incremental
development
easily
effectively
line
configuration
adls
adls
allow
variable
numbers
components
communicate
connector
well
suited
incremental
development
particularly
faced
unplanned
architectural
changes
med97
another
view
incrementality
adl's
support
incomplete
architectural
descriptions
incomplete
architectures
common
design
decisions
deferred
others
yet
become
relevant
however
existing
adls
supporting
toolsets
built
prevent
precisely
kinds
situations
example
darwin
metah
rapide
unicon
compilers
constraint
checkers
runtime
systems
constructed
raise
exceptions
situations
arise
case
adl
wright
focuses
analyses
information
local
single
connector
better
suited
accommodate
expansion
architecture
sadl
rigorous
refinement
entire
architectures
still
another
aspect
static
evolution
support
application
families
mt96
showed
number
possible
architectures
component
based
style
grows
exponentially
result
linear
expansion
collection
components
architectures
may
belong
logical
family
therefore
relying
component
connector
inheritance
subtyping
evolution
mechanisms
insufficient
obvious
solution
currently
adopted
acme
provide
language
construct
allows
architect
specify
family
given
architecture
belongs
4
4
2
execution
time
evolution
presently
two
approaches
supporting
evolution
architectures
execution
time
first
oreizy
calls
constrained
dynamism
runtime
changes
architecture
must
known
priori
specified
part
architectural
model
ore96
two
existing
adls
support
constrained
dynamism
rapide
supports
conditional
configuration
clause
enables
form
architectural
rewiring
runtime
using
link
unlink
operators
darwin
allows
runtime
replication
components
using
dyn
operator
second
approach
execution
time
evolution
places
restrictions
architecture
specification
time
kinds
allowed
changes
instead
adl
architecture
modification
feature
allows
architect
specify
changes
architecture
running
darwin
c2
adls
support
pure
dynamism
ore96
darwin
allows
deletion
rebinding
components
interpreting
darwin
scripts
c2
specifies
set
operations
insertion
removal
rewiring
elements
architecture
runtime
med96
c2's
archshell
tool
enables
arbitrary
interactive
construction
execution
runtime
modification
c2
style
architectures
dynamically
loading
linking
new
architectural
elements
ore96
mot97
issue
needs
exploration
constraining
pure
dynamic
evolution
ensure
desired
properties
architectures
maintained
4
5
refinement
adls
provide
architects
expressive
semantically
elaborate
facilities
specification
architectures
however
adl
must
also
enable
correct
consistent
refinement
architectures
subsequently
lower
levels
abstraction
eventually
executable
systems
obvious
way
adls
can
support
refinement
providing
patterns
maps
applied
architecture
result
related
architecture
lower
level
abstraction
sadl
rapide
two
adls
provide
support
sadl
uses
maps
enable
correct
architecture
refinements
across
styles
rapide
generates
comparative
simulations
architectures
different
abstraction
levels
approaches
certain
drawbacks
indicating
hybrid
approach
may
useful
garlan
recently
argued
refinement
consistent
respect
single
immutable
law
rather
respect
particular
properties
interest
conservative
extension
sadl
computational
behavior
rapide
something
entirely
different
performance
gar96
may
good
starting
point
towards
successful
marriage
two
approaches
several
adls
take
different
approach
refinement
enable
generation
executable
systems
directly
architectural
specifications
typically
implementation
constraining
languages
metah
unicon
adls
assume
existence
source
file
corresponds
given
architectural
element
approach
makes
assumption
relationship
elements
architectural
description
resulting
system
will
1
1
given
architectures
intended
describe
systems
higher
level
abstraction
source
code
modules
can
considered
limited
form
refinement
4
6
traceability
problem
refinement
essentially
focuses
one
axis
figure
2
horizontal
axis
one
direction
left
right
traceability
may
need
cover
large
portion
two
dimensional
space
applicable
directions
presents
much
difficult
task
indicating
architectural
domain
existing
adls
lacking
relationships
among
architectural
views
vertical
axis
always
well
understood
example
adls
commonly
provide
support
tracing
changes
textual
graphical
views
changes
one
view
automatically
reflected
however
may
less
clear
data
flow
view
affect
process
view
cases
changes
one
view
process
never
affect
another
control
flow
even
bigger
hurdle
providing
traceability
support
across
architectural
views
levels
abstraction
simultaneously
finally
although
much
research
directed
methodologies
making
transition
requirements
design
oo
process
still
art
form
research
especially
needed
understand
effects
changing
requirements
architectures
vice
versa
traceability
particularly
problem
way
implementation
constraining
languages
approach
code
generation
discussed
previous
subsection
adls
provide
means
guaranteeing
source
modules
supposed
implement
architectural
components
will
correctly
furthermore
even
specified
modules
currently
implement
needed
behavior
correctly
guarantee
future
changes
modules
will
traced
back
architecture
vice
versa
4
7
simulation
executability
dynamic
analysis
section
4
3
2
simulating
architecture
will
directly
depend
upon
adl's
ability
model
dynamic
behavior
currently
rapide
adl
can
simulate
architecture
generating
event
posets
adls
enable
generation
running
systems
corresponding
architecture
metah
unicon
require
preexisting
component
implementations
ada
respectively
order
generate
applications
darwin
can
also
construct
executable
systems
manner
rapide
ada
vhdl
executable
sublanguage
c2
aesop
provide
class
hierarchies
concepts
operations
components
connectors
interconnection
message
passing
protocols
hierarchies
form
basis
implementation
architecture
may
produced
aesop's
hierarchy
implemented
c2's
java
ada
4
8
summary
existing
adls
span
broad
spectrum
terms
architectural
domains
support
one
hand
languages
like
sadl
wright
specific
narrow
foci
c2
rapide
darwin
support
number
architectural
domains
certain
domains
evolution
refinement
traceability
sparsely
supported
indicating
areas
around
future
work
centered
complete
summary
section
given
table
1
table
1
adl
support
architectural
domains
arch
domain
adl
represent
design
process
support
static
analysis
dynamic
analysis
spec
time
evolution
exec
time
evolution
refinement
trace
simulation
executability
acme
explicit
config
weblets
noneparsernoneapplication
familiesnonerep
maps
across
levels
textual
graphical
none
aesop
explicit
config
graphical
notation
types
distinguished
iconicallysyntax
directed
editor
specialized
editors
visualization
classesparser
style
specific
compiler
type
cycle
resource
conflict
scheduling
feasibility
checkernonebehavior
preserving
subtyping
components
connectorsnonenone
textual
graphical
build
tool
constructs
system
glue
code
pipe
filter
style
c2
explicit
config
graphical
notation
process
view
simulation
event
filteringnon
intrusive
reactive
design
critics
lists
argoparser
critics
establish
adherence
style
rules
design
heuristicsevent
filteringmultiple
subtyping
mechanisms
allows
partial
architecturespure
dynamism
element
insertion
removal
rewiringnone
textual
graphical
class
framework
enables
generation
ada
java
code
darwin
implicit
config
graphical
notation
hierarchical
system
viewautomated
addition
ports
propagation
changes
across
bound
ports
property
dialogsparser
compiler
scenarios
instantiating
parameters
dynamic
componentsnoneconstrained
dynamism
runtime
replication
components
conditional
configurationnone
textual
graphical
compiler
generates
code
metah
implicit
config
graphical
notation
types
distinguished
iconicallyintrusive
reactive
graphical
editorparser
compiler
schedulability
reliability
security
analysisnonenonenonenone
textual
graphical
compiler
generates
ada
code
code
generation
planned
rapide
implicit
config
graphical
notation
animated
simulation
event
filteringnoneparser
compiler
constraint
checker
ensure
valid
mappingsevent
filtering
animationinheritance
structural
subtyping
constrained
dynamism
conditional
configuration
dynamic
event
generationrefinement
maps
enable
comparative
simulations
architectures
different
levels
textual
graphical
constraint
checking
across
refinement
levelssimulation
generating
event
posets
system
construction
ada
vhdl
rapide
sadl
explicit
config
noneparser
relative
correctness
architectures
refinement
mapnonecomponent
connector
refinement
via
pattern
mapsnonemaps
enable
correct
refinements
across
levelsrefinement
across
levelsnone
unicon
explicit
config
graphical
notationproactive
gui
editor
invokes
language
checkerparser
compiler
schedulability
analysisnonenonenonenone
textual
graphical
compiler
generates
code
wright
explicit
config
noneparser
model
checker
type
conformance
deadlock
analysis
connectorsnonetype
conformance
behaviorally
related
protocolsnonenonenonenone
5
architectural
vs
application
domains
past
decade
interest
relating
architectures
solution
domain
problem
application
domain
leading
notion
domain
specific
software
architectures
dssas
tra95
dssa
provides
single
generic
reference
architecture
reflects
characteristics
particular
problem
domain
instantiated
specific
application
domain
architectural
styles
discussed
section
2
provide
another
way
relating
problem
solution
spaces
styles
largely
orthogonal
dssas
single
style
may
applicable
multiple
application
domains
hand
single
dssa
may
use
multiple
styles
attempt
explore
perhaps
generalize
relationship
architectural
application
domains
greatly
aided
classification
application
domains
unaware
classification
although
jackson
identified
number
domain
characteristics
serve
starting
point
one
jac95
static
vs
dynamic
domains
latter
application
domains
element
time
events
state
one
dimensional
vs
multi
dimensional
domains
tangible
vs
intangible
domains
latter
typically
involving
machine
representations
abstractions
user
interfaces
inert
vs
reactive
vs
active
dynamic
domains
autonomous
vs
programmable
vs
biddable
active
dynamic
domains
given
application
domain
characteristics
one
can
easily
identify
number
useful
relationships
architectural
domains
instance
support
evolution
executability
dynamic
analysis
important
dynamic
domains
static
domains
another
example
reactive
domains
naturally
supported
style
representation
statecharts
har87
different
active
domains
cham
iw95
deepen
understanding
architectural
domains
will
able
solidify
understanding
relationship
application
domains
6
conclusions
software
architecture
research
moving
forward
rapidly
number
adls
supporting
toolsets
developed
many
existing
styles
adopted
new
ones
invented
theoretical
underpinnings
study
software
architectures
also
begun
emerge
form
definitions
pw92
gs93
formal
classifications
styles
sc96
adls
med97
mt97
body
work
reflects
wide
spectrum
views
architecture
aspects
modeled
relationship
software
development
concepts
artifacts
divergence
views
also
resulted
divergence
adls'
conceptual
frameworks
defined
section
2
fragmentation
made
difficult
establish
whether
exists
adls
notion
similar
computational
equivalence
programming
languages
furthermore
sharing
support
tools
difficult
acme
attempted
provide
basis
interchanging
architectural
descriptions
across
adls
however
acme
thus
far
much
successful
achieving
architectural
interchange
syntactic
structural
level
semantic
level
although
acme
team's
recent
work
looks
encouraging
still
remains
open
problem
one
reasons
acme
encountered
difficulties
precisely
fact
limited
agreement
architecture
community
fundamental
issues
critical
problems
architectures
attempt
solve
paper
presents
important
first
step
towards
solution
problem
recognized
field
software
architecture
concerned
several
domains
every
adl
reflects
properties
one
domains
set
architectural
domains
thus
provide
unifying
view
seemed
like
disparate
collection
approaches
notations
techniques
tools
task
architectural
interchange
can
greatly
aided
studying
interrelationships
among
architectural
domains
existing
adls
can
better
understood
new
light
new
adls
easily
developed
solve
specific
set
problems
much
work
still
needed
however
current
understanding
relationship
architectural
domains
formal
semantic
theories
section
2
limited
also
need
examine
whether
exist
techniques
can
effectively
support
needs
particular
architectural
domains
provided
existing
adls
finally
thorough
understanding
relationship
architectural
application
domains
crucial
architecture
based
development
fulfill
potential
7
acknowledgements
like
thank
richard
taylor
peyman
oreizy
jason
robbins
david
redmiles
david
hilbert
participation
numerous
discussions
issues
concerning
adls
also
thank
dsl
reviewers
helpful
reviews
effort
partially
sponsored
defense
advanced
research
projects
agency
rome
laboratory
air
force
materiel
command
usaf
agreement
numbers
f30602
94
0218
f30602
97
2
0021
government
authorized
reproduce
distribute
reprints
governmental
purposes
notwithstanding
copyright
annotation
thereon
approved
public
release
distribution
unlimited
views
conclusions
contained
herein
authors
interpreted
necessarily
representing
official
policies
endorsements
either
expressed
implied
defense
advanced
research
projects
agency
rome
laboratory
government
material
also
partially
based
work
supported
national
science
foundation
grant
ccr
9701973
8
references
ag94a
allen
garlan
formal
connectors
technical
report
cmu
cs
94
115
carnegie
mellon
university
march
1994
ag94b
allen
garlan
formalizing
architectural
connection
proceedings
sixteenth
international
conference
software
engineering
pages
71
80
sorrento
italy
may
1994
all96
allen
hla
standards
effort
architectural
style
wolf
ed
proceedings
second
international
software
architecture
workshop
isaw
2
pages
130
133
san
francisco
ca
october
1996
br95
booch
rumbaugh
unified
method
object
oriented
development
rational
software
corporation
1995
dk76
deremer
kron
programming
large
versus
programming
small
ieee
transactions
software
engineering
pages
80
86
june
1976
for92
failures
divergence
refinement
user
manual
tutorial
formal
systems
europe
ltd
oxford
england
october
1992
gao94
garlan
allen
ockerbloom
exploiting
style
architectural
design
environments
proceedings
sigsoft'94
foundations
software
engineering
pages
175
188
new
orleans
louisiana
usa
december
1994
gar95
garlan
editor
proceedings
first
international
workshop
architectures
software
systems
seattle
wa
april
1995
gar96
garlan
style
based
refinement
software
architecture
wolf
ed
proceedings
second
international
software
architecture
workshop
isaw
2
pages
72
75
san
francisco
ca
october
1996
gmw95
garlan
monroe
wile
acme
architectural
interconnection
language
technical
report
cmu
cs
95
219
carnegie
mellon
university
november
1995
gmw97
garlan
monroe
wile
acme
architecture
interchange
language
submitted
publication
january
1997
gpt95
garlan
paulisch
tichy
editors
summary
dagstuhl
workshop
software
architecture
february
1995
reprinted
acm
software
engineering
notes
pages
63
83
july
1995
gs93
garlan
shaw
introduction
software
architecture
advances
software
engineering
knowledge
engineering
volume
world
scientific
publishing
1993
gw88
goguen
winkler
introducing
obj3
technical
report
sri
csl
88
99
sri
international
1988
har87
harel
statecharts
visual
formalism
complex
systems
science
computer
programming
1987
hoa85
hoare
communicating
sequential
processes
prentice
hall
1985
iw95
inverardi
wolf
formal
specification
analysis
software
architectures
using
chemical
abstract
machine
model
ieee
transactions
software
engineering
pages
373
386
april
1995
jac95
jackson
software
requirements
specifications
lexicon
practice
principles
prejudices
addison
wesley
1995
lka
95
luckham
kenney
augustin
vera
bryan
mann
specification
analysis
system
architecture
using
rapide
ieee
transactions
software
engineering
pages
336
355
april
1995
luc87
luckham
anna
language
annotating
ada
programs
reference
manual
volume
260
lecture
notes
computer
science
springer
verlag
berlin
1987
lv95
luckham
vera
event
based
architecture
definition
language
ieee
transactions
software
engineering
pages
717
734
september
1995
lvb
93
luckham
vera
bryan
augustin
belz
partial
orderings
event
sets
application
prototyping
concurrent
timed
systems
journal
systems
software
pages
253
265
june
1993
lvm95
luckham
vera
meldal
three
concepts
system
architecture
unpublished
manuscript
july
1995
med96
medvidovic
adls
dynamic
architecture
changes
wolf
ed
proceedings
second
international
software
architecture
workshop
isaw
2
pages
24
27
san
francisco
ca
october
1996
med97
medvidovic
classification
comparison
framework
software
architecture
description
languages
technical
report
uci
ics
97
02
university
california
irvine
january
1997
mdek95
magee
dulay
eisenbach
kramer
specifying
distributed
software
architectures
proceedings
fifth
european
software
engineering
conference
esec'95
barcelona
september
1995
mk96
magee
kramer
dynamic
structure
software
architectures
proceedings
acm
sigsoft'96
fourth
symposium
foundations
software
engineering
fse4
pages
3
14
san
francisco
ca
october
1996
mot97
medvidovic
oreizy
taylor
reuse
shelf
components
c2
style
architectures
proceedings
1997
symposium
software
reusability
ssr'97
pages
190
198
boston
ma
may
17
19
1997
also
proceedings
1997
international
conference
software
engineering
icse'97
pages
692
700
boston
ma
may
17
23
1997
mort96
medvidovic
oreizy
robbins
taylor
using
object
oriented
typing
support
architectural
design
c2
style
proceedings
acm
sigsoft'96
fourth
symposium
foundations
software
engineering
fse4
pages
24
32
san
francisco
ca
october
1996
mqr95
moriconi
qian
riemenschneider
correct
architecture
refinement
ieee
transactions
software
engineering
pages
356
372
april
1995
mt96
medvidovic
taylor
reusing
shelf
components
develop
family
applications
c2
architectural
style
proceedings
international
workshop
development
evolution
software
architectures
product
families
las
navas
del
marqu
vila
spain
november
1996
mt97
medvidovic
taylor
framework
classifying
comparing
architecture
description
languages
appear
proceedings
sixth
european
software
engineering
conference
together
fifth
acm
sigsoft
symposium
foundations
software
engineering
zurich
switzerland
september
22
25
1997
mtw96
medvidovic
taylor
whitehead
jr
formal
modeling
software
architectures
multiple
levels
abstraction
proceedings
california
software
symposium
1996
pages
28
40
los
angeles
ca
april
1996
nkm96
ng
kramer
magee
case
tool
software
architecture
design
journal
automated
software
engineering
jase
special
issue
case
95
1996
ore96
oreizy
issues
runtime
modification
software
architectures
technical
report
uci
ics
96
35
university
california
irvine
august
1996
pet62
petri
kommunikationen
mit
automaten
phd
thesis
university
bonn
1962
english
translation
technical
report
radc
tr
65
377
vol
1
suppl
1
applied
data
research
princeton
pn86
prieto
diaz
neighbors
module
interconnection
languages
journal
systems
software
pages
307
334
october
1989
pw92
perry
wolf
foundations
study
software
architectures
acm
sigsoft
software
engineering
notes
pages
40
52
october
1992
rmrr97
robbins
medvidovic
redmiles
rosenblum
integrating
architecture
description
languages
standard
design
method
technical
report
uci
ics
97
35
university
california
irvine
august
1997
rr96
robbins
redmiles
software
architecture
design
perspective
human
cognitive
needs
proceedings
california
software
symposium
css'96
los
angeles
ca
usa
april
1996
sc96
shaw
clements
toward
boxology
preliminary
classification
architectural
styles
wolf
ed
proceedings
second
international
software
architecture
workshop
isaw
2
pages
50
54
san
francisco
ca
october
1996
sdk
95
shaw
deline
klein
ross
young
zelesnik
abstractions
software
architecture
tools
support
ieee
transactions
software
engineering
pages
314
335
april
1995
sg94
shaw
garlan
characteristics
higher
level
languages
software
architecture
technical
report
cmu
cs
94
210
carnegie
mellon
university
december
1994
spi89
spivey
notation
reference
manual
prentice
hall
new
york
1989
tlpd95
terry
london
papanagopoulos
devito
ardec
teknowledge
architecture
description
language
artek
version
4
0
technical
report
teknowledge
federal
systems
inc
army
armament
research
development
engineering
center
july
1995
tra95
tracz
dssa
domain
specific
software
architecture
pedagogical
example
acm
sigsoft
software
engineering
notes
july
1995
ves93
vestal
cursory
overview
comparison
four
architecture
description
languages
technical
report
honeywell
technology
center
february
1993
ves96
vestal
metah
programmer's
manual
version
1
09
technical
report
honeywell
technology
center
april
1996
wolf96
wolf
editor
proceedings
second
international
software
architecture
workshop
isaw
2
san
francisco
ca
october
1996
footnotes
footnote
1
section
condensed
detailed
exposition
adls
given
med97
mt97
provided
definition
adls
devised
classification
comparison
framework
footnote
2
one
can
think
syntactic
features
equivalent
boxes
arrows
graphical
notation
little
underlying
semantics
footnote
3
saying
architecture
executing
can
mean
either
architecture
simulated
executable
system
built
based
architecture
running
