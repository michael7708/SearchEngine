bfs dfs 
breadth first search depth first search 
ics
161
design
analysis
algorithms
lecture
notes
february
15
1996
breadth
first
search
depth
first
search
traversal
graphs
digraphs
traverse
means
visit
vertices
systematic
order
familiar
various
traversal
methods
trees
preorder
visit
node
children
postorder
visit
node
children
inorder
binary
trees
visit
left
subtree
node
right
subtree
also
saw
another
kind
traversal
topological
ordering
talked
shortest
paths
today
see
two
traversals
breadth
first
search
bfs
depth
first
search
dfs
construct
spanning
trees
certain
properties
useful
graph
algorithms
start
describing
undirected
graphs
also
useful
directed
graphs
breadth
first
search
can
throught
like
dijkstra's
algorithm
shortest
paths
every
edge
length
however
lot
simpler
need
data
structures
just
keep
tree
breadth
first
search
tree
list
nodes
added
tree
markings
boolean
variables
vertices
tell
whether
tree
list
breadth
first
search
unmark
vertices
choose
starting
vertex
mark
list
tree
nonempty
choose
vertex
front
list
visit
unmarked
neighbor
mark
add
end
list
add
edge
vw
important
remove
vertices
end
list
one
add
list
acts
queue
fifo
storage
rather
stack
lifo
visit
step
filled
later
depending
using
bfs
just
like
tree
traversals
usually
involve
something
vertex
specified
part
basic
algorithm
vertex
several
unmarked
neighbors
equally
correct
visit
order
probably
easiest
method
implement
simply
visit
order
adjacency
list
stored
prove
basic
facts
algorithm
first
vertex
clearly
marked
added
list
since
happens
marked
therefore
removed
list
since
time
process
vertex
proportional
length
adjacency
list
total
time
whole
algorithm
next
look
tree
constructed
algorithm
tree
think
edge
vw
pointing
upward
edge
points
vertex
visited
later
one
visited
earlier
following
successive
edges
upwards
can
get
stopped
edge
going
upward
every
vertex
path
means
least
connected
subgraph
now
prove
tree
tree
just
connected
acyclic
graph
need
show
cycles
cycle
matter
orient
edges
one
direction
upward
downward
always
bottom
vertex
two
upward
edges
vertex
one
upward
edge
can
cycles
therefore
really
tree
known
breadth
first
search
tree
also
want
know
spanning
tree
graph
connected
every
vertex
path
root
every
vertex
will
occur
somewhere
can
prove
induction
length
shortest
path
path
length
starting
path
length
1
induction
included
visited
seen
edge
vw
already
tree
added
breadth
first
traversal
corresponds
kind
tree
traversal
preorder
postorder
even
inorder
traversal
instead
traversal
goes
level
time
left
right
within
level
level
defined
simply
terms
distance
root
tree
instance
following
tree
drawn
vertices
numbered
order
might
followed
breadth
first
search
1
2
3
4
5
6
7
8
9
10
11
proof
vertices
order
breadth
first
search
goes
induction
level
number
induction
hypothesis
bfs
lists
vertices
level
1
level
therefore
will
place
vertices
level
level
1
therefore
list
level
level
1
really
proof
even
though
sounds
like
circular
reasoning
breadth
first
search
trees
nice
property
every
edge
can
classified
one
three
groups
edges
connect
two
vertices
level
remaining
ones
connect
two
vertices
two
adjacent
levels
possible
edge
skip
level
therefore
breadth
first
search
tree
really
shortest
path
tree
starting
root
every
vertex
path
root
path
length
equal
level
just
follow
tree
path
can
skip
level
really
shortest
path
breadth
first
search
several
uses
graph
algorithms
complicated
explain
detail
one
part
algorithm
matching
problem
want
pair
vertices
graph
2
edges
partial
matching
pairing
vertices
can
extend
finding
alternating
path
connecting
two
unmatched
vertices
path
every
edge
part
partial
matching
remove
edges
path
matching
add
path
edges
back
matching
get
matching
one
edge
alternating
paths
can
found
using
version
breadth
first
search
second
use
breadth
first
search
arises
certain
pattern
matching
problems
instance
looking
small
subgraph
triangle
part
larger
graph
know
every
vertex
triangle
connected
edge
every
vertex
since
edge
can
skip
levels
bfs
tree
can
divide
problem
subproblems
look
triangle
pairs
adjacent
levels
tree
sort
problem
look
small
graph
part
larger
one
known
subgraph
isomorphism
recent
paper
used
idea
solve
many
similar
pattern
matching
problems
linear
time
depth
first
search
depth
first
search
another
way
traversing
graphs
closely
related
preorder
traversal
tree
recall
preorder
traversal
simply
visits
node
children
easy
program
recursive
routine
preorder
node
visit
child
preorder
turn
graph
traversal
algorithm
basically
replace
child
neighbor
prevent
infinite
loops
want
visit
vertex
just
like
bfs
can
use
marks
keep
track
vertices
already
visited
visit
also
just
like
bfs
can
use
search
build
spanning
tree
certain
useful
properties
dfs
vertex
visit
neighbor
unvisited
dfs
add
edge
vw
tree
overall
depth
first
search
algorithm
simply
initializes
set
markers
can
tell
vertices
visited
chooses
starting
vertex
initializes
tree
calls
dfs
just
like
breadth
first
search
vertex
several
neighbors
equally
correct
go
order
simply
say
unvisited
neighbor
important
delay
test
whether
vertex
visited
recursive
calls
previous
neighbors
finished
proof
produces
spanning
tree
depth
first
search
tree
essentially
bfs
repeat
however
bfs
tree
typically
short
bushy
dfs
tree
typically
long
stringy
just
like
bfs
can
use
dfs
classify
edges
types
either
edge
vw
dfs
tree
ancestor
ancestor
last
two
cases
thought
single
type
since
differ
order
look
vertices
means
different
subtrees
edge
edge
existed
say
visited
first
way
avoid
adding
vw
dfs
tree
visited
one
recursive
calls
ancestor
example
property
might
useful
prove
following
fact
graph
either
path
length
least
kn
edges
proof
look
longest
path
dfs
tree
length
least
done
otherwise
since
edge
connects
ancestor
descendant
can
bound
number
edges
counting
total
number
ancestors
descendant
longest
path
shorter
descendant
1
ancestors
can
1
edges
fact
can
used
part
algorithm
finding
long
paths
another
subgraph
isomorphism
problem
closely
related
traveling
salesman
problem
small
constant
like
say
5
can
find
paths
length
linear
time
measured
function
measured
function
time
exponential
surprising
problem
closely
related
traveling
salesman
problem
particular
problem
see
michael
fellows
michael
langston
search
decision
efficiency
polynomial
time
algorithms
21st
acm
symp
theory
computing
1989
pp
501
512
relation
bfs
dfs
may
clear
pseudo
code
bfs
dfs
closely
related
fact
class
tried
describe
search
modified
add
end
list
line
bfs
pseudocode
add
start
list
resulting
traversal
algorithm
dfs
little
care
possible
make
bfs
dfs
look
almost
similar
say
prim's
dijkstra's
algorithms
bfs
list
empty
tree
empty
choose
starting
vertex
search
nonempty
remove
edge
start
yet
visited
add
search
dfs
list
empty
tree
empty
choose
starting
vertex
search
nonempty
remove
edge
end
yet
visited
add
search
search
vertex
visit
edge
add
edge
end
search
algorithms
now
keep
list
edges
explore
difference
two
algorithms
adds
items
end
bfs
removes
beginning
results
maintaining
list
queue
dfs
removes
end
maintaining
list
stack
bfs
dfs
directed
graphs
although
discussed
undirected
graphs
search
routines
work
essentially
unmodified
directed
graphs
difference
exploring
vertex
want
look
edges
going
ignore
edges
coming
directed
graphs
can
prove
nice
properties
bfs
dfs
tree
help
classify
edges
graph
bfs
directed
graphs
edge
graph
either
connects
two
vertices
level
goes
exactly
one
level
goes
number
levels
dfs
edge
either
connects
ancestor
descendant
descendant
ancestor
one
node
node
previously
visited
subtree
possible
get
forward
edges
connecting
node
subtree
visited
later
node
use
property
next
time
test
directed
graph
strongly
connected
every
vertex
can
reach
every
one
ics
161
dept
information
computer
science
uc
irvine
last
update
07
may
2004
15
27
14
pdt
