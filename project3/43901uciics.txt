program constuction debugging 

program
construction
debugging
introduction
computer
science
iii
ics
21
22
23
introduction
lecture
will
learn
general
information
iterative
enhancement
technique
designing
coding
testing
debugging
programs
will
discuss
debugging
syntax
complation
errors
execution
runtime
errors
java
debugging
skill
will
become
adept
quarter
progresses
will
much
lecture
will
coupled
handout
includes
practical
information
tutorial
reference
using
eclipse
debugger
please
read
follow
instructions
tool
useful
debugging
programs
also
useful
understanding
java
control
structures
method
calls
parameters
local
variables
objects
instance
variables
shall
use
classroom
repeated
quarter
use
explore
topics
even
use
debug
programs
warmup
debugging
please
read
bugs
programming
web
page
programmers
write
code
80
correct
mark
good
programmer
systematically
locates
corrects
bug
program
100
correct
contrast
poor
programmer
randomly
changes
program
without
knowing
cause
bug
implications
changes
will
actually
reduce
correctness
code
program
construction
via
iterative
enhancement
design
debugging
application
programs
almost
always
written
based
divide
conquer
approach
problem
solving
approaches
rely
belief
harder
solve
one
large
problem
solve
sequence
smaller
subproblems
lead
solution
large
problem
designing
program
must
determine
divide
larger
problem
sequence
smaller
subproblems
conquer
solve
one
individually
industry
team
programmers
working
project
may
solve
problems
parallel
divide
conquer
approach
will
use
mostly
iterative
enhancement
given
problem
specification
program
write
start
writing
kernel
program
meets
dramatically
simplified
version
specification
extend
kernel
writing
sequence
programs
enhancement
previous
one
called
phase
includes
specification
eventually
reach
final
phase
last
program
sequence
meets
entire
specification
solves
entire
problem
analogy
think
trying
cross
river
try
jump
single
bound
try
find
path
stones
river
bed
jump
stone
stone
getting
closer
closer
destination
reach
side
phase
enhancement
like
stepping
stone
addition
approach
allows
us
gauge
progress
finished
phase
acting
milestone
taken
us
3
hours
finish
first
4
phases
project
4
phases
go
assume
phase
takes
amount
work
can
predict
will
take
us
another
3
hours
finish
estimate
crude
better
estimate
pictorially
can
look
process
follows
already
practiced
method
small
scale
early
programming
assignments
requires
perspective
experience
take
complicated
program
specification
identify
good
kernel
design
good
sequence
enhancements
kernel
capture
something
essential
problem
without
getting
bogged
details
often
kernel
captures
information
needed
construct
main
loop
program
phase
reasonable
amount
work
focusing
one
different
aspect
problem
adding
details
phases
involve
designing
coding
testing
debugging
small
amount
related
code
create
enhanced
program
critical
program
testable
can
verify
meets
enhanced
specification
truly
making
progress
towards
ultimate
goal
design
element
code
fails
work
will
discover
quickly
fix
immediately
spend
lots
time
building
parts
code
depend
wrong
decision
start
program
need
good
perfect
understanding
problem
solved
try
understand
much
can
starting
need
understand
everything
afraid
begin
process
writing
program
will
learn
details
problem
tackle
details
enhancements
understanding
problem
willl
increase
work
writing
program
solve
eventually
will
acquire
understanding
every
detail
problem
implemented
every
detail
program
learn
write
methods
will
able
associate
action
code
name
just
referring
name
can
execute
code
sometimes
discovery
methods
bottom
realize
performing
computation
write
method
sometimes
discovery
top
even
write
code
realize
certain
methods
can
act
useful
building
blocks
write
learn
write
classes
will
apply
bottom
top
process
larger
scale
now
can
identify
useful
classes
methods
define
can
test
class
independently
testing
individual
methods
class
working
can
test
combinations
use
build
entire
application
program
thus
always
employing
kind
divide
conquer
approach
solve
programming
problems
another
key
feature
iterative
enhancement
focus
enhancement
focuses
designing
coding
small
number
additions
modifications
already
working
program
debugging
phase
typically
need
focus
small
amount
code
recently
added
changed
way
can
effectively
build
large
programs
focussing
one
piece
time
biggest
problem
making
sure
pieces
fit
together
human
brain
can
keep
track
many
details
time
wrote
huge
amount
code
tried
debug
easily
overload
mental
capacity
often
engineers
talk
kiss
principle
keep
simple
stupid
iterative
enhancement
lets
us
keep
task
simple
finally
end
phase
simplify
code
much
possible
step
back
try
come
equivalent
code
easier
understand
often
smaller
building
code
making
complicated
enhancing
want
always
start
enhancement
simplest
code
possible
simplifying
iterative
enhancement
will
much
effective
focus
trying
simplify
entire
program
written
time
spent
simplifying
code
will
pay
time
saved
later
enhancements
testing
software
testing
process
running
software
looking
errors
meaning
actively
trying
make
program
fail
failure
program
produce
correct
output
correct
input
testing
shows
presence
bug
debugging
begins
process
fixing
errors
found
testing
discussing
process
debugging
look
bit
process
testing
professional
software
testers
acquire
great
skill
intuition
thinking
good
inputs
test
programs
valued
members
product
team
example
microsoft
employs
one
tester
programmer
sometimes
testers
work
teams
separate
programmers
times
tester
will
pair
programmer
programmer
finishes
part
code
tester
begins
testing
programmer
proceeds
next
part
code
tester
finds
bugs
programmer
must
fix
continuing
can
imagine
programmers
often
dislike
testers
latter
always
pointing
mistakes
made
former
better
mistake
pointed
coworker
boss
customer
programmer
wants
believe
code
contains
errors
contain
errors
argue
programmer
intimiate
code
written
best
person
test
programmer
test
code
might
bad
psychological
point
view
might
test
code
rigorously
really
want
find
errors
separate
tester
addresses
problem
even
approach
can
cause
problems
programmer
knows
independent
tester
will
examining
code
written
programmer
may
write
code
carelessly
knowing
someone
else's
job
spot
problems
thus
real
tangle
incentives
writing
testing
code
microsoft
produces
software
overview
accessible
students
course
discussed
cusumano
shelby
microsoft
secrets
world's
powerful
software
company
creates
technology
shapes
markets
manages
people
free
press
1995
agile
programming
methods
includes
extreme
programming
includes
pair
programming
programming
test
driven
coding
programmer
tester
develops
extensive
suite
tests
code
must
pass
code
written
programmer's
progress
judged
number
tests
suite
passes
bit
like
using
iterative
enhancment
judge
progress
programming
code
modified
later
must
repass
tests
will
discuss
junit
testing
towards
end
quarter
helps
automate
test
driven
programming
two
general
categories
testing
black
box
testing
testers
write
test
cases
based
specifications
code
supposed
accomplish
allowed
look
code
white
box
testing
testers
write
test
cases
based
knowledge
specifications
code
certain
kinds
tests
migh
suggest
tester
examines
code
course
black
box
tests
can
developed
code
written
white
box
tests
can
developed
code
written
industry
testers
often
write
use
long
scripts
regression
test
programs
time
program
changed
tester
executes
script
ensure
bugs
introduced
old
features
still
works
always
script
extended
new
features
tested
much
work
regression
testing
can
automated
often
result
tools
either
message
confirming
tests
passed
list
outputs
inputs
differed
original
program
one
now
tested
finally
integration
tests
determine
whether
software
components
written
tested
separately
component
unit
tests
work
together
correctly
program
much
easier
test
debug
component
system
comprising
many
components
systems
even
simple
bugs
can
manifest
hard
understand
situations
many
features
added
programming
languages
end
1990s
designed
simplify
software
integration
will
discuss
many
aspects
testing
detail
later
lecture
focusing
java's
ability
write
unit
tests
inside
classes
testing
cover
junit
will
discuss
kind
automated
testing
detail
debugging
testing
found
problem
can
begin
debugging
trying
locate
source
error
fix
debugging
also
task
suited
solution
divide
conquer
techniques
need
remove
bugs
program
instead
can
remove
one
bug
another
etc
will
eventually
remove
also
looking
location
bug
program
can
divide
program
regions
search
bug
smaller
smaller
regions
find
key
idea
continually
make
progress
never
getting
stuck
long
one
problem
maybe
switching
solve
another
will
divide
debugging
syntax
compilation
bugs
execution
runtime
bugs
syntax
bugs
diagnosed
reported
java
compiler
shows
location
close
approximation
description
error
close
approximation
execution
runtime
bugs
much
difficult
fix
primarily
must
first
find
occur
hardest
part
debugging
tracking
location
error
accomplished
task
actually
fixing
bug
often
much
simple
syntax
bugs
learned
first
lecture
earlier
problem
discovered
less
time
money
will
take
fix
syntax
compilation
errors
discovered
early
java
compiler
detects
reports
running
program
much
easier
fix
execution
runtime
errors
fact
languages
strict
compilers
help
spot
compile
time
errors
become
apparent
runtime
languages
less
strict
compilers
paradoxically
happy
whenever
java
reports
compile
time
bug
given
program
error
compiler
saves
us
locate
error
later
runtime
complicated
process
never
say
program
correct
contains
neither
kinds
errors
many
introductory
programming
students
say
program
errors
working
correctly
saying
program
syntax
errors
compiling
correctly
still
execution
runtime
errors
although
one
likes
told
syntax
errors
programs
java
forces
us
fix
errors
running
programs
thus
eliminates
many
harder
debug
execution
runtime
errors
otherwise
occur
well
designed
programming
language
one
allows
errors
detected
early
possible
compiler
technically
java
compiler
detects
reports
syntax
error
examines
token
legally
appear
next
code
thus
either
token
wrong
recent
one
preceded
first
check
token
immediately
preceding
understand
trying
accomplish
tokens
use
knowledge
help
determine
wrong
wrote
great
help
fixing
subtle
syntax
errors
working
code
program
uses
language
features
correctly
compare
two
find
problem
common
errors
include
missing
semi
colons
mismatched
separators
parentheses
braces
misspelled
names
variables
methods
classes
remember
case
important
wrong
number
type
arguments
operators
methods
prototype
signature
mismatches
java
relatively
good
job
explaining
syntax
errors
finds
sometimes
messages
cryptic
even
just
plain
wrong
takes
bit
intuition
interpret
messages
skill
will
continue
acquire
debug
programs
fact
can
acquire
skill
helping
debug
people's
programs
teachers
good
debugging
java
compiler
multi
pass
compiler
scans
source
code
top
bottom
multiple
times
sometimes
first
syntax
error
reported
first
syntax
error
program
still
best
strategy
try
fix
first
syntax
error
reported
sometimes
might
scan
first
syntax
errors
able
fix
one
time
times
may
confused
first
syntax
error
able
fix
later
one
fact
sometimes
fixing
one
syntax
error
eliminates
others
root
cause
recommend
fixing
just
one
syntax
error
compilation
can
always
fix
least
one
error
time
compile
program
will
eventually
remove
syntax
errors
often
fixing
three
syntax
errors
can
eliminate
dozen
syntax
error
messages
fix
syntax
error
seek
help
understand
wrong
write
problem
error
message
solution
error
log
can
consult
whenever
hard
fix
syntax
errors
incorrectly
matching
braces
can
cause
many
syntax
error
messages
indicative
real
problem
reason
whenever
type
opening
brace
eclipse
will
automatically
type
matching
closing
brace
position
cursor
inbetween
two
continue
typing
statements
block
eclipse
also
supports
special
brace
matching
operation
double
click
immediately
opening
brace
execution
bugs
java
compiler
finds
syntax
errors
program
can
run
program
program
may
may
behave
simple
program
may
compute
display
correct
results
complicated
one
may
right
thing
click
buttons
either
case
execution
runtime
error
technically
execution
runtime
error
something
java
detects
like
throwing
exception
dividing
0
intent
error
program
finishes
without
execution
runtime
error
nevertheless
computes
incorrect
result
discussion
will
refer
kinds
errors
execution
errors
debugging
execution
errors
hard
leave
ego
door
admit
put
error
program
systematically
locate
fix
problem
golden
rule
debugging
find
simplest
input
program
consistently
produces
error
makes
debugging
much
easier
can
apply
techniques
described
effectively
debugging
program
simplest
input
causing
error
find
input
causes
program
fail
keep
trying
simpler
inputs
fewer
values
smaller
values
etc
find
simplest
one
fails
start
debubugging
job
1
debugging
finding
location
error
know
statement
contains
wrong
instruction
wrong
syntax
right
statement
program
execute
finding
fix
often
much
simpler
typical
way
find
problem
instrument
program
system
println
statements
display
current
state
relevant
variables
can
build
complicated
programs
trace
can
use
statement
testing
trace
variable
determine
whether
print
information
boolean
level
information
int
trace
level
print
program
executes
eventually
will
find
variable
goes
storing
right
value
storing
wrong
one
statements
displayed
right
wrong
value
location
error
write
programs
using
iterative
enhancement
phase
display
variables
creates
changes
can
see
new
parts
program
making
right
state
changes
sometimes
program
gets
infinite
loop
test
controling
termination
loop
never
true
put
system
println
statement
inside
body
loop
loop
becomes
infinite
information
will
print
indicating
infinite
loop
system
println
start
loop
real
statements
loop
sometimes
system
println
statements
involve
variables
system
println
execute
critical
statement
frequently
system
println
update
always
uniquely
label
output
statements
know
program
piece
information
printed
amount
time
spend
typing
statements
dwarfed
amount
time
spend
studying
make
output
clear
first
time
always
remember
use
println
print
debugging
purposes
console
buffers
like
file
buffers
use
print
possible
program
execute
print
first
terminate
abnormally
without
printed
information
displayed
can
confusing
println
information
will
always
fully
displayed
program
executes
subsequent
statements
output
accurate
log
program
find
bug
hard
part
often
takes
much
less
work
fix
often
hand
simulation
closely
see
problem
whenever
fix
bug
immediately
hand
simulate
rerun
new
code
ensure
now
works
correctly
perform
expected
undo
change
go
back
old
code
look
different
fix
keep
change
code
unless
observe
change
improves
code
one
change
may
completely
correct
code
improve
make
lots
changes
improve
code
will
degrade
code
make
harder
fix
first
effort
programmer
often
80
correct
students
tendancy
make
unsupported
changes
code
debugging
often
taking
code
close
correct
away
good
programmers
verify
change
improves
code
change
improve
things
remove
go
back
original
code
keep
making
improvements
code
correct
measure
good
programmer
necessarily
many
bugs
initially
present
code
quickly
removes
bugs
simple
debugging
tips
eliminate
obvious
errors
first
make
sure
data
read
correctly
file
trying
debug
code
processes
data
read
correctly
course
processing
code
will
produce
incorrect
results
ensure
every
variable
contains
reasonable
value
value
used
first
time
variables
can
initialized
declared
subsequent
statements
involving
operator
state
change
operators
update
state
depend
value
already
stored
expression
computing
incorrect
value
display
values
variables
used
expression
one
may
wrong
unsure
part
else
executing
put
something
like
following
top
block
containing
statements
else
controls
test
system
println
test
test
true
real
statements
true
test
else
system
println
test
test
false
real
statements
false
test
eclipse
debug
perspective
eclipse
debug
perspective
can
help
automate
hand
simulation
program
instrumentation
needed
debug
programs
allows
us
equivalent
without
entering
code
recompiling
programs
debuggers
contain
many
powerful
features
allowing
us
monitor
execution
program
location
statement
executing
values
stored
variables
declared
program
programmers
prefer
avoid
using
debugger
instead
instrument
code
carefully
write
others
prefer
master
debugger
can
use
quickly
locate
many
kinds
errors
blend
two
approaches
probably
best
takes
experience
well
end
will
examine
eclipse
debugger
handout
practice
using
problem
set
problems
lecture
see
eclipse
debugger
handout
problems
last
page
