ics 22 cse 22 fall 2012 project 6 expresso love 
project 6 
ics
22
cse
22
fall
2012
news
course
reference
schedule
lab
manual
code
examples
alex
ics
22
cse
22
fall
2012
project
6
expresso
love
due
date
time
friday
december
7
11
59pm
project
done
pairs
using
pair
programming
technique
introduction
project
asked
write
eleven
racket
functions
according
given
specifications
will
give
opportunity
practice
functional
programming
addition
learn
approach
solve
problems
using
recursion
skill
will
continue
benefit
ics
23
cse
23
beyond
even
ever
write
another
line
racket
code
functional
programming
something
likely
see
coursework
take
course
programming
languages
compsci
141
cse
141
functional
programming
features
gradually
beginning
work
way
mainstream
programming
languages
variety
reasons
knowing
something
will
make
prepared
keep
inevitable
changes
programming
languages
time
choosing
partner
pair
programming
required
project
need
choose
partner
among
people
enrolled
lab
section
different
people
partnered
previously
remember
required
partner
someone
enrolled
lab
section
trouble
finding
partner
notify
ta
can
assisted
finding
one
found
partner
notified
ta
pairing
end
lab
section
meeting
wednesday
november
28
reserve
right
assign
partner
case
will
notify
via
email
partnership
arrangement
ta
selected
partner
fashion
will
allow
switch
another
one
best
way
control
destiny
choose
partner
will
receive
credit
assignment
work
alone
without
prior
consent
instructor
please
note
prior
consent
include
approaching
us
day
project
due
completed
telling
us
able
find
partner
using
drracket
drracket
environment
writing
running
programs
written
variety
similar
looking
programming
languages
collectively
called
racket
predominantly
focused
style
programming
called
functional
programming
languages
include
well
known
language
called
scheme
particular
dialect
racket
based
use
scheme
will
discover
differences
full
standard
scheme
chosen
subset
able
adapt
quickly
drracket
built
primarily
use
teaching
learning
programming
though
support
surprising
array
real
world
functionality
well
runs
versions
windows
mac
os
various
flavors
unix
linux
drracket
already
installed
machines
lab
can
downloaded
free
use
racket
lang
org
latest
version
writing
5
3
though
new
versions
come
somewhat
regularly
explanation
assumes
using
version
previous
versions
essentially
installation
drracket
windows
snap
installed
operating
systems
presume
just
simple
others
just
execute
setup
program
will
take
care
everything
installer
finished
find
folder
called
racket
programs
folder
start
menu
select
drracket
menu
go
first
execute
drracket
prompted
choose
language
list
remember
drracket
supports
variety
different
languages
including
different
combination
libraries
features
prompted
select
language
can
also
select
one
time
going
language
menu
selecting
choose
language
list
languages
teaching
languages
click
design
programs
advanced
student
click
ok
finally
click
run
button
near
top
right
corner
main
racket
window
now
ready
roll
screenshot
drracket
action
bottom
half
drracket
window
interpreter
simply
type
expression
interpreter
get
back
answer
just
like
talked
lecture
top
half
window
can
write
racket
code
save
file
write
functions
unit
tests
need
write
project
make
change
code
wish
test
interpreter
click
run
button
toolbar
causes
interpreter
restarted
code
top
half
window
loaded
though
typed
interpreter
also
runs
unit
tests
example
writing
square
function
top
half
window
along
tests
verify
correctness
clicked
run
button
told
tests
passed
subsequently
able
call
square
function
interpreter
output
generated
expressions
will
printed
time
say
run
forget
save
file
periodically
accidentally
lose
work
project
set
racket
functions
required
write
project
general
permitted
make
assumptions
arguments
function
assumptions
listed
description
function
example
unless
explicitly
stated
may
assume
lists
will
simple
simple
list
one
sublists
along
function
required
write
unit
tests
described
lecture
using
racket's
built
testing
functions
tools
disposal
sure
code
works
drracket
advanced
student
language
level
selected
grading
work
beyond
also
staying
within
even
restricted
subset
racket
may
use
following
predefined
racket
functions
constructs
solution
define
lambda
cond
else
empty
empty
first
rest
cons
list
list
equal
may
also
use
predefined
test
functions
unit
testing
solutions
check
expect
check
within
check
error
may
need
everything
listed
ones
eligible
use
like
use
predefined
functions
need
write
terms
listed
decomposing
problems
smaller
ones
functions
written
easily
without
helper
functions
turn
helper
functions
along
ones
write
may
reuse
helper
functions
one
solutions
like
though
required
similarly
may
call
solution
one
functions
solution
another
word
notation
advanced
student
language
level
drracket
provides
two
equivalent
ways
describing
list
using
list
construct
short
hand
version
consisting
lists
elements
surrounded
parentheses
example
list
containing
numbers
1
2
3
4
5
can
written
one
two
ways
list
1
2
3
4
5
'
1
2
3
4
5
two
notations
can
little
confusing
sometimes
require
quoting
different
places
example
list
symbols
look
like
supported
styles
list
'x
'y
'z
'
work
either
styles
fine
writing
functions
using
advanced
student
language
level
will
project
list
construct
used
describe
lists
returned
output
functions
eleven
functions
asked
write
includes
brief
set
examples
shows
output
cases
note
examples
intended
complete
set
tests
function
may
want
develop
extra
examples
remember
pay
special
attention
base
case
function
always
listed
examples
whose
answer
able
deduce
description
problem
fourth
element
fourth
element
function
takes
list
returns
fourth
element
course
lists
four
elements
list
empty
list
returned
necessarily
simple
handle
sublists
differently
elements
fourth
element
sublist
return
whole
sublist
examples
fourth
element
list
'a
'b
'c
'd
'e
fourth
element
list
'x
list
'y
'z
'w
'h
'j
fourth
element
list
list
'a
'b
list
'c
'd
list
'e
'f
list
'g
'h
list
'i
'j
list
'g
'h
fourth
element
list
'a
'b
'c
empty
list
length
list
length
function
takes
list
returns
number
elements
list
examples
list
length
list
'a
'b
'c
3
list
length
list
'a
list
'b
'c
'd
'e
'f
5
count
matches
count
matches
function
takes
symbol
simple
list
symbols
returns
number
times
occurs
examples
count
matches
'f
list
'a
'b
'c
'd
'e
'f
'g
1
count
matches
'b
list
'a
'b
'a
'b
'a
'b
'a
3
count
matches
'x
list
'a
'b
'c
0
append
l1
l2
append
function
takes
two
lists
l1
l2
returns
concatenation
l1
l2
concatenation
means
stick
one
end
note
concatenation
thing
cons
two
lists
examples
append
list
'a
'b
list
'c
'd
list
'a
'b
'c
'd
append
empty
list
'a
'b
list
'a
'b
append
list
'a
'b
empty
list
'a
'b
increasing
increasing
function
takes
simple
list
numbers
returns
true
numbers
list
increasing
read
beginning
end
false
define
increasing
according
mathemtical
definition
word
numbers
increasing
long
never
decrease
opposed
might
call
strictly
increasing
every
number
bigger
previous
one
special
cases
consider
one
element
empty
lists
increasing
examples
increasing
list
1
2
3
true
increasing
list
3
2
1
false
increasing
list
1
2
2
3
4
4
5
true
increasing
list
1
true
increasing
empty
true
remove
duplicates
remove
duplicates
function
takes
simple
list
returns
new
list
duplicate
objects
removed
examples
remove
duplicates
list
1
2
3
list
1
2
3
remove
duplicates
list
1
2
1
4
list
2
1
4
list
1
2
4
remove
duplicates
list
3
3
3
3
3
list
3
calc
running
sums
calc
running
sums
function
takes
simple
list
numbers
returns
list
containing
running
sums
nth
element
returned
list
sum
first
elements
examples
calc
running
sums
list
1
list
1
calc
running
sums
list
2
2
2
2
2
list
2
4
6
8
10
calc
running
sums
list
2
5
8
list
2
7
15
recursive
sum
recursive
sum
function
takes
list
numbers
returns
sum
numbers
list
may
sublists
atoms
list
will
numbers
sum
empty
list
0
examples
recursive
sum
empty
0
recursive
sum
list
1
2
3
6
recursive
sum
list
1
1
1
1
4
recursive
sum
list
1
list
2
3
4
10
calc
depth
calc
depth
function
takes
list
returns
depth
depth
list
defined
maximum
level
nesting
list
list
sublists
depth
1
list
sublists
sublists
depth
2
list
sublists
sublists
sublists
depth
3
examples
calc
depth
list
1
2
3
1
calc
depth
list
1
list
2
3
2
calc
depth
list
1
list
2
list
3
4
5
3
calc
depth
list
1
list
2
3
list
4
list
5
3
deep
reverse
deep
reverse
function
takes
list
returns
deep
reversal
deep
reversal
list
contains
elements
reverse
order
element
l'
list
corresponding
element
deep
reversal
l'
examples
deep
reverse
list
'a
'b
'c
list
'c
'b
'a
deep
reverse
list
list
'a
'b
'c
'd
list
list
'e
'f
'g
list
list
'g
list
'f
'e
'd
list
'c
'b
'a
filter
items
filter
items
function
takes
function
takes
one
argument
returns
boolean
result
list
job
filter
items
call
elements
returning
list
elements
returned
true
leaving
elements
returned
false
pretty
powerful
function
can
solve
wide
variety
problems
general
say
higher
order
functions
take
functions
arguments
called
higher
order
powerful
can
send
arbitrary
function
configure
can
solve
problems
even
conceived
yet
examples
make
use
predefined
racket
functions
show
versatile
filter
items
will
done
feel
free
use
functions
tests
filter
items
even
though
list
functions
can
use
solutions
positive
returns
true
argument
positive
number
false
notodd
returns
true
argument
odd
number
false
notstring
length
takes
string
argument
returns
number
characters
string
examples
filter
items
positive
list
1
3
2
4
3
5
4
6
list
1
2
3
4
filter
items
odd
list
1
2
3
4
5
6
list
1
3
5
filter
items
increasing
list
list
1
4
list
4
3
2
list
5
6
list
list
1
4
list
5
6
filter
items
lambda
list
alex
last
example
interesting
lambda
expression
builds
returns
function
give
function
name
order
use
though
often
case
saying
call
filter
items
passing
newly
built
function
takes
string
returns
true
length
4
along
list
strings
expect
get
back
list
strings
original
list
whose
lengths
4
grading
project
will
graded
33
point
scale
unlike
previous
projects
please
note
though
project
will
weigh
differently
final
grade
others
score
project
will
scaled
proportionally
match
others
33
points
will
broken
differently
points
available
projects
eleven
racket
functions
will
worth
three
points
will
scored
according
following
rubric
2
points
correctness
quality
solution
earn
2
function
must
return
correct
value
specified
cases
may
test
functions
cases
examples
listed
make
sure
test
functions
thoroughly
earn
1
function
must
correct
cases
function's
code
must
also
constitute
attempt
actually
solve
problem
given
clearer
following
two
situations
will
yield
score
0
function
works
base
case
empty
list
function
accidentally
works
one
cases
constitute
attempted
solution
problem
given
recursive
sum
function
always
returns
3
happens
answer
one
test
cases
1
point
testing
means
used
drracket's
built
test
functions
like
check
expect
demonstrate
function
works
variety
cases
get
1
point
must
include
interesting
cases
ones
listed
project
write
note
racket
much
deeper
much
full
featured
programming
language
considered
class
example
predefined
functions
racket
solve
problems
assigned
still
interested
learning
solve
problems
particular
way
sticking
small
subset
racket
forbidden
using
predefined
racket
functions
constructs
list
accepted
functions
constructs
listed
top
project
write
functions
uses
anything
forbidden
will
receive
0
points
sure
one
solutions
breaks
rule
please
ask
us
ahead
time
intended
gotcha
intended
force
attack
problems
certain
way
style
issues
will
de
emphasized
since
spent
time
discussing
issues
respect
racket
deliverables
put
solutions
single
file
called
project6
rkt
submit
file
others
must
able
read
file
directly
drracket
environment
test
write
procedures
microsoft
word
another
format
please
include
comment
top
file
lists
names
student
ids
partner
comments
racket
begin
semicolon
character
though
convention
often
use
two
row
easier
see
everything
follows
semicolon
line
ignored
racket
interpreter
follow
link
discussion
submit
project
additional
challenge
interested
understanding
functional
programming
different
object
oriented
programming
accustomed
particularly
giving
variables
changes
approach
problems
make
impossible
approach
consider
problem
implementing
queue
racket
using
tools
know
thus
far
first
attempt
queue
list
one
approach
implement
queue
list
following
functions
make
queue
takes
parameters
returns
empty
queue
case
empty
list
queue
enqueue
takes
queue
new
element
returns
queue
new
element
added
back
case
added
end
list
queue
dequeue
takes
queue
returns
queue
front
element
removed
case
first
list
element
removed
queue
front
takes
queue
returns
element
front
case
first
list
element
queue
empty
takes
queue
returns
true
empty
false
case
can
check
list
empty
functions
longer
need
know
implemented
queue
collectively
play
role
interface
java
hiding
details
queue's
implementation
implemted
way
racket
details
quite
hidden
can
safely
ignore
using
five
functions
manipulate
queue
try
implementing
functions
read
analysis
first
attempt
okay
now
implemented
functions
consider
notation
understanding
lists
racket
behave
essentially
like
singly
linked
lists
head
references
make
queue
1
return
empty
listqueue
enqueue
adding
end
list
takes
linear
timequeue
dequeue
1
removing
first
element
list
takes
constant
timequeue
front
1
accessing
first
element
list
takes
constant
timesqueue
empty
1
checking
list
empty
requires
checking
head
reference
can
done
constant
time
better
approach
using
two
lists
instead
issue
keeping
first
approach
efficient
enough
many
purposes
racket
lists
equivalent
singly
linked
lists
head
references
accessing
end
lists
need
able
enqueue
elements
expensive
unlike
java
though
just
add
tail
reference
functional
racket
however
clever
approach
1
average
long
haul
analysis
bit
deep
uses
technique
called
amortized
analysis
learn
ics
23
cse
23
can
give
rough
idea
instead
using
just
one
list
queues
will
made
two
lists
list
first
elements
queue
beginning
front
element
continuing
forward
list
last
elements
queue
beginning
last
element
continuing
backward
can
implement
queue
list
containing
two
lists
example
implementation
level
view
queue
containing
elements
might
one
possibilities
list
list
'a
'b
'c
list
'f
'e
'd
list
list
'a
list
'f
'e
'd
'b
'c
list
list
'a
'b
'c
'd
'e
list
'f
now
point
splitting
queue
two
lists
like
think
function
implemented
now
make
queue
returns
list
two
empty
lists
queue
enqueue
takes
queue
new
element
returns
new
queue
following
properties
first
list
unchangedthe
second
list
new
element
added
front
queue
dequeue
takes
queue
returns
new
queue
front
element
removed
two
possibilities
first
list
elements
first
element
first
list
removed
second
list
unchanged
first
list
empty
make
first
list
reverse
original
second
list
first
element
removed
make
second
list
empty
queue
front
takes
queue
returns
front
element
two
possibilities
first
list
elements
first
element
first
list
removed
first
list
empty
return
last
item
second
list
queue
empty
takes
queue
returns
true
lists
empty
false
otherwise
try
writing
functions
read
brief
analysis
second
approach
consider
notation
operation
make
queue
1
two
empty
lists
can
created
constant
time
queue
enqueue
1
can
add
element
front
second
list
constant
time
queue
dequeue
worst
case
requires
reversing
second
list
trick
though
happen
often
longer
takes
longer
second
list
longer
will
longer
first
list
done
average
long
haul
average
time
spent
performing
dequeue
will
constant
analysis
similar
add
method
adds
element
end
arraylist
takes
constant
time
average
even
though
sometimes
takes
longer
queue
front
worst
case
occurs
first
list
empty
assuming
ask
front
element
often
dequeue
element
expensive
calls
queue
front
happen
often
will
happen
decreasingly
often
expensive
going
need
call
queue
front
many
times
queue
dequeues
ways
mitigate
problem
queue
empty
1
takes
constant
time
check
two
lists
empty
face
analysis
seems
worse
started
now
two
operations
can
take
linear
time
one
operation
difference
first
attempt
every
call
queue
enqueue
takes
linear
time
second
attempt
occasional
calls
queue
dequeue
queue
front
linear
rest
constant
really
turn
truly
better
approach
variety
small
updates
alex
thornton
winter
2012
additional
information
testing
requirement
added
alex
thornton
fall
2008originally
written
alex
thornton
fair
amount
influence
basic
instructions
alex
thornton
winter
2007
