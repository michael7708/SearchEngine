compsci 141 cse 141 informatics 101 fall 2009 assignment 3 
assignment 3 
compsci
141
cse
141
informatics
101
fall
2009
news
course
reference
schedule
lab
manual
code
examples
alex
compsci
141
cse
141
informatics
101
fall
2009
assignment
3
due
date
time
friday
october
30
9
00pm
introduction
discussed
lecture
functional
languages
haskell
provide
substantial
advantages
imperative
style
counterparts
programs
simple
clear
concise
tedious
error
prone
details
things
like
memory
management
handled
automatically
concurrency
distribution
across
multiple
machines
simpler
cases
automatable
advantages
enabled
simpler
programming
model
programs
global
state
variables
assignment
statements
expressions
statements
higher
order
functions
functions
take
functions
parameters
build
return
functions
results
given
set
parameters
function
will
always
return
result
makes
understanding
program
easier
since
none
unforeseen
interactions
subprograms
difficult
avoid
imperative
style
programming
java
global
mutable
state
course
disadvantages
functional
programming
well
pays
ultimately
know
functional
programming
might
might
appropriate
approach
even
programming
say
object
oriented
language
surprised
many
ways
functional
programming
techniques
will
help
better
understand
design
software
example
number
methods
functions
standard
libraries
java
built
around
ideas
functional
programming
function
objects
objects
often
carry
state
support
one
method
passed
parameters
instead
functions
syntax
ways
different
since
object
created
possibly
destroyed
semantics
heavyweight
since
object's
class
may
inherit
class
implement
interface
idea
precisely
idea
functional
programming
passing
function
parameter
another
function
functional
programming
presents
easier
venue
learning
technique
stripped
essence
without
scaffolding
required
object
oriented
language
accomplish
goal
functional
programming
requires
somewhat
different
mindset
imperative
style
programming
likely
accustomed
emphasis
writing
small
generic
reusable
building
blocks
can
combined
wide
variety
ways
whose
primary
experience
languages
like
java
visual
basic
may
find
limitations
functional
programming
difficult
overcome
first
declare
variables
create
objects
imperative
style
language
write
loops
manipulate
functional
approach
use
recursion
instead
parameters
results
carrying
information
might
prefer
store
variables
pass
object
configures
behavior
method
object
oriented
language
functional
approach
require
function
passed
instead
write
loop
walks
linked
list
performs
operation
element
functional
approach
use
higher
level
abstraction
mapping
function
passed
indicate
operation
performed
elements
assignment
gives
opportunity
explore
core
language
features
haskell
purposes
assignment
purely
functional
language
particular
going
concentrate
attention
features
make
haskell
different
seen
later
quarter
talk
differences
stark
may
seem
ideas
show
haskell
also
show
albeit
different
syntax
languages
may
familiar
course
learning
something
new
always
difficult
especially
forbidden
things
feel
comfortable
time
though
may
come
find
many
seeming
limitations
haskell
variables
classes
objects
actually
free
limit
get
started
remember
maintain
open
mind
syntax
will
frustrating
first
time
learn
new
language
frustration
fades
quickly
gain
experience
semantic
hurdles
somewhat
difficult
clear
worthwhile
will
pay
regardless
whether
ever
write
another
line
haskell
code
many
concepts
universal
sure
get
questions
answered
along
way
know
working
new
language
difficult
happy
help
enjoy
getting
started
like
many
programming
languages
multiple
dialects
haskell
need
pick
one
use
recent
standard
version
haskell
called
haskell
98
sounds
old
sense
windows
98
considered
old
operating
system
standards
standardizing
programming
language
lengthy
process
even
recent
standard
comes
1998
though
new
standards
haskell
expected
within
next
year
two
also
multiple
implementations
haskell
work
quarter
use
one
called
hugs
98
available
windows
mac
os
several
distributions
linux
freebsd
openbsd
using
hugs
98
ics
labs
windows
workstations
ics
labs
provide
hugs
98
interpreter
use
can
use
selecting
start
menu
suggest
using
winhugs
gui
based
windows
application
rather
command
line
version
simply
called
hugs
support
haskell
equivalently
winhugs
user
interface
obvious
advantages
graphical
start
winhugs
sure
says
running
haskell
98
mode
mode
default
hurt
check
winhugs
also
supports
extended
mode
called
hugs
mode
extensions
supported
course
select
options
file
menu
switch
mode
haskell
98
compatibility
downloading
hugs
98
home
use
hugs
98
available
variety
platforms
including
windows
mac
os
several
distributions
linux
freebsd
want
download
latest
version
sep
2006
following
link
hugs
98
web
site
installation
instructions
differ
one
platform
another
though
used
windows
version
offers
typical
frills
windows
based
installer
using
hugs
98
hugs
98
provides
interactive
interpreted
haskell
environment
offers
sometimes
called
read
evaluate
print
loop
repeatedly
asked
type
expression
expression
evaluated
result
printed
somewhat
different
environment
one
might
accustomed
require
compilation
separate
program
execution
instead
load
script
interpreter
can
call
functions
typing
expressions
interpreter's
prompt
kind
work
will
notion
main
function
writing
either
individual
functions
functions
work
tandem
one
another
produce
result
complete
programs
say
write
complete
haskell
programs
compile
beyond
scope
work
provided
example
haskell
script
couple
simple
haskell
functions
example
using
interpreter
load
script
execute
functions
assuming
script
saved
folder
haskell
examples
type
text
shown
boldface
interpreter
printing
text
shown
prelude
cd
haskell
examples
prelude
load
examples
examples
factorial
5
120
examples
listlength
1
2
3
4
4
examples
factorial
listlength
1
2
3
4
24
examples
type
factorial
factorial
int
int
straightforward
user's
guide
available
hugs
web
site
suggest
reading
chapter
2
nothing
else
briefly
discusses
commands
loading
reloading
haskell
scripts
evaluating
expressions
asking
expression's
type
others
may
find
handy
work
part
1
simple
functions
primitive
recursion
create
new
haskell
script
called
part1
hs
beginning
following
line
module
part1
script
write
following
functions
part
assignment
requiring
stick
writing
simple
functions
using
primitive
recursion
necessary
use
higher
order
functions
use
higher
level
list
functions
map
filter
foldr
discussed
lecture
subsequent
parts
assignment
explore
higher
order
functions
can
dramatically
simplify
haskell
functions
inc
takes
one
int
parameter
returns
value
int
1
added
examples
part1
inc
3
4
part1
inc
inc
0
2
larger
takes
two
int
parameters
returns
larger
two
examples
part1
larger
3
4
4
part1
larger
8
5
8
part1
larger
3
3
3
sumoffirstn
takes
int
parameter
returns
sum
integers
1
inclusive
function
result
zero
negative
error
message
example
roughly
equivalent
default
fine
need
construct
error
message
examples
part1
sumoffirstn
5
15
part1
sumoffirstn
1
error
pattern
match
failure
largest
takes
list
ints
parameter
returns
largest
integer
list
function
result
given
list
empty
examples
part1
largest
1
2
3
4
4
part1
largest
3
1
5
4
5
part1
largest
error
pattern
match
failure
addonetoall
takes
list
ints
parameter
returns
list
1
added
original
elements
examples
part1
addonetoall
1
2
3
2
3
4
part1
addonetoall
removealexes
takes
list
strings
parameter
returns
list
occurrence
string
alex
removed
function
case
sensitive
removes
strings
whose
value
exactly
alex
examples
part1
removealexes
alex
alex
alex
alex
alex
alex
deepsum
takes
list
lists
ints
returns
sum
integers
lists
sum
empty
list
considered
0
examples
part1
deepsum
1
2
2
3
3
4
15
part1
deepsum
1
1
part1
deepsum
0
might
find
useful
use
functions
helpers
solutions
others
might
also
find
necessary
write
separate
helper
functions
officially
assigned
sure
include
type
declaration
function
example
following
function
calculates
factorial
integer
important
include
first
line
explicitly
declares
function's
type
addition
equations
define
function
factorial
int
int
factorial
0
1
0
factorial
1
haskell
interpreters
compilers
actually
support
feature
called
type
inference
meaning
can
deduce
types
function's
parameters
result
based
way
used
within
function
however
specifying
type
function
worthwhile
form
documentation
required
functions
assignment
part
2
higher
order
functions
partial
function
application
operator
sections
background
thanks
higher
level
abstraction
mechanisms
provided
haskell
standard
prelude
higher
order
functions
partial
function
application
operator
sections
kind
primitive
recursion
used
several
functions
part
1
often
unnecessary
part
assignment
will
allow
rewrite
functions
part
1
well
new
ones
hard
work
done
one
pre
existing
haskell
constructs
functions
task
create
new
haskell
script
called
part2
hs
beginning
following
lines
module
part2
import
part1
import
directive
makes
functions
part1
module
available
part2
module
loading
part2
interpreter
will
also
load
part1
automatically
part2
hs
script
write
following
functions
time
making
use
various
higher
level
features
avoided
part
1
inclined
try
challenge
use
partial
function
application
whenever
can
example
consider
function
squares
elements
list
integers
assuming
presence
function
square
squares
integer
least
two
ways
write
function
haskell
squareall
int
int
squareall
xs
map
square
xs
squareall
int
int
squareall
map
square
two
approaches
equivalent
latter
arguably
clearer
read
english
squareall
map
square
across
list
functions
need
write
part
2
addonetoall2
behaves
equivalently
addonetoall
function
part
1
implemented
using
higher
order
list
functions
map
filter
foldr
zipwith
instead
primitive
recursion
examples
part2
addonetoall2
1
2
3
2
3
4
part2
addonetoall2
addonetoallremovingnegatives
takes
list
ints
parameter
adding
one
elements
non
negative
removing
elements
negative
use
higher
order
functions
operator
sections
solution
appropriate
examples
part2
addonetoallremovingnegatives
1
2
3
2
3
4
part2
addonetoallremovingnegatives
1
1
2
2
3
3
4
2
3
4
5
sumoffirstn2
behaves
equivalently
sumoffirstn
part
1
implemented
using
higher
order
functions
examples
part2
sumoffirstn2
5
15
part2
sumoffirstn2
1
error
pattern
match
failure
concatenate
takes
list
strings
flattens
one
long
string
remember
strings
really
lists
chars
use
higher
order
functions
operator
sections
solution
appropriate
use
pre
existing
concat
function
examples
part2
concatenate
alex
happy
alexishappy
part2
concatenate
hello
world
hello
world
largest2
behaves
equivalently
largest
function
part
1
implemented
using
higher
order
functions
operator
sections
appropriate
examples
part2
largest2
1
2
3
4
4
part2
largest2
3
1
5
4
5
part2
largest2
error
pattern
match
failure
calculatenetincomes
takes
two
lists
floats
first
list
gross
incomes
set
people
second
list
taxes
paid
set
people
list
items
list
correspond
first
element
first
list
gross
income
first
person
first
element
second
list
taxes
paid
first
person
function
calculates
net
income
people
net
income
defined
gross
income
minus
taxes
paid
examples
part2
calculatenetincomes
35123
75
21011
88
105143
13
8127
19
7003
55
37881
47
26996
56
14008
33
67261
66
part2
calculatenetincomes
part
3
polymorphically
typed
functions
background
first
two
parts
assignment
wrote
functions
limited
dealing
one
set
parameter
types
returned
one
kind
result
example
largest2
took
list
ints
parameter
returned
largest
int
list
however
reason
largest2
necessarily
limited
ints
algorithm
used
find
largest
float
list
floats
largest
string
lexicographically
list
strings
difference
individual
elements
compared
note
say
thing
similar
java
method
java
solve
problem
using
generics
discussed
lecture
polymorphically
typed
functions
present
solution
problem
allowing
define
one
function
can
operate
variety
types
way
similar
java's
generics
part
assignment
write
functions
polymorphically
typed
case
part
challenge
specify
general
type
function
can
use
type
command
hugs
uses
type
inferencing
determine
general
type
function
already
type
declaration
get
help
though
best
spend
time
thinking
resort
using
type
command
task
create
script
called
part3
hs
beginning
following
lines
module
part3
import
part1
import
part2
notice
necessary
import
part1
part2
modules
want
definitions
modules
available
part3
module
import
recursive
part3
hs
script
write
following
functions
making
generally
typed
can
concatenate3
behaves
equivalently
concatenate
function
part
2
polymorphic
can
flatten
kind
list
lists
rather
just
list
lists
chars
examples
part3
concatenate3
alex
happy
alexishappy
part3
concatenate3
hello
world
hello
world
part3
concatenate3
1
2
3
4
5
6
1
2
3
4
5
6
part3
concatenate3
1
2
3
4
1
2
3
4
removealloccurrences
takes
element
type
list
type
parameters
removing
occurrences
given
element
given
list
function
polymorphic
takes
lists
elements
type
long
type
supports
comparison
equality
eq
part3
removealloccurrences
3
1
2
3
4
5
4
3
2
1
1
2
4
5
4
2
1
part3
removealloccurrences
alex
alex
happy
today
alex
done
happy
today
done
larger3
behaves
equivalently
larger
function
part
1
except
polymorphic
meaning
will
return
larger
two
arguments
regardless
type
long
type
supports
comparison
basis
ordering
ord
part3
larger3
3
4
4
part3
larger3
8
5
8
part3
larger3
alex
thornton
thornton
largest3
behaves
equivalently
largest2
function
part
2
except
polymorphic
meaning
will
return
largest
element
list
regardless
list's
type
long
type
supports
comparison
basis
ordering
ord
part3
largest3
1
2
3
4
4
part3
largest3
3
1
5
4
5
part3
largest3
alex
happy
part3
largest3
4
5
3
7
2
3
4
5
part
4
lazy
evaluation
infinite
recursion
infinite
lists
background
haskell's
mechanism
evaluating
expressions
different
experienced
programming
languages
java
scheme
example
evaluate
expressions
roughly
way
example
arguments
function
completely
evaluated
function
called
consider
following
two
java
methods
public
arraylist
getlistofintegers
int
arraylist
new
arraylist
int
0
add
return
public
int
returnfirstelement
arraylist
return
get
0
now
suppose
executed
statement
system
println
returnfirstelement
getlistofintegers
10000000
even
though
first
element
arraylist
actually
used
java
will
execute
getlistofintegers
completion
building
arraylist
10
000
000
integers
calling
returnfirstelement
java
designed
way
least
partly
side
effects
global
state
since
getlistofintegers
potentially
long
lasting
effect
beyond
just
computing
returning
result
way
ever
hope
understand
java
program
methods
executed
completion
time
called
important
know
java
since
might
otherwise
find
foolishly
walking
performance
trap
haskell's
approach
fundamentally
different
programming
languages
haskell
uses
lazy
evaluation
evaluate
expressions
meaning
result
ever
calculated
needed
fact
part
result
ever
calculated
needed
leads
startling
design
choices
functions
infinitely
recursive
take
build
infinitely
long
lists
least
substantially
longer
lists
might
needed
used
judiciously
cause
performance
problem
haskell
terms
time
space
since
function
will
proceed
far
needed
list
will
evaluated
far
needed
advantage
can
often
write
functions
without
considering
boundary
conditions
input
lengths
minutiae
might
think
programming
languages
example
imagine
list
strings
representing
names
students
course
wanted
assign
one
unique
id
haskell's
solution
problem
remarkably
simple
clear
assignids
string
int
string
assignids
names
zip
1
names
1
infinite
list
1
2
3
zip
function
standard
haskell
function
takes
two
lists
zips
together
creating
pair
corresponding
elements
list
first
elements
list
paired
second
elements
list
paired
zipping
stops
one
two
lists
runs
elements
example
might
see
following
behavior
called
function
haskell
interpreter
idmodule
assignids
norm
rich
alex
1
norm
2
rich
3
alex
approach
able
give
student
unique
id
without
using
counter
variable
might
java
without
writing
recursive
function
though
fairness
point
zip
recursive
without
worrying
many
elements
list
names
code
simpler
java
equivalent
syntax
terse
simpler
rely
fewer
details
order
accomplish
goal
task
create
script
called
part4
hs
beginning
following
lines
module
part4
import
part1
import
part2
import
part3
script
write
following
functions
wholenumbers
takes
parameters
returns
infinite
list
whole
numbers
0
1
2
use
primitive
infinite
recursion
generate
list
part4
take
5
wholenumbers
0
1
2
3
4
part4
addonetoall2
take
5
wholenumbers
1
2
3
4
5
fibonaccinumbers
takes
parameters
returns
infinite
list
consists
sequence
fibonacci
numbers
ith
number
fibonacci
sequence
sum
1
th
2
th
number
first
two
numbers
sequence
0
1
use
primitive
infinite
recursion
generate
list
may
find
helper
function
useful
part4
take
10
fibonaccinumbers
0
1
1
2
3
5
8
13
21
34
infinitemerge
takes
two
lists
ints
assumed
infinite
sorted
ascending
order
merges
together
one
infinite
list
sorted
ascending
order
use
primitive
infinite
recursion
generate
list
part4
take
20
infinitemerge
wholenumbers
fibonaccinumbers
0
0
1
1
1
2
2
3
3
4
5
5
6
7
8
8
9
10
11
12
helpful
hints
dealing
infinite
lists
begin
delve
infinite
lists
functions
recurse
infinitely
testing
becomes
issue
approached
somewhat
carefully
example
wholenumbers
function
returns
infinite
list
integers
simply
call
function
interpreter's
prompt
get
infinite
stream
output
cancel
evaluation
function
pressing
stop
button
winhugs
ctrl
one
command
line
hugs
versions
use
pre
existing
functions
take
limit
output
manageable
amount
part
5
using
lazy
evaluation
implement
simpler
iterator
background
previous
assignment
asked
implement
binary
search
tree
class
java
including
iterator
iterator
way
abstract
notion
iterating
elements
collection
possible
iterate
elements
without
know
details
collection
implemented
unfortunately
java
implementation
iterator
quite
painful
write
java
lacks
capability
pause
method
mid
stream
start
later
left
meant
just
write
simple
recursive
tree
traversal
instead
simulate
one
using
stack
pushes
pops
iterator
remember
current
position
traversal
calls
next
haskell's
lazy
evaluation
mechanism
blurs
distinction
traversals
iterators
whereas
java
need
implement
traversals
iterators
separately
haskell
allows
implement
traversal
since
traversal
will
evaluated
lazily
haskell
will
ever
traverse
far
ask
will
able
continue
left
whenever
needs
traverse
farther
task
provided
script
called
bst
hs
contains
haskell
implementation
binary
search
tree
consisting
three
functions
bstadd
bstlookup
bstremove
bst
hs
add
following
two
functions
bottom
script
without
introducing
modifications
provided
portion
bsttolist
takes
bst
parameter
returns
list
tuples
contains
key
value
list
contain
key
value
pairs
ascending
order
keys
bst
bsttolist
bstadd
10
alex
bstadd
5
joe
emptybst
5
joe
10
alex
bst
head
bsttolist
bstadd
10
alex
bstadd
5
joe
emptybst
5
joe
function
can
serve
way
convert
binary
search
tree
list
also
traversal
mechanism
iterator
sounds
crazy
important
remember
effect
lazy
evaluation
second
example
ask
head
resulting
list
haskell
will
build
first
element
list
meaning
traversal
done
bsttolist
will
go
far
minimum
key
tree
stop
bstcount
takes
bst
returns
number
key
value
pairs
stored
implement
function
using
bsttolist
rather
counting
nodes
directly
bst
bstcount
bstadd
10
alex
bstadd
5
joe
emptybst
2
deliverables
must
submit
haskell
scripts
part1
hs
part2
hs
part3
hs
part4
hs
bst
hs
nothing
else
follow
link
discussion
submit
assignment
remember
accept
paper
submissions
assignments
accept
via
email
circumstances
writing
cleaned
new
section
added
alex
thornton
fall
2007
originally
written
alex
thornton
fall
2005
