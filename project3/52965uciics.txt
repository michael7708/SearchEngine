trees processing 

tree
processing
iterative
recursive
introduction
computer
science
ii
ics
22
introduction
lecture
will
continue
study
trees
examining
ordered
binary
search
trees
various
method
processing
methods
useful
storing
collections
trees
discussing
required
ordering
property
will
examine
search
trees
time
proportional
log2n
size
reasonably
perfect
search
tree
will
also
discuss
add
remove
values
tree
finally
will
examine
recursively
traverse
trees
study
three
standard
traversal
orders
applications
ordered
binary
search
trees
bst
binary
tree
quickly
searchable
must
satisfy
simple
ordering
property
value
stored
node
must
greater
value
stored
left
subtree
smaller
value
stored
right
subtree
property
just
true
root
must
true
every
node
tree
trivially
satisfied
leaf
nodes
empty
left
right
subtrees
following
example
illustrates
ordred
binary
search
tree
storing
int
values
constructed
tn
class
defined
previous
lecture
notice
ordering
property
true
node
check
will
abbreivate
trees
just
binary
search
trees
bst
implication
must
adhere
standard
ordering
property
quickly
searchable
tree
fails
ordering
property
means
can
find
specific
node
tree
whose
left
right
child
appropriate
whose
value
ordered
correctly
compared
value
stored
parent
later
lecture
will
learn
another
way
order
values
stored
binary
tree
heap
ordering
requires
every
node
bigger
node
subtree
ordering
property
allow
quick
searching
tree
allow
us
quickly
insert
value
remove
largest
value
two
operations
necessary
implement
priority
queue
efficiently
will
study
heaps
detail
next
lecture
now
understand
multiple
ways
order
trees
standard
ordering
property
useful
need
create
quickly
searchable
binary
trees
throughout
lecture
will
assume
unique
values
stored
bst
two
standard
ways
implement
bsts
identical
values
store
counter
initialized
1
record
often
value
appears
treat
duplicate
value
differently
value
inserting
code
given
stores
duplicate
value
right
value
already
occuring
tree
searching
ordered
binary
search
trees
ordering
property
supplies
us
information
need
search
binary
trees
quickly
decision
telling
whether
stop
search
left
right
subtree
depends
value
stored
node
currently
examining
value
searching
equal
value
node
found
node
value
searching
less
value
node
search
left
subtree
value
searching
greater
value
node
search
right
subtree
law
trichotomy
exactly
one
relationships
must
hold
every
pair
values
tests
easy
perform
primitive
types
using
relational
operators
classes
support
trichotomous
comparisions
typically
implement
comparable
interface
defines
compareto
method
returns
negative
zero
positive
value
distinguish
less
equal
greater
see
string
class
comparator
interface
also
generalize
kidns
comparisons
can
write
methods
implement
searching
algorithm
either
iteratively
examine
one
subtree
recursively
recursively
explore
either
left
right
subtree
never
first
iterative
method
lots
variants
equivalent
one
depending
loop
written
public
static
tn
locate
tn
root
int
tofind
tn
root
null
tofind
value
left
right
tofind
value
return
return
null
next
recursive
method
implement
algorithm
although
method
bit
complicated
write
iterative
one
pattern
recursive
calls
uses
repeated
writing
various
insertion
methods
one
appears
public
static
tn
locate
tn
int
tofind
null
return
null
else
tofind
value
return
else
tofind
value
return
locate
left
tofind
else
return
locate
right
tofind
notice
statement
final
else
test
equality
test
failed
less
test
failed
must
case
law
trichotomy
tofind
greater
value
explicit
test
needed
sometimes
programmers
simplify
method
bit
write
follows
combining
empty
tree
found
cases
public
static
tn
locate
tn
int
tofind
null
tofind
value
return
else
tofind
value
return
locate
left
tofind
else
return
locate
right
tofind
three
methods
traverse
parts
tree
can
possibly
contain
value
searching
moving
one
depth
unequal
comparison
either
reach
node
searching
comparison
empty
null
subtree
can
prove
recursive
method
correct
follows
base
case
empty
tree
method
returns
correct
value
null
found
becuase
values
can
found
empty
tree
recursive
calls
applied
strictly
smaller
tree
least
one
fewer
nodes
least
one
smaller
height
integers
characterize
size
tree
problem
referring
node
can
assume
locate
left
tofind
locate
right
tofind
correctly
return
reference
node
whose
value
tofind
subtrees
now
value
tofind
return
immediately
without
searching
call
method
appropriate
subtree
present
one
ordering
property
contain
tofind
just
return
result
finally
note
worst
case
visit
one
node
every
depth
tree
thus
complexity
class
methods
best
characterized
height
also
note
learned
well
balanced
tree
height
log2size
node
tree
size
complexity
class
searching
log2n
well
balanced
trees
close
perfect
possible
whenever
explore
one
subtree
disregard
sibling
cut
number
nodes
must
search
half
time
descend
tree
thus
binary
search
trees
self
referential
structures
can
search
may
able
search
quickly
sorted
arrays
quickly
unsorted
arrays
linear
linked
lists
now
discuss
build
trees
insertion
insertion
deletion
ordered
binary
search
trees
insert
value
binary
search
tree
follow
similar
process
searching
ultimately
will
insert
value
new
leaf
node
tree
value
found
searching
tree
way
trees
grow
fringes
although
can
write
method
iteratively
certainly
invited
recursive
implementation
much
much
simpler
uses
pattern
similar
generalizing
insertion
linear
linked
lists
review
code
forgotten
able
reproduce
public
static
tn
insert
tn
int
toinsert
null
return
new
tn
toinsert
null
null
else
toinsert
value
left
insert
left
toinsert
else
right
insert
right
toinsert
return
method
replaces
next
insert
next
toinsert
two
calls
equivalent
left
right
subtree
references
call
method
like
root
insert
root
5
similar
searching
tree
method
also
complexity
class
traversing
every
depth
tree
correctly
placing
new
value
insert
also
note
binary
search
tree
ordered
insertion
still
ordered
insertion
new
value
goes
node
etends
tree
exactly
spot
belongs
bst
note
important
fact
many
structurally
different
ordered
binary
search
trees
containing
exactly
values
structure
tree
dictated
order
values
inserted
tree
first
root
rest
depend
root
example
ordered
binary
search
tree
contains
values
one
structurally
different
fact
inserted
values
tree
increasing
order
end
pathological
republican
tree
seen
height
binary
tree
must
least
log2
size
1
1
perfect
trees
size
1
pathological
trees
upcoming
programming
project
will
repeatedly
build
trees
inserting
values
permutation
integers
1
compute
height
eventually
computing
average
height
trees
build
will
double
repeat
process
finally
will
determine
approximate
formula
average
height
tree
nodes
iterative
method
can
use
insert
node
binary
search
tree
already
root
node
case
must
taken
care
specially
method
public
static
void
add
tn
int
toinsert
toinsert
value
left
null
left
new
tn
toinsert
null
null
return
left
else
right
null
right
new
tn
toinsert
null
null
return
right
note
code
value
belongs
left
right
node
must
check
see
nothing
case
add
node
done
something
just
advance
reference
left
right
continue
although
recursive
locate
add
look
similar
iterative
locate
add
quite
different
deleting
value
binary
search
tree
much
complicated
delicate
operation
can
describe
algorithm
fairly
simply
still
complex
difficult
implement
concisely
efficiently
people
can
follow
algorithm
much
easily
java
method
implements
will
focus
algorithm
delete
value
bst
find
node
containing
value
deleted
leaf
remove
make
reference
parent
instead
refer
null
internal
node
one
child
make
reference
parent
instead
refer
directly
child
internal
node
two
children
find
node
containing
either
largest
value
smaller
smallest
value
larger
matter
remove
node
tree
guaranteed
one
child
will
easy
delete
replace
value
original
node
one
delete
value
node
just
deleted
removing
leaf
node
leaves
ordering
property
intact
removing
node
one
child
likewise
nodes
descending
removed
node
compare
parent
way
finally
replace
node
two
children
either
smallest
larger
descendent
biggest
smaller
descendent
descendents
compare
way
thus
removing
node
ordered
binary
tree
leaves
tree
still
obeying
ordering
property
code
two
methods
removing
value
bst
public
static
tn
lift
tn
tn
toremove
right
null
toremove
value
value
return
left
else
right
lift
right
toremove
return
public
static
tn
remove
tn
int
toremove
null
return
null
else
toremove
value
left
null
return
right
else
right
null
return
left
else
left
lift
left
return
else
toremove
value
left
remove
left
toremove
else
right
remove
right
toremove
return
course
expected
know
construct
bst
inserting
values
show
result
removing
value
bst
know
quickly
also
responsible
understanding
able
write
code
searching
insertion
bsts
code
deletion
hand
able
adapt
deleteion
code
works
type
value
instance
variable
traversals
ordered
binary
search
trees
already
covered
searching
values
bsts
inserting
values
bsts
deleting
values
bsts
will
now
discuss
processing
nodes
binary
tree
traversing
tree
generally
will
process
value
node
visit
process
every
value
node's
left
right
subtrees
three
standard
traversal
orders
relating
node's
values
processed
compared
values
subtrees
processed
three
traversal
orders
preorder
process
value
current
node
first
left
right
subtrees
inorder
process
left
subtree
first
value
current
node
right
subtree
postorder
process
left
right
subtrees
first
value
current
node
thus
traversal
order
determined
node's
value
processed
compared
values
subtrees
processed
pre
post
simple
example
suppose
want
visit
every
node
tree
print
values
following
simple
method
preorder
traversal
public
static
void
printpreorder
tn
null
return
else
system
print
value
printpreorder
left
printpreorder
right
inorder
traversal
print
statement
instead
come
recursive
calls
postorder
traversal
print
statement
instead
come
recursive
calls
breadth
first
traversals
process
nodes
one
depth
descending
next
one
simple
recursive
methods
kind
traversal
instead
use
queue
loop
job
public
static
void
printbreadthfirst
tn
abstractqueue
new
linkedqueue
add
isempty
tn
next
tn
remove
cast
object
next
null
system
print
next
value
add
next
left
add
next
right
note
method
many
null
values
get
enqueued
ignored
dequeued
write
slightly
complicated
version
method
avoided
original
bst
order
print
values
using
traversal
order
notice
inorder
traversals
print
node
values
sorted
order
according
ordering
property
also
notice
preorder
traversals
print
node
values
order
inserting
nodes
empty
tree
order
build
original
binary
tree
parents
always
inserted
children
thus
can
write
bst
file
read
rebuild
exactly
binary
tree
will
discuss
standard
uses
postorder
traversals
discuss
evaluating
expression
trees
next
lecture
problem
set
ensure
understand
material
lecture
please
solve
announced
problems
read
lecture
get
stumped
problem
go
back
read
relevant
part
lecture
still
questions
please
get
help
instructor
ta
student
write
int
method
named
min
returns
minimum
value
stored
binary
search
tree
complexity
class
method
write
copy
method
takes
tn
parameter
returns
tn
result
reference
copy
tree
write
boolean
method
named
isbst
returns
whether
tn
parameter
ordered
binary
search
tree
will
need
write
helper
method
tow
check
ordering
property
complexity
class
method
write
method
named
named
niceprint
prints
tn
parameter
nicely
tree
top
handout
prints
82
70
60
50
43
35
30
20
15
8
hint
add
second
parameter
string
amount
space
necessary
print
value
node
right
indentation
complexity
class
method
write
method
called
buildbalancedbst
takes
int
parameter
returns
reference
root
reasonably
well
balanced
bst
hint
write
one
helper
methods
arrays
decomposed
smaller
arrays
pass
two
parameters
specifying
lowest
highest
index
array
process
examine
alternative
bst
show
order
print
values
using
traversal
order
complexity
class
traversal
method
