
continued fraction method 
algorithms
egyptian
fractions
continued
fraction
methods
continued
fraction
method
one
can
derive
good
egyptian
fraction
algorithm
continued
fractions
algorithm
quick
generates
reasonably
terms
uses
fractions
small
denominators
ble72
real
number
can
represented
continued
fraction
1
0
1
1
1
2
1
3
4
values
integers
terminates
finite
sequence
rational
convergents
formed
truncating
sequence
alternately
useful
finding
good
rational
approximations
original
number
instance
famous
approximation
355
113
pi
can
found
convergent
way
successive
convergents
differences
unit
fractions
sequence
differences
gives
something
like
egyptian
fraction
representation
unfortunately
every
fraction
sequence
negative
denotes
ith
convergent
can
define
sequence
secondary
convergents
1
1
ranges
0
1
secondary
convergents
give
increasing
sequence
ranging
1
st
convergent
1
st
convergent
nz80
primary
convergents
successive
secondary
convergents
differ
unit
fraction
interleave
sequence
every
primary
convergent
connected
appropriate
sequences
secondary
convergents
differences
interleaved
sequence
give
egyptian
fraction
representation
first
find
continued
fraction
representation
mathematica
provides
package
continued
fractions
one
must
supply
bound
number
terms
compute
need
want
bound
use
code
order
use
method
continued
fraction
must
odd
number
terms
necessary
replace
last
term
two
terms
1
1
cfnextterm
integer
0
cfnextterm
rational
1
floor
continuedfractionlist
floor
drop
fixedpointlist
cfnextterm
2
cfmakeodd
oddq
length
join
drop
1
last
1
1
next
find
primary
secondary
sequences
unit
fractions
continued
fraction
representations
cfpsaux
cfprimaryseq
transpose
drop
foldlist
cfpsaux
0
1
1
1
cfsecondaryseq
length
3
table
1
2
0
3
1
2
1
join
cfsecondaryseq
drop
2
described
final
representation
formed
hooking
together
secondary
sequences
first
separate
integer
part
input
leave
remaining
fractions
formed
multiplying
pairs
values
secondary
sequence
egyptcontinuedfraction
cfsecondaryseq
cfprimaryseq
cfmakeodd
continuedfractionlist
1
drop
1
drop
1
floor
0
prepend
floor
termination
algorithm
follows
termination
continued
fraction
representation
algorithm
essentially
euclid's
algorithm
integer
gcd's
clear
construction
secondary
sequence
fact
final
result
denominators
products
pairs
numbers
secondary
sequence
fractions
distinct
fact
sum
fractions
original
input
number
straightforward
tedious
exercise
algebraic
manipulation
number
terms
egyptian
fraction
representation
sum
odd
terms
first
continued
fraction
list
fraction
difference
two
secondary
convergents
denominator
fraction
denominator
2
egyptcontinuedfraction
18
23
1
1
1
1
1
2
6
12
36
207
grouped
continued
fraction
method
worst
case
continued
fraction
method
occurs
continued
fraction
representation
three
terms
producing
long
secondary
sequence
case
egyptian
fraction
representation
will
involve
long
sequences
fractions
form
1
1
add
consecutive
values
sequence
get
may
happen
can
simplified
unit
fraction
performing
several
simplifications
reduce
number
terms
overall
representation
also
reduce
denominators
instance
continued
fraction
method
7
15
gives
1
1
1
1
1
1
1
3
15
35
63
99
143
195
1
15
1
35
1
63
1
9
1
99
1
143
1
195
1
45
can
replace
triples
find
shorter
representation
1
1
1
3
9
45
phenomenon
unusual
bleicher
ble72
showed
take
advantage
dramatically
reduce
number
terms
produced
continued
fraction
method
care
required
list
instead
group
last
five
terms
get
1
1
1
3
15
15
egyptian
fraction
representation
implementation
finds
shortest
representations
rather
single
representation
distinct
fractions
return
representations
partition
secondary
sequence
blocks
arithmetic
progressions
find
groupings
separately
within
progression
safe
sum
fractions
one
progression
smaller
half
fraction
previous
progression
within
progression
determine
groups
terms
can
combined
form
unit
fraction
represent
group
edge
graph
labelled
corresponding
unit
fraction
example
graph
eight
vertices
ten
edges
follows
edge
directed
left
right
horizontal
edges
represent
original
terms
produced
continued
fraction
method
longer
edges
represent
groupings
result
unit
fractions
task
becomes
one
finding
shortest
path
graph
restriction
use
two
edges
label
unfortunately
finding
paths
without
repeated
labels
np
complete
efficient
algorithm
subproblem
unlikely
exist
fortunately
time
graphs
repeated
labels
problem
hard
worst
case
use
following
heuristic
increasing
values
find
paths
fewer
edges
filter
paths
repeated
labels
paths
filtered
return
remaining
list
paths
theoretically
fastest
algorithm
listing
short
paths
takes
constant
time
per
path
preprocessing
time
proportional
time
find
single
shortest
path
epp94
however
ease
implementation
use
simpler
method
invented
byers
waterman
bw84
motivation
papers
egyptian
fractions
rather
comparison
dna
protein
sequences
also
turns
equivalent
certain
shortest
path
problem
first
include
code
make
adjacency
matrix
graph
containing
entry
either
fraction
corresponding
edge
graph
empty
set
edge
exists
corresponding
sum
terms
reduce
unit
fraction
input
routine
secondary
sequence
continued
fraction
ecfmakegraph
table
numerator
1
rational
1
length
1
length
next
include
shortest
path
algorithm
takes
input
adjacency
matrix
produces
vector
distances
vertices
last
vertex
vector
needed
bounded
length
path
search
ecfpathlengths
ecfpathlengths
length
1
0
ecfpathlengths
vec
prepend
vec
min
table
infinity
vec
1
1
length
vec
1
ecfpathlengths
1
now
implement
byers
waterman's
algorithm
finding
paths
contain
edges
shortest
path
will
call
algorithm
repeatedly
using
larger
larger
values
find
path
without
repeated
labels
implementation
takes
input
graph
value
vertex
start
number
vertices
vector
distances
produced
first
two
can
omitted
case
supply
appropriate
values
automatically
technique
simply
build
path
one
edge
time
step
compute
value
measuring
amount
path
length
increase
followed
given
edge
instead
keeping
shortest
path
0
shortest
path
edges
subtract
continue
recursively
long
result
nonnegative
ecfboundedpaths
ecfboundedpaths
1
length
ecfpathlengths
ecfboundedpaths
join
table
infinity
1
prepend
ecfboundedpaths
1
next
include
code
removing
list
paths
contain
duplicated
fraction
clear
paths
will
fractions
listed
sorted
order
sort
first
ecfcontainsdupl
true
ecfcontainsdupl
false
ecffilterduplsub
ecfcontainsdupl
ecffilterdupls
join
ecffilterduplsub
reverse
sort
ecfshortfilter
ecfshortfilter
ecfpathlengths
0
ecfshortfilter
ecffilterdupls
ecfboundedpaths
1
length
ecfshortfilter
1
next
function
applies
steps
three
term
continued
fractions
final
algorithm
applies
several
three
term
subsequences
whole
continued
fraction
ecfarithseq
ecfshortfilter
ecfmakegraph
cfsecondaryseq
next
function
takes
two
lists
lists
forms
pairwise
concatenations
one
item
first
list
one
second
obvious
approach
using
outer
join
work
since
outer
interprets
lists
lists
tensors
use
alternate
method
based
distribute
outerjoin
ll
mm
distribute
ll
mm
list
list
list
join
finally
ready
define
overall
modified
continued
fraction
method
breaks
primary
sequence
subsequences
calls
ecfarithseq
one
ecfsecondarypaths
length
3
outerjoin
ecfarithseq
1
2
3
ecfsecondarypaths
drop
2
egyptgroupedcf
ecfsecondarypaths
cfprimaryseq
cfmakeodd
continuedfractionlist
every
step
involves
fixed
number
nested
loops
indices
bounded
length
secondary
sequence
possible
exception
finding
short
repetition
free
path
overall
time
polynomial
numerator
original
rational
number
given
input
hard
see
algorithm
produces
sequences
fractions
formed
grouping
results
continued
fraction
method
sum
sequence
correct
remains
verify
fraction
duplicated
checked
explicitly
within
subsequence
entire
sum
subsequence
less
half
single
fraction
previous
subsequences
two
separate
subsequences
can
produce
duplications
continued
fraction
method
largest
denominator
representation
2
number
terms
still
can
also
analyzed
terms
bleicher
ble72
shows
choosing
prime
gcd
1
log
using
groups
sizes
equal
powers
one
can
find
representation
log
log
log
log
log
log
terms
since
actual
representation
chosen
minimum
length
can
longer
remains
unclear
whether
implementation
really
takes
polynomial
time
whether
can
sufficiently
many
repeated
labels
algorithm
listing
short
paths
list
large
number
paths
slows
exponential
however
practice
method
seems
work
well
bleicher's
method
grouping
can
apparently
done
polynomial
time
egyptgroupedcf
31
311
1
1
1
1
1
11
121
2541
9933
93611
graph
constructed
31
311
complicated
depict
two
paths
length
five
however
one
paths
eliminated
two
copies
label
1
231
hybrid
pairing
continued
fraction
method
can
use
potentially
even
fewer
terms
grouped
continued
fraction
method
expense
possibly
increasing
maximum
denominator
representation
simply
find
shortest
paths
graph
constructed
method
ignoring
possibility
repeated
labels
make
unit
fractions
resulting
representation
distinct
applying
egyptpairlist
eharithseq
ecfboundedpaths
ecfmakegraph
cfsecondaryseq
0
ehsecondarypaths
length
3
outerjoin
eharithseq
1
2
3
ehsecondarypaths
drop
2
egypthybrid
egyptpairlist
ehsecondarypaths
cfprimaryseq
cfmakeodd
continuedfractionlist
method
uses
log
log
log
log
terms
represent
number
following
example
see
representations
corresponding
shortest
paths
graph
constructed
31
311
egypthybrid
31
311
1
1
1
1
1
11
116
9933
26796
93611
1
1
1
1
1
11
121
2541
9933
93611
egyptian
fractions
number
theory
david
eppstein
ics
uc
irvine
formatted
nb2html
filter
last
update
09
sep
1996
16
24
43
pdt
