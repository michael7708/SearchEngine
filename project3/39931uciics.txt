
jordan sorting 
callahan
condor
cs
jhu
edu
paul
callahan
newsgroups
comp
theory
subject
jordan
sorting
splay
trees
conjecture
date
12
aug
1995
13
40
08
0400
organization
johns
hopkins
university
cs
department
jordan
sorting
problem
sorting
list
numbers
coordinate
assuming
numbers
represent
intersections
non
self
intersecting
jordan
curve
axis
given
order
appear
along
curve
known
decade
far
research
determined
jordan
sorting
can
performed
linear
time
curious
following
conjecture
given
paper
presents
linear
time
algorithm
reference
given
second
remark
may
much
simpler
way
sort
jordan
sequences
linear
time
merely
insert
items
sequence
one
time
splay
tree
access
sorted
order
basis
sleator
tarjan's
dynamic
optimality
conjecture
conjecture
sorts
jordan
sequences
time
sorting
jordan
sequences
linear
time
using
level
linked
search
trees
hoffman
mehlhorn
rosensteihl
tarjan
information
control
68
1986
pp
170
184
several
later
papers
claim
present
simpler
algorithms
recent
one
seen
1990
still
nearly
simple
approach
using
splay
trees
curious
conjecture
treated
either
theoretically
experimentally
theoretical
perspective
one
think
conjecture
true
least
easier
prove
dynamic
optimality
conjecture
still
pretty
interesting
result
strikes
even
attractive
experimental
issue
though
existing
code
splay
trees
random
jordan
sequences
hard
generate
course
leaves
open
issue
generating
hard
cases
jordan
sorting
sense
excuse
performing
experiment
literature
search
far
exhaustive
experimental
results
much
appreciate
reference
seems
conjecture
actually
true
one
perhaps
make
careful
study
splay
tree
algorithm
jordan
sorting
try
infer
achieve
good
results
provide
non
trivial
linear
time
algorithm
sense
exists
nature
rather
consequence
clever
design
true
strikes
people
hope
quite
remarkable
despite
fact
better
known
optimal
algorithm
paul
callahan
callahan
cs
jhu
edu
first
principle
science
invent
something
nice
look
decide
can
rowland
emett
callahan
biffvm
cs
jhu
edu
paul
callahan
newsgroups
comp
theory
subject
family
jordan
sequences
splay
sort
omega
log
date
25
sep
1995
14
13
09
0400
organization
johns
hopkins
university
cs
department
month
half
ago
posted
inquiry
conjecture
related
sorting
jordan
sequences
jordan
sequence
list
intersections
non
self
intersecting
plane
curve
axis
jordan
sequence
sorting
problem
sort
intersections
coordinate
non
crossing
curve
restriction
implies
number
jordan
sequences
values
rather
implying
general
purpose
comparison
based
sorting
algorithm
may
optimal
fact
known
decade
jordan
sequences
can
sorted
time
using
comparisons
emphasize
point
comparisons
avoid
getting
mired
msd
radix
sort
flame
war
now
progress
anyway
appealing
conjecture
two
papers
presenting
linear
time
algorithms
information
control
68
170
184
1986
information
processing
letters
35
85
92
1990
values
jordan
sequence
simply
inserted
splay
tree
read
sorted
order
might
also
require
time
worst
case
general
technique
usually
called
splay
sort
can
certain
kinds
input
shown
require
much
less
time
worst
case
optimal
comparision
based
sort
mergesort
understand
jordan
sequence
conjecture
correctly
can
show
incorrect
know
following
result
new
fairly
specialized
seem
lead
anywhere
posting
wondering
month
posting
formal
publication
going
leave
steps
hard
fill
details
first
prove
lower
bound
sorting
sequence
using
splay
sort
will
suffice
prove
lower
bound
algorithm
uses
insertions
binary
search
tree
using
rotation
strategy
fact
general
kind
lower
bound
often
easier
prove
lower
bound
splay
sort
owing
work
robert
wilber
focs
'86
revised
version
siam
comp
vol
18
1
provides
two
powerful
methods
showing
lower
bounds
accessing
sequences
values
binary
search
trees
will
really
need
methods
corollary
accessing
nodes
binary
tree
containing
values
0
1
2
1
bit
reversed
order
taking
binary
representations
values
increasing
order
reversing
significance
bits
requires
omega
2
rotations
following
going
use
claim
sorting
sequence
inserting
binary
tree
hard
accessing
sequence
tree
containing
values
proved
seems
time
value
inserted
new
leaf
added
null
pointer
one
imagine
value
already
existed
node
tree
previously
accessed
thus
possible
construct
initial
tree
containing
values
sorted
rotation
sequence
whether
one
inserting
intially
empty
tree
accessing
initally
full
tree
originally
complicated
idea
proof
require
claim
think
true
results
cleaner
argument
now
remains
simply
construct
family
hard
jordan
sequences
value
sequence
family
containing
least
elements
happens
sequences
family
will
bear
relationship
bit
reversed
order
will
cause
require
omega
log
rotations
sort
using
binary
search
tree
according
result
wilber
first
give
intuitive
explanation
sequences
come
one
take
looped
flattened
strip
paper
view
facing
edge
look
like
simple
jordan
curve
unfortunately
ascii
graphics
make
unclear
let
repeat
viewed
edge
might
also
appear
folded
double
thickness
get
another
jordan
curve
somewhat
convoluted
can
repeat
doubling
process
many
times
like
time
doubling
number
intersections
curve
vertical
line
larger
examples
becomes
convenient
represent
shape
curve
using
two
sets
matching
parentheses
representation
normally
used
prove
bound
number
jordan
sequences
double
two
times
rotate
90
degrees
curve
intersects
axis
obtain
matching
parentheses
top
sequence
arcs
bottom
sequence
arcs
gives
us
actual
curve
connect
idea
bit
reversed
order
will
describe
folding
process
transformation
sequence
numbers
will
denote
actual
jordan
sequence
question
correspondence
folding
hard
see
will
omitted
since
really
needed
obtain
final
form
construction
first
original
loop
sequence
intersections
curve
intersecting
line
denote
sequence
0
1
now
given
sequence
obtain
next
doubled
sequence
follows
1
double
number
sequence
2
append
new
sequence
reverse
3
add
1
every
odd
positioned
number
sequence
leftmost
position
considered
even
0
1
0
2
1
0
2
2
0
2
0
3
2
1
3
0
3
2
1
0
6
4
2
0
6
4
2
2
4
6
0
0
7
4
3
2
5
6
1
0
7
4
3
2
5
6
1
0
14
8
6
4
10
12
2
0
14
8
6
4
10
12
2
2
12
10
4
6
8
14
0
0
15
8
7
4
11
12
3
2
13
10
5
6
9
14
1
etc
resort
proof
example
simply
point
take
increasing
sequence
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
connect
pairs
numbers
adjacent
sequence
obtained
process
non
crossing
arcs
also
connecting
end
values
0
1
will
obtain
jordan
curve
determined
set
matching
parentheses
given
earlier
recall
lower
bound
want
connect
way
bit
reversed
order
yet
another
way
obtain
sequence
define
following
function
bit
binary
numbers
denoted
1
0
following
assume
denotes
exclusive
let
b0
1
0
1
0
2
0
1
0
words
reverse
order
bits
1
1
keeping
0
position
also
1
invert
bits
1
1
0
000
000
001
111
010
100
011
011
100
010
101
101
110
110
111
001
now
get
kth
sequence
determined
process
given
previously
merely
take
values
0
2
1
expressed
binary
apply
function
increasing
order
overload
meaning
denote
result
converting
binary
string
applying
converting
back
integer
can
seen
table
sequence
3
0
7
4
3
2
5
6
1
corresponds
obtained
previously
imagine
lot
readers
newsgroup
find
examples
convincing
matter
large
nicely
work
fortunately
function
defined
suffices
show
sequence
0
1
2
1
jordan
sequence
easier
task
showing
corresponds
particular
jordan
sequences
illustrated
earlier
necessary
show
numbers
0
1
2
1
written
order
left
right
adjacent
numbers
sequence
0
1
2
1
can
connected
non
crossing
arcs
alternating
list
numbers
key
observation
needed
proof
two
arcs
one
another
cross
long
cross
set
arcs
can
put
1
equivalence
classes
according
crossing
within
equivalence
class
second
observation
can
used
exclude
crossings
arcs
distinct
equivalence
classes
writing
rigorous
article
now
say
something
like
lemma
0
sequence
0
1
2
1
jordan
sequence
followed
proof
left
exercise
remains
show
requires
omega
2
comparisons
sort
sequence
using
splay
sort
can
seen
considering
even
let
denote
result
reversing
order
bits
binary
representation
definition
know
even
values
2
2
subsequence
0
2
2
2
must
bit
reversed
order
since
sequence
0
1
2
1
contains
2
1
elements
bit
reversed
order
result
wilber
implies
time
access
sequence
binary
search
tree
omega
1
2
1
also
provides
bound
time
sort
sequence
using
splay
sort
follows
exists
value
one
can
construct
jordan
sequence
length
greater
requires
log
comparisons
sort
using
splay
sort
refuting
conjecture
understood
splay
sort
linear
time
algorithm
sorting
jordan
sequences
paul
callahan
callahan
cs
jhu
edu
first
principle
science
invent
something
nice
look
decide
can
rowland
emett
rew
lightstone
com
bob
wilber
pumice
newsgroups
comp
theory
subject
re
jordan
sequences
splay
sort
omega
log
date
27
sep
1995
15
57
48
0500
organization
utexas
mail
news
gateway
paul
callahan
showed
bit
reversal
permutation
can
imbedded
jordan
sequence
following
going
use
claim
sorting
sequence
inserting
binary
tree
hard
accessing
sequence
tree
containing
values
proved
seems
time
value
inserted
new
leaf
added
null
pointer
one
imagine
value
already
existed
node
tree
previously
accessed
thus
possible
construct
initial
tree
containing
values
sorted
rotation
sequence
whether
one
inserting
intially
empty
tree
accessing
initally
full
tree
crux
matter
can
lower
bound
1
used
get
omega
log
lower
bound
jordan
sorting
via
insertion
symmetrically
ordered
binary
tree
lower
bound
assumed
elements
tree
start
accessed
specified
order
allowing
rotations
tree
insertions
deletions
done
originally
complicated
idea
proof
require
claim
think
true
results
cleaner
argument
believe
claim
false
think
lower
bound
can
patched
work
case
consider
jordan
sorting
binary
tree
proceeds
first
traverse
simple
closed
curve
time
encounter
intersection
axis
insert
intersection
point
binary
tree
symmetrically
ordered
coordinate
second
access
items
tree
order
coordinate
end
first
pass
items
sorted
coordinate
second
pass
accesses
nodes
sequential
order
pass
takes
linear
time
including
splay
algorithm
used
accessing
proved
tarjan
2
lower
bound
must
applied
first
pass
items
inserted
find
convenient
reverse
film
items
inserted
tree
sequential
order
coordinate
linear
time
deleted
order
appear
curve
deleted
according
jordan
sequence
want
show
deletion
phase
takes
log
time
need
extend
model
allow
deletions
think
following
definition
covers
cases
definition
standard
deletion
node
can
occur
one
child
case
children
leaf
simply
removed
otherwise
removed
v's
child
made
child
v's
parent
root
made
root
root
general
delete
node
sequence
rotations
one
child
standard
deletion
example
recall
deletion
node
splay
tree
proceeds
follows
1
splayed
root
removed
leaving
left
right
subtrees
2
largest
node
splayed
root
3
made
right
subtree
can
cast
standard
model
follows
1
splayed
root
left
subtree
2
largest
node
splayed
root
making
left
child
3
rotated
4
left
child
standard
deletion
done
clearly
complexity
usual
deletion
routine
model
delete
must
also
count
cost
accessing
root
order
fold
costs
rotations
require
algorithm
normalized
deleting
node
first
rotates
node
root
can
always
done
without
increasing
time
constant
factor
original
algorithm
standard
deletion
node
depth
first
rotatate
root
rotate
back
using
2d
2
rotations
delete
cost
extra
rotations
just
constant
times
cost
following
path
root
likewise
look
always
done
rotating
root
two
lower
bound
methods
given
1
will
patch
first
one
methods
give
omega
log
bound
accessing
bit
reversal
permutation
important
understand
intuition
behind
lower
bounds
items
access
get
way
items
want
access
later
must
rotated
can
delete
nodes
can
sometimes
get
node
way
deleting
might
cheaper
forcing
several
nodes
underneath
rotate
ability
shrink
tree
go
might
invalidate
lower
bounds
given
1
quick
review
first
lower
bound
method
binary
search
tree
whose
nodes
may
considered
consecutive
integers
allow
rotations
standard
deletions
lower
bound
tree
2n
1
nodes
constructed
whose
leaves
initial
nodes
whose
internal
nodes
lie
nodes
may
taken
half
integers
changes
rotations
deletions
fixed
getting
lower
bound
bit
reversal
permutation
taken
balanced
binary
tree
sequence
nodes
accessed
1
2
node
accessed
either
look
delete
cases
node
must
rotated
root
normalized
algorithm
given
numbers
subsequence
consisting
interval
internal
node
score
computed
follows
let
minimum
maximum
leaves
subtree
rooted
let
s'
let
m'
length
s'
1
m'
s'
s'
1
s'
s'
1
counts
many
times
subsequence
s'
hops
left
subtree
right
subtree
vice
versa
sum
's
lower
bound
number
rotations
must
done
access
sequence
deletions
done
key
part
argument
1
point
access
access
1
rotation
node
node
furthermore
rotation
affect
generalized
subtrees
corresponding
leaves
u's
left
right
subtrees
already
counted
scores
u's
children
see
1
definition
generalized
subtree
suppose
now
allow
standard
deletions
example
root
1
right
child
left
child
accessing
can
access
1
simply
deleting
rotations
done
one
might
try
fix
counting
deletions
nodes
score
work
deletions
doubled
counted
u's
children
words
either
affected
deletion
node
fix
lower
bound
note
even
deleted
case
access
access
1
going
rotation
node
node
use
first
rotation
access
causes
ancestor
standard
deletion
can
cause
happen
given
sequence
length
say
1
end
access
either
1
else
1
end
access
j1
j2
j1
j2
intuitively
end
accesses
nodes
can
get
way
deletion
modify
score
follows
l'
1
s'
s'
1
s'
s'
1
end
access
subsequence
s'
now
lower
bound
goes
using
l'
rather
count
rotation
1
else
1
bit
reversal
permutation
convenient
index
sequence
0
bit
reversal
bit
reversal
sequence
bits
easy
show
1
end
accesses
elements
equal
2
1
0
score
assigned
node
j'th
level
lower
bound
tree
whose
subsequence
bit
reversal
permutation
bits
l'
2
1
1
j'th
level
2
nodes
summing
scores
get
2
2
2
4
2
4
1
2
gives
omega
log
lower
bound
algorithm
sorts
jordan
sequence
inserting
elements
binary
tree
maintained
via
rotations
requires
log
time
note
single
internal
node
lower
bound
tree
subtracting
end
accesses
can
cause
radical
reduction
u's
score
example
subsequence
10
5
1
20
2
19
3
18
4
17
5
16
6
15
7
14
8
13
9
12
10
11
19
l'
0
indeed
nodes
following
zig
zag
binary
tree
1
20
2
19
3
can
accessed
stated
order
solely
standard
deletions
rotations
question
sequences
nodes
lower
bound
accessing
deletions
lower
bound
accessing
without
deletions
sequence
will
need
many
end
accesses
many
subsequences
1
wilber
lower
bounds
accessing
binary
search
trees
rotations
siam
computing
18
1
1989
pp
56
67
2
tarjan
sequential
access
splay
trees
takes
linear
time
combinatorica
5
1985
pp
367
378
rew
lightstone
com
bob
wilber
pumice
newsgroups
comp
theory
subject
re
2
jordan
sequences
splay
sort
log
date
1
oct
1995
13
28
32
0500
organization
utexas
mail
news
gateway
statement
made
last
post
needs
correction
clarification
paul
callahan
said
following
going
use
claim
sorting
sequence
inserting
binary
tree
hard
accessing
sequence
tree
containing
values
proved
seems
time
value
inserted
new
leaf
added
null
pointer
one
imagine
value
already
existed
node
tree
previously
accessed
thus
possible
construct
initial
tree
containing
values
sorted
rotation
sequence
whether
one
inserting
intially
empty
tree
accessing
initally
full
tree
originally
complicated
idea
proof
require
claim
think
true
results
cleaner
argument
said
believe
claim
false
clear
model
insertion
callahan
mind
nodes
always
inserted
leaves
appropriate
part
tree
case
claim
easily
proven
true
starting
empty
tree
carry
sequence
rotations
insertions
new
leaves
nodes
inserted
creating
tree
now
carry
sequence
backward
starting
except
delete
leaf
backwards
version
inserting
instead
leave
node
place
mark
deleted
subsequent
rotations
backwards
sequence
involve
marked
leaves
furthermore
leaves
marked
deleted
stay
fringe
tree
never
case
marked
leaf
unmarked
leaf
child
backward
sequence
rotations
can
carried
final
tree
nodes
marked
tree
satisfies
claim
mind
general
model
insertion
namely
reverse
standard
deletions
general
type
insertion
claim
appears
false
standard
insertion
node
tree
defined
follows
1
let
largest
node
let
smallest
node
now
assume
neither
smaller
every
node
bigger
every
node
2
either
ancestor
ancestor
assume
former
let
0
1
2
path
1
right
child
1
left
child
1
node
can
made
child
one
made
child
right
child
otherwise
left
child
left
child
given
1
right
child
unless
case
leaf
3
less
every
node
can
either
make
root
right
subtree
can
insert
left
child
nodes
along
leftmost
path
similarly
greater
every
node
4
cost
standard
insertion
cost
following
path
root
inserted
note
argument
used
prove
callahan's
claim
insertions
leaves
work
general
type
insertion
marked
nodes
might
left
middle
tree
unmarked
nodes
children
can
make
subsequent
rotations
reverse
sequence
invalid
trivial
emulate
splay
tree
insertion
means
rotations
standard
insertion
change
cost
operation
see
way
emulate
splay
tree
insertion
rotations
insertion
leaf
retaining
original
cost
patched
lower
bound
previous
post
seems
necessary
able
claim
splay
sort
bit
reversal
permutation
jordan
sequence
requires
log
time
callahan
biffvm
cs
jhu
edu
paul
callahan
newsgroups
comp
theory
subject
re
re
2
jordan
sequences
splay
sort
log
date
2
oct
1995
11
49
20
0400
organization
johns
hopkins
university
cs
department
article
06edc080
lightstone
com
bob
wilber
pumice
rew
lightstone
com
wrote
statement
made
last
post
needs
correction
clarification
clear
model
insertion
callahan
mind
nodes
always
inserted
leaves
appropriate
part
tree
case
claim
easily
proven
true
mind
general
model
insertion
namely
reverse
standard
deletions
general
type
insertion
claim
appears
false
ok
point
considered
guess
things
bit
complicated
hoped
mentioned
backup
argument
relied
different
claim
seemed
clear
time
namely
insert
element
binary
tree
one
must
access
either
successor
predecessor
symmetric
order
now
bring
issue
general
insertions
even
latter
claim
seems
less
clear
true
case
leaf
insertions
one
must
link
node
directly
either
successor
predecessor
however
still
hold
one
certify
node
inserted
correct
place
without
seen
successor
predecessor
least
assuming
extra
information
maintained
tree
anyway
instead
bounding
rotations
beginning
can
simply
ignore
cost
inserting
first
half
bit
reversed
sequence
even
valued
elements
bound
cost
inserting
remaining
odd
valued
elements
find
cost
accessing
sequence
successors
predecessors
elements
think
omega
log
since
poster
seems
patched
argument
satisfaction
probably
need
especially
correspondence
name
author
one
cited
papers
coincidental
actually
brings
another
unstated
assumption
use
cost
accessing
subsequence
2
elements
list
elements
bit
reversed
order
omega
log
surprised
true
know
best
way
proving
clearly
sequences
hard
access
contain
easy
subsequence
length
2
intuitively
looks
like
subsequence
bit
reversed
permutation
property
breaking
kind
locality
reference
needed
obtain
log
rotations
appreciate
insight
suspect
machinery
needed
lower
bound
bit
reversed
sequences
sufficient
maybe
simpler
argument
paul
callahan
callahan
cs
jhu
edu
first
principle
science
invent
something
nice
look
decide
can
rowland
emett
rew
lightstone
com
bob
wilber
pumice
newsgroups
comp
theory
subject
re
jordan
sequences
splay
sort
log
date
3
oct
1995
14
34
15
0500
organization
utexas
mail
news
gateway
wrote
mind
general
model
insertion
namely
reverse
standard
deletions
general
type
insertion
claim
appears
false
paul
callahan
wrote
ok
point
considered
guess
things
bit
complicated
hoped
mentioned
backup
argument
relied
different
claim
seemed
clear
time
namely
insert
element
binary
tree
one
must
access
either
successor
predecessor
symmetric
order
now
bring
issue
general
insertions
even
latter
claim
seems
less
clear
true
case
leaf
insertions
one
must
link
node
directly
either
successor
predecessor
however
still
hold
one
certify
node
inserted
correct
place
without
seen
successor
predecessor
least
assuming
extra
information
maintained
tree
well
brings
issue
arises
sort
lower
bound
right
model
inserting
node
tree
contains
immediate
predecessor
immediate
successor
arguable
one
charge
cost
finding
order
certify
inserted
legal
spot
call
two
nodes
bounds
instead
standard
insertions
charge
cost
following
path
root
newly
inserted
node
reasons
choosing
cost
model
follows
1
symmetry
cost
standard
insertion
cost
standard
deletion
node
time
reversed
sequence
clear
deleting
node
necessary
charge
finding
bounds
2
generality
generous
cost
model
one
charges
finding
bounds
lower
bound
obtained
cost
model
will
apply
broader
class
algorithms
principle
algorithm
need
look
bounds
example
store
minimum
maximum
values
entire
tree
addition
store
non
root
node
minimum
value
subtree
root
right
child
parent
maximum
value
subtree
root
left
child
parent
values
can
verify
validity
insertion
look
far
child
node
inserted
values
can
maintained
constant
time
rotations
example
left
child
right
child
rotated
gets
z's
old
extremum
value
either
minimum
maximum
gets
y's
old
minimum
gets
x's
old
maximum
standard
deletion
insertion
done
cost
making
required
updates
extrema
can
charged
cost
following
path
root
inserted
deleted
node
balanced
search
tree
algorithms
need
sort
extra
information
tree
example
red
black
trees
need
bit
per
node
tells
whether
red
black
splay
trees
unusual
extra
information
storing
one
extra
value
node
overhead
search
algorithms
seems
arbitrary
reject
hand
algorithms
might
less
costly
way
avoid
looking
bounds
3
simplicity
charge
finding
bounds
figure
bounds
highly
regular
sequence
like
bit
reversal
permutation
easy
general
might
harder
counting
end
accesses
anyway
instead
bounding
rotations
beginning
can
simply
ignore
cost
inserting
first
half
bit
reversed
sequence
even
valued
elements
bound
cost
inserting
remaining
odd
valued
elements
find
cost
accessing
sequence
successors
predecessors
elements
think
omega
log
well
yes
inserting
node
charge
accessing
bounds
believe
works
second
half
bit
reversal
permutation
br
2
br
2
1
br
1
nodes
accessed
bounds
br
2
bounds
br
2
1
bounds
br
1
can
extract
subsequence
br
0
br
1
br
2
1
takes
omega
log
time
access
complicating
factor
proceed
nodes
inserted
tree
just
accesses
think
affects
validity
lower
bound
proofs
sufficient
establish
bound
splay
sorting
since
splay
insertion
fact
access
bounds
since
poster
seems
patched
argument
satisfaction
probably
need
especially
correspondence
name
author
one
cited
papers
coincidental
probability
two
people
name
looking
problem
low
actually
brings
another
unstated
assumption
use
cost
accessing
subsequence
2
elements
list
elements
bit
reversed
order
omega
log
surprised
true
know
best
way
proving
thought
self
evident
suppose
can
access
sequence
1
2
time
algorithm
also
accesses
subsequence
1
2
time
just
ignore
accesses
care
lower
bound
accessing
subsequence
necessarily
lower
bound
accessing
full
sequence
callahan
condor
cs
jhu
edu
paul
callahan
newsgroups
comp
theory
subject
re
jordan
sequences
splay
sort
log
date
3
oct
1995
17
23
32
0400
organization
johns
hopkins
university
cs
department
article
0718e6e0
lightstone
com
bob
wilber
pumice
rew
lightstone
com
wrote
thought
self
evident
suppose
can
access
sequence
1
2
time
algorithm
also
accesses
subsequence
1
2
time
just
ignore
accesses
care
lower
bound
accessing
subsequence
necessarily
lower
bound
accessing
full
sequence
actually
meant
bound
also
hold
direction
bit
reversed
sequences
want
show
lower
bound
full
bit
reversed
sequence
within
constant
lower
bound
subsequence
containing
half
elements
sequences
hold
example
interleave
bit
reversed
sequence
sequence
increasing
order
full
sequence
requires
omega
log
rotations
access
contains
subsequence
one
increasing
order
requires
rotations
claiming
bit
reversed
sequence
contain
easy
sequence
subsequence
true
paul
callahan
callahan
cs
jhu
edu
first
principle
science
invent
something
nice
look
decide
can
rowland
emett
rew
lightstone
com
bob
wilber
pumice
newsgroups
comp
theory
subject
re
jordan
sequences
splay
sort
log
date
4
oct
1995
11
59
49
0500
organization
utexas
mail
news
gateway
actually
meant
bound
also
hold
direction
bit
reversed
sequences
want
show
lower
bound
full
bit
reversed
sequence
within
constant
lower
bound
subsequence
containing
half
elements
sequences
hold
example
interleave
bit
reversed
sequence
sequence
increasing
order
full
sequence
requires
omega
log
rotations
access
contains
subsequence
one
increasing
order
requires
rotations
claiming
bit
reversed
sequence
contain
easy
sequence
subsequence
true
suspect
proof
however
need
strong
claim
proof
work
look
proof
accessing
bit
reversal
permutation
length
via
binary
search
tree
algorithm
requires
log
time
0
insert
initially
empty
tree
bit
reversal
permutation
bits
2
elements
want
show
inserting
last
2
elements
requires
accessing
2
nodes
already
tree
bit
reversal
order
fix
4
br
2
0001
inserted
must
access
lower
bounds
0001
namely
lower
0000
0010
higher
two
nodes
ancestor
lower
actually
visit
free
charge
accessing
either
one
charge
acessing
0000
insert
br
2
1
1001
must
access
1000
1010
charge
1000
insert
br
2
1
0101
must
access
0100
0110
charge
0100
sequence
accesses
charge
0000
1000
0100
1100
1110
full
bit
reversal
permutation
1
bits
k'th
bit
fixed
0
missing
elements
takes
2
log
2
omega
log
time
lower
bound
applied
complete
bit
reversal
permutation
arbitrary
subsequence
bit
reversal
permutation
