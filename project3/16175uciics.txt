fibonacci numbers 
introduction fibonacci numbers 
ics
161
design
analysis
algorithms
lecture
notes
january
9
1996
introduction
analysis
algorithms
algorithm
just
outline
idea
behind
program
express
algorithms
pseudo
code
something
resembling
pascal
statements
english
rather
within
programming
language
expected
one
translate
pseudo
code
statement
small
number
lines
actual
code
easily
mechanically
class
covers
design
algorithms
various
types
problems
well
mathematical
analysis
algorithms
done
independently
actual
computational
experiments
purpose
design
algorithms
obvious
one
needs
algorithm
order
write
program
analysis
algorithms
less
obviously
necessary
several
purposes
analysis
can
reliable
experimentation
experiment
know
behavior
program
certain
specific
test
cases
analysis
can
give
us
guarantees
performance
inputs
helps
one
choose
among
different
solutions
problems
will
see
can
many
different
solutions
problem
careful
analysis
comparison
can
help
us
decide
one
best
purpose
without
requiring
implemented
tested
can
predict
performance
program
take
time
write
code
large
project
waited
code
written
discover
something
runs
slowly
major
disaster
analysis
first
time
discover
speed
problems
work
around
analyzing
algorithm
gain
better
understanding
fast
slow
parts
work
work
around
order
speed
fibonacci
numbers
introduce
algorithms
via
toy
problem
computation
fibonacci
numbers
one
probably
need
actually
solve
simple
enough
easy
understand
maybe
surprising
many
different
solutions
fibonacci
story
leonardo
pisa
aka
fibonacci
interested
many
things
including
subject
now
know
population
dynamics
instance
quickly
population
rabbits
expand
appropriate
conditions
typical
mathematics
analysis
algorithms
form
mathematics
make
problem
abstract
get
idea
general
features
without
getting
lost
detail
assume
pair
rabbits
pair
children
every
year
children
young
children
two
years
later
rabbits
never
die
last
assumption
sounds
stupid
makes
problem
simpler
analyzed
simpler
version
go
back
add
assumption
rabbits
die
ten
years
change
overall
behavior
problem
much
express
number
pairs
rabbits
function
time
measured
number
years
since
start
experiment
1
1
start
one
pairf
2
1
young
children
first
yearf
3
2
second
year
pair
childrenf
4
3
third
year
another
pairf
5
5
get
first
set
grandchildren
general
1
2
previous
rabbits
still
1
plus
get
one
pair
children
every
pair
rabbits
two
years
ago
2
algorithmic
problem
look
today
compute
formulas
floating
point
probably
saw
math
6a
1
1
1
sqrt
5
2
1
618
golden
ratio
solution
often
used
standard
example
method
generating
functions
seems
algorithm
compute
1
618
0
618
problem
accurately
know
get
right
answer
just
use
1
618
get
3
1
99992
close
enough
2
16
986
698
round
987
18
2583
1
2584
instead
since
defined
integers
saves
problems
stick
integers
recursive
algorithm
original
formula
seems
give
us
natural
example
recursion
algorithm
1
int
fib
int
2
return
1
else
return
fib
1
fib
2
example
sort
basic
question
study
class
much
time
algorithm
take
measure
time
natural
measure
seconds
nice
answer
change
every
time
intel
came
faster
processor
can
measure
time
terms
machine
instructions
dividing
machine's
speed
instructions
second
give
actual
time
want
however
hard
guess
piece
pseudo
code
exact
number
instructions
particular
compiler
generate
get
rough
approximation
try
measuring
terms
lines
code
call
fib
returns
either
one
two
lines
2
execute
one
line
return
3
execute
2
fib
2
plus
one
fib
1
fib
0
4
like
rabbits
except
two
lines
call
time
sum
times
two
smaller
recursive
calls
time
2
time
1
time
2
general
recursive
algorithm
one
gives
us
recurrence
relation
time
routine
time
within
routine
plus
time
recursive
calls
gives
easy
mechanical
way
equation
like
one
can
solve
find
formula
time
case
recurrence
relation
similar
definition
fibonacci
numbers
work
can
solve
equation
least
terms
think
recursion
forming
tree
draw
one
node
root
tree
first
call
time
routine
calls
draw
another
child
tree
5
4
3
3
2
2
1
2
1
four
internal
nodes
tree
fib
5
take
two
lines
five
leaves
take
one
line
total
number
lines
executed
recursive
calls
13
note
call
fib
fibonacci
number
internal
node
just
number
leaves
node
total
number
leaves
tree
just
remember
leaves
count
one
line
code
internal
nodes
2
count
internal
nodes
use
basic
fact
binary
trees
trees
node
2
children
number
internal
nodes
always
equals
number
leaves
minus
one
can
prove
induction
true
one
leaf
internals
stays
true
add
2
children
leaf
lines
executed
leaves
2f
2
internal
nodes
total
3f
2
double
check
simple
example
time
5
3f
5
2
3
5
2
13
kind
slow
45
takes
billion
steps
maybe
can
faster
dynamic
programming
one
idea
reason
slow
slow
keep
recomputing
subproblems
instance
tree
shows
two
computations
3
second
time
get
3
wasting
effort
computing
already
solved
answer
going
change
instead
solve
subproblem
look
solution
later
need
instead
repeatedly
recomputing
easy
idea
leads
complicated
algorithms
see
later
section
dynamic
programming
pretty
simple
algorithm
2
int
fib
int
int
1
1
2
1
int
3
1
2
return
iterative
algorithm
one
uses
loops
instead
recursion
analyze
little
differently
recursive
algorithm
basically
just
compute
line
many
times
line
executed
looking
loops
many
times
loop
executed
three
lines
executed
always
first
line
loop
executed
1
times
except
1
second
line
loop
executed
2
times
except
1
time
1
2
3
2n
except
time
1
4
example
45
takes
90
steps
roughly
10
million
times
faster
program
even
often
big
enough
difference
notice
second
algorithm
much
better
first
space
complexity
running
time
thing
care
thing
can
analyzed
mathematically
programmer
time
code
length
important
discuss
part
subject
software
engineering
however
will
often
analyze
amount
memory
used
program
program
takes
lot
time
can
still
run
just
wait
longer
result
however
program
takes
lot
memory
may
able
run
important
parameter
understand
analyze
things
differently
recursive
iterative
programs
iterative
program
usually
just
matter
looking
variable
declarations
storage
allocation
calls
malloc
instance
algorithm
2
declares
array
numbers
analysis
recursive
program
space
complicated
space
used
time
total
space
used
recursive
calls
active
time
recursive
call
algorithm
1
takes
constant
amount
space
space
local
variables
function
arguments
also
space
remembering
call
return
calls
active
one
time
form
path
tree
drew
earlier
argument
node
path
one
two
units
smaller
argument
parent
length
path
can
space
needed
recursive
algorithm
constant
factor
times
abbreviate
constant
factor
times
using
notation
turns
algorithm
2
can
modified
use
much
smaller
amount
space
step
loop
uses
previous
two
values
instead
storing
values
array
can
simply
use
two
variables
requires
swapping
around
values
everything
stays
appropriate
places
algorithm
3
int
fib
int
int
1
1
int
3
int
return
represents
represents
1
represents
2
two
extra
assignments
sum
shift
values
preparation
next
iteration
algorithm
uses
roughly
4n
lines
compute
slower
algorithm
2
uses
much
less
space
big
notation
better
algorithms
fibonacci
numbers
investigate
take
side
track
make
analysis
little
abstract
problem
analysis
two
algorithms
line
code
use
whitespace
break
line
two
change
program
speed
change
number
lines
executed
mentioned
buy
faster
computer
change
program
speed
change
analysis
avoid
extraneous
details
like
whitespace
computer
type
use
big
notation
idea
already
write
times
function
big
notation
treats
two
functions
roughly
one
times
constant
something
depend
instance
replace
3f
2
2n
4n
formally
say
constant
true
4n
also
true
4n
however
note
always
symmetric
relation
true
practice
will
usually
use
notation
simplify
formulas
ignoring
constant
factors
extraneous
details
point
notation
first
makes
life
easier
allowing
us
less
careful
fine
details
algorithm's
behavior
also
allows
us
compare
two
algorithms
easily
algorithm
2
algorithm
3
according
number
lines
executed
one
twice
fast
ratio
change
function
factors
like
amount
time
needed
allocate
large
array
algorithm
2
may
mean
actual
time
algorithms
closer
careful
analysis
needed
determine
two
use
hand
know
4n
much
better
3f
2
reasonable
value
depend
factor
4
4n
time
bound
7n
12n
larger
larger
ratio
gets
large
quickly
will
faster
replacing
4n
abstraction
lets
us
compare
functions
without
certain
details
4
getting
way
recursive
powering
algorithms
3
4
best
mathematical
trick
matrices
1
1
1
1
0
1
remember
much
linear
algebra
understand
just
formula
multiplying
two
symmetric
2x2
matrices
ad
bd
ce
bd
ce
cf
can
prove
result
induction
let
1
1
1
0
assume
induction
equation
true
multiply
sides
another
power
using
formula
matrix
multiplication
verify
terms
get
formula
defining
fibonacci
numbers
can
use
define
another
iterative
algorithm
using
matrix
multiplication
although
will
write
syntax
starting
get
pseudo
code
since
matrix
multiplication
built
way
written
following
algorithm
initializes
matrix
identity
matrix
zeroth
power
repeatedly
multiplies
form
1
st
power
formula
top
left
corner
holds
value
want
return
algorithm
4
int
fib
int
int
2
2
1
0
0
1
int
1
1
1
1
0
return
0
0
takes
time
much
better
algorithm
1
probably
somewhat
slower
algorithm
2
algorithm
3
big
notation
hides
difference
algorithms
careful
tell
better
like
algorithm
3
uses
1
space
can
compute
quickly
basic
idea
want
compute
3
8
can
multiply
8
3's
together
one
time
3
3
3
3
3
3
3
3
can
repeatedly
square
square
3
2
9
9
2
3
4
81
81
2
3
8
6561
squaring
idea
uses
many
fewer
multiplications
since
one
doubles
exponent
rather
simply
adding
one
care
idea
works
matrices
can
extended
exponents
powers
two
algorithm
5
int
2
2
1
0
0
1
int
fib
int
matpow
1
return
0
0
void
matpow
int
1
matpow
2
odd
1
1
1
0
basically
time
matpow
recursive
tries
compute
nth
power
squaring
2
th
power
however
odd
rounding
2
squaring
power
results
1
st
power
fix
multiplying
one
factor
recursive
algorithm
usual
get
recurrence
relation
defining
time
just
writing
time
spent
call
matpow
1
plus
time
recursive
call
one
recursive
call
argument
2
recurrence
time
1
time
2
turns
solves
log
purposes
class
will
use
logarithms
base
2
round
logarithms
integers
log
basically
number
bits
needed
write
binary
equivalent
way
defining
smallest
value
2
clearly
2
2
2
1
conversely
log
satisfies
recurrence
log
1
log
2
recurrence
defining
time
matpow
basically
except
1
instead
1
solution
recurrence
just
sum
log
copies
1
log
1
billion
log
30
algorithm
better
algorithms
2
3
way
better
algorithm
1
actually
somewhat
cheating
able
use
equal
billion
need
able
write
answer
will
digits
need
able
store
variables
many
digits
manipulating
large
numbers
take
like
steps
per
operation
counting
one
step
per
integer
multiplication
addition
even
used
special
library
dealing
large
numbers
algorithm
4
much
faster
ones
actually
can
get
original
formula
1
618
work
using
similar
repeated
squaring
trick
also
time
log
tell
better
careful
just
use
notation
dealing
integer
matrix
somewhat
simpler
compute
floating
point
square
roots
wins
sort
comparison
analysis
algorithms
ics
161
dept
information
computer
science
uc
irvine
last
update
17
oct
2002
11
24
48
pdt
