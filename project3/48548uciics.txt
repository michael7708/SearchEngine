special trees 

special
trees
introduction
computer
science
ii
ics
22
introduction
lecture
will
continue
study
trees
examining
special
kinds
trees
first
will
discuss
heaps
trees
special
order
structure
property
trees
perfectly
suited
implementing
fast
priority
queue
collection
class
nlog2n
sorting
method
second
will
discuss
represent
process
ary
trees
parent
can
store
number
children
can
use
ary
trees
applications
like
file
directories
third
will
discuss
represent
arithmetic
expressions
structure
trees
including
create
stack
evaluate
expression
trees
using
rules
parentheses
operator
precendence
like
writing
tiny
parser
expressions
covered
course
compiler
writing
finally
time
permitting
will
discuss
digital
trees
special
type
ary
tree
searches
can
performed
exceptionally
fast
1
time
based
size
value
stored
number
values
stored
primary
goal
lecture
understand
special
trees
via
pictures
algorithms
modify
pictures
will
examine
methods
actually
implemented
java
focus
lecture
concepts
important
code
heaps
heap
binary
tree
special
ordering
property
special
structure
property
taken
together
two
properties
allow
efficient
implementation
priority
queues
measured
time
space
will
discuss
min
heaps
priority
queues
use
max
heaps
ordering
property
min
heap
value
stored
node
must
less
equal
values
stored
subtrees
max
heap
must
greater
equal
transitivity
can
easily
check
property
ensuring
node
stores
value
less
values
stored
roots
subtrees
structure
property
depths
deepest
must
filled
deepest
depth
filled
values
must
occur
far
left
possible
will
continue
examining
min
heaps
lecture
everything
learn
easily
generalizes
max
heaps
used
priority
queues
ordering
property
smallest
value
heap
must
appear
root
following
example
illustrates
heap
storing
int
values
notice
ordering
property
structure
property
satisfied
tree
first
observation
make
heaps
useless
binary
searches
ordering
property
help
us
searching
value
know
whether
look
left
right
subtree
ordering
property
dictates
larger
values
subtrees
ordering
structure
property
heaps
makes
easy
quick
add
new
value
remove
smallest
value
will
discuss
operation
two
algorithms
next
following
algorithm
inserts
new
value
heap
ensuring
ordering
structure
properties
invariant
true
insertion
true
insertion
insert
new
value
heap
structure
property
new
node
must
added
tree
either
following
right
node
deepest
unfilled
depth
left
node
increased
depth
tree
already
perfect
value
placed
property
tree
ordering
property
continually
compare
value
value
parent
flip
order
compare
value
value
new
parent
stop
added
value
flipped
root
bigger
parent
following
algorithm
newly
added
value
will
percolate
upwards
finds
correct
resting
spot
iteration
flips
larger
value
parent
smaller
valued
child
ordering
property
continues
hold
following
example
illustrates
adding
value
18
heap
depicted
notice
ordering
property
structure
property
remain
satisfied
performing
insertion
new
value
18
percolating
almost
root
tree
quite
fact
inserted
10
percolated
upwards
way
root
tree
smallest
value
entire
heap
build
heap
values
perform
insertion
operation
times
starting
empty
tree
practice
inserting
values
get
general
idea
algorithm
note
complexity
class
inserting
value
truly
log2n
structure
property
heaps
always
store
prefectly
balanced
trees
height
always
log
size
number
percolations
performed
height
tree
next
will
examine
algorithm
removing
minimum
value
min
heap
ensuring
ordering
structure
properties
invariant
true
removal
true
removal
remove
minimum
values
heap
ordering
property
minimum
value
root
heap
remove
value
root
node
leave
root
node
place
structure
property
node
must
deleted
tree
right
node
deepest
depth
delete
node
first
put
value
root
node
ordering
property
continually
compare
value
values
children
child
smaller
swap
value
smallest
child
repeat
process
stop
values
smaller
children
following
algorithm
last
value
promoted
root
will
percolate
downwards
finds
correct
resting
spot
iteration
replaces
larger
value
parent
smallest
valued
child
ordering
property
continues
hold
following
example
illustrates
removing
minimum
heap
depicted
see
nodes
values
18
27
29
ultimately
moved
notice
ordering
property
structure
property
remain
satisfied
performing
removal
practice
removing
values
get
general
idea
algorithm
note
complexity
class
removing
minimum
value
truly
log2n
structure
property
heaps
always
store
prefectly
balanced
trees
height
always
log
size
number
percolations
performed
height
tree
means
complexity
class
enqueuing
values
dequeuing
values
standard
way
measure
complexity
class
collection
class
log2n
log2n
log2n
complexity
class
much
better
previous
implementations
n2
either
enqueue
dequeue
1
operation
log2n
worse
1
better
seems
balance
things
better
logarithm
function
closer
constant
linear
growth
fact
can
sort
array
log2n
equivalent
enqueuing
values
dequeuing
finally
structure
property
heaps
allows
us
easily
store
contiguous
values
arrays
without
use
explicit
child
parent
references
references
left
right
children
parents
can
calculated
via
indexes
following
store
root
tree
index
1
leave
index
0
unfilled
store
left
child
node
index
index
2
store
right
child
node
index
index
2
1
heap
size
values
stored
1
valued
array
indexes
1
following
example
illustrates
heap
stored
array
note
parent
child
stored
index
stored
index
2
left
child
root
stored
index
2
left
right
children
stored
indices
4
5
respectively
right
child
root
stored
index
3
left
right
children
stored
indices
6
7
respectively
continuing
process
can
observe
every
index
filled
collisions
multiple
values
stored
index
thus
can
unambiguously
store
heap
values
array
size
1
storing
nodes
uniquely
indexes
1
algorithms
require
can
easily
find
location
node
add
insertion
node
remove
deletion
index
1
index
respectively
general
ary
trees
binary
trees
store
references
left
right
subtrees
parent
exactly
0
1
2
children
will
now
explore
interesting
ways
generalize
trees
allow
parent
store
references
number
children
trees
called
ary
trees
can
use
represent
tree
structure
file
system
every
node
either
file
folder
can
include
files
folders
example
ary
tree
representing
directory
tree
folder
names
pink
file
names
white
many
ways
implement
ary
tree
structure
example
one
instance
named
children
stored
reference
collection
class
children
list
important
order
among
children
set
important
order
course
can
use
array
information
using
collection
class
often
makes
things
simpler
public
class
folderfile
public
folderfile
string
name
children
new
hashset
public
string
name
public
set
children
given
representation
recursive
method
prints
names
folders
files
stored
inside
folderfile
supplied
parameter
matter
many
levels
deep
uses
combination
iteration
recursion
reach
every
node
tree
public
static
void
printnames
folderfile
ff
system
println
ff
name
iterator
ff
children
iterator
hasnext
folderfile
achild
folderfile
next
printnames
achild
note
form
preorder
traversal
node
printed
recursive
call
made
children
program
directory
lister
shows
can
explore
directory
structures
java
using
file
class
java's
standard
library
fact
java
uses
arrays
list
files
available
folder
processed
manner
similar
code
surprisingly
can
also
use
standard
binary
tree
store
ary
tree
assign
two
references
different
meanings
basic
idea
behind
ary
trees
stored
binary
trees
node
refers
first
child
next
sibling
thus
regular
binary
trees
still
define
trees
using
two
recursive
references
meanings
trees
processed
different
general
form
defining
ary
tree
nodes
public
class
ntn
public
int
value
public
ntn
firstchild
sibling
public
ntn
int
tn
fc
tn
value
firstchild
sibling
example
represent
directory
tree
use
ntns
following
references
notice
node
refers
downward
left
first
child
rightward
next
sybling
actually
defining
directory
data
will
define
following
three
classes
small
inheritance
hierarchy
directoryentry
superclass
file
folder
supplies
code
variety
methods
including
getfirstchild
always
returns
null
overridden
directory
getsize
always
returns
0
overridden
file
directory
entries
siblings
folders
children
public
class
directoryentry
public
directoryentry
string
name
name
name
next
null
public
directoryentry
getfirstchild
return
null
public
directoryentry
getnextsibling
return
next
public
void
addsibling
directoryentry
de
directoryentry
next
null
next
next
de
public
int
getsize
return
0
private
string
name
private
directoryentry
next
public
class
file
extends
directoryentry
public
file
string
name
int
size
super
name
size
size
public
int
getsize
return
size
private
int
size
public
class
folder
extend
directoryentry
public
folder
string
name
super
name
firstchild
null
public
directoryentry
getfirstchild
return
firstchild
public
void
addchild
directoryentry
de
firstchild
null
firstchild
de
else
firstchild
addsibling
de
private
directoryentry
firstchild
now
suppose
wanted
compute
height
ary
tree
deep
one
go
get
deepest
folder
file
use
following
code
combines
iteration
siblings
recursion
children
public
static
int
height
directoryentry
de
de
null
return
1
else
int
maxchildheight
1
directoryentry
de
getfirstchild
null
getsibling
int
childheight
height
childheight
maxchildheight
maxchildheight
childheight
return
1
maxchildheight
can
write
code
amazingly
elegantly
compactly
using
double
recursion
require
two
methods
first
public
static
int
height
directoryentry
de
return
1
heighthelper
de
firstchild
heighthelper
computes
maximum
height
node
subsequent
siblings
public
static
int
heighthelper
directoryentry
de
de
null
return
1
else
return
math
max
1
heighthelper
de
firstchild
heighthelper
de
getsibling
finally
wanted
compute
total
size
files
directory
like
adding
sizes
nodes
binary
tree
use
following
code
also
two
methods
public
static
int
size
directoryentry
de
de
null
return
0
else
return
de
getsize
sizehelper
de
firstchild
sizehelper
computes
size
node
subsequent
siblings
public
static
int
sizehelper
directoryentry
de
de
null
return
0
else
return
de
getsize
sizehelper
de
firstchild
sizehelper
de
getsibling
expression
trees
can
also
use
binary
trees
model
java
expressions
using
binary
unary
operators
whose
left
subtrees
empty
whose
right
subtrees
contain
expression
apply
unary
operator
trees
operators
internal
nodes
literals
leaf
nodes
following
picture
illustrate
arithmetic
expression
written
infix
form
expression
tree
interesting
observe
reverse
polish
notation
rpn
translation
expression
can
computed
postorder
traversal
tree
printing
value
operator
constant
node
note
parentheses
tree
operator
precedence
including
parentheses
override
precedence
can
alter
structure
tree
even
though
appear
tree
proper
also
note
modeling
expression
tree
can
answer
certain
questions
expression
computing
information
model
computer
single
arithmetic
unit
amount
time
will
take
evaluate
expression
computed
number
internal
nodes
computer
many
arithmetic
units
amount
time
will
take
evaluate
expression
computed
height
tree
operators
depth
bacn
computed
time
multiple
arithmetic
units
can
use
inheritance
model
expressions
easily
classes
definining
expression
trees
abstract
concrete
form
following
inheritance
hierarchy
top
hierarchy
descended
object
generic
class
expressiontree
defined
follows
public
abstract
class
expressiontree
public
abstract
int
evaluate
public
abstract
string
postfix
called
factory
method
constructs
expression
tree
public
static
expressiontree
makeet
string
op
expressiontree
left
expressiontree
right
op
equals
return
new
add
left
right
else
op
equals
return
new
subtract
left
right
else
op
equals
return
new
multiply
left
right
else
op
equals
return
new
divide
left
right
else
op
equals
return
new
power
left
right
else
op
equals
return
new
negate
right
else
throw
new
illegalargumentexception
expressiontree
makeet
illegal
operators
op
main
methods
abstract
compute
value
expression
produce
postfix
rpn
string
representation
expression
can
write
constant
class
direct
conctete
subclass
one
trivially
implementing
postfix
evaluate
methods
public
class
constant
extends
expressiontree
public
constant
int
value
value
value
public
int
evaluate
return
value
public
string
postfix
return
value
private
int
value
add
another
layer
abstraction
defining
simple
operator
subclass
extending
expressiontree
public
abstract
class
operator
extends
expressiontree
public
abstract
string
getopsymbol
add
final
abstract
layer
defining
binaryoperator
class
unaryoperator
class
defined
similarly
notice
abstract
postfix
method
made
concrete
level
hierarchy
getopsymbol
method
still
abstract
will
specified
subclass
uses
postorder
traversal
compute
postfix
form
left
right
subexpressions
followed
current
operator
public
abstract
class
binaryoperator
extends
operator
public
binaryoperator
expressiontree
left
expressiontree
right
left
left
right
right
public
expressiontree
getleft
return
left
public
expressiontree
getright
return
right
public
string
postfix
return
left
postfix
right
postfix
getopsymbol
private
expressiontree
left
right
finally
infrastructure
easy
specify
new
class
represents
operator
multiply
specified
public
class
multiply
extends
binaryoperator
public
multiply
expressiontree
left
expressiontree
right
super
left
right
public
int
evaluate
return
getleft
evaluate
getright
evaluate
public
string
getopsymbol
return
notice
evaluation
uses
postfix
traversal
tree
recursively
evaluates
left
right
subtrees
classes
determines
evaluate
values
performs
arithmetic
operation
specified
node
download
expression
trees
entire
specification
classes
driver
program
uses
stringtokenizer
stack
translate
infix
expressions
using
operator
precedence
parentheses
expression
trees
print
postfix
form
evaluate
expression
tree
augment
program
using
map
store
associations
variables
values
add
variable
class
heirarchy
add
operator
evaluate
expressios
context
variable
map
point
built
interpreter
simple
calculator
digital
trees
aka
tries
will
discuss
class
problem
set
ensure
understand
material
lecture
please
solve
announced
problems
read
lecture
get
stumped
problem
go
back
read
relevant
part
lecture
still
questions
please
get
help
instructor
ta
student
none
yet
