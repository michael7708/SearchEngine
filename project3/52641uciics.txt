recursion linked lists 

recursion
linked
lists
introduction
computer
science
ii
ics
22
introduction
lecture
will
extend
study
recursion
studying
various
recursive
methods
operating
linked
lists
natural
linked
lists
can
defined
recursively
null
reference
empty
linked
list
non
null
reference
object
class
ln
whose
next
instance
variable
refers
linked
list
either
empty
non
empty
linked
list
recursive
methods
operating
linked
lists
often
simpler
write
easier
understand
iterative
counterparts
become
familiar
recursive
methods
often
store
state
use
state
change
operators
next
week
begin
study
trees
will
find
methods
can
written
via
recursion
using
recursion
linked
lists
bridge
gap
recursion
trees
will
first
examine
recursive
accessor
methods
process
linked
lists
will
examine
recursive
mutator
methods
add
remove
values
linked
lists
methods
written
using
simple
pattern
java
programmers
learn
finally
will
discuss
write
recursive
methods
collection
classes
will
use
simple
pattern
requires
writing
one
public
method
calls
private
recursive
helper
method
recursive
accessor
methods
recursive
methods
operating
linked
list
base
case
empty
list
recursive
call
next
instance
variable
refers
smaller
list
one
contains
one
fewer
node
probably
simplest
recursive
method
one
returns
number
nodes
linked
list
length
list
code
shown
public
static
int
length
ln
null
return
0
else
return
1
length
next
note
proof
correctness
base
case
empty
list
method
returns
correct
length
0
recursive
call
applied
strictly
smaller
linked
list
next
containing
one
fewer
node
assuming
length
next
correctly
computes
length
list
following
first
node
returning
value
one
bigger
correctly
computes
length
entire
list
changing
method
ever
slightly
can
compute
sum
values
nodes
linked
list
public
static
int
sum
ln
null
return
0
else
return
value
sum
next
proof
correctness
also
similar
following
two
methods
print
values
list
first
standard
order
second
reverse
order
notice
difference
two
methods
besides
different
names
order
printing
node's
value
recursive
call
public
static
void
print
ln
null
return
else
system
println
value
print
next
method
simple
write
iteratively
linear
linked
lists
now
discuss
method
prints
values
reverse
order
method
seems
impossible
write
linear
linked
lists
printe
node
must
print
node
comes
link
previous
node
linear
linked
lists
public
static
void
reverseprint
ln
null
return
else
reverseprint
next
system
println
value
yet
can
write
method
easily
print
use
recursion
note
proof
correctness
base
case
empty
list
method
prints
reverse
order
correctly
values
recursive
call
applied
strictly
smaller
linked
list
next
containing
one
fewer
node
assuming
reverseprint
next
correctly
prints
reverse
order
values
tha
list
first
node
printing
first
node
afterwards
correctly
prints
values
list
reverse
order
illustrates
recursion
strictly
powerful
iteration
interative
method
can
converted
recursive
one
recursive
methods
like
printreversed
translated
iterative
code
unless
extra
collection
class
used
typically
iteration
stack
equivalent
recursion
example
can
write
reverseprint
iteratively
follows
public
static
void
reverseprint
ln
stack
new
arraystack
ln
null
next
add
isempty
system
println
ln
remove
value
conversion
recursive
iterative
stack
alsways
easy
finally
can
also
simplify
methods
involving
immediate
return
base
case
public
static
void
reverseprint
ln
null
reverseprint
next
system
println
value
although
containing
less
code
implicit
return
void
method
code
match
standard
recursive
form
check
base
case
explicitly
case
can
choose
form
follow
write
code
following
method
performs
linear
search
returns
either
null
reference
node
containing
value
public
static
ln
search
ln
int
value
null
return
null
else
value
value
return
else
return
search
next
value
note
proof
correctness
base
case
empty
list
method
returns
correct
answer
null
nodes
linked
list
containing
value
fact
nodes
recursive
call
applied
strictly
smaller
linked
list
next
containing
one
fewer
node
assuming
search
next
correctly
returns
reference
node
containing
value
list
following
first
node
method
returns
correct
reference
either
returnins
reference
first
node
storesvalue
returns
result
recursive
call
can
also
simplify
method
combining
base
case
case
finding
correct
reference
return
write
follows
public
static
ln
search
ln
int
value
null
value
value
return
else
return
search
next
value
finally
particularly
elegant
recursive
way
copy
linked
list
efficient
iterative
method
studied
required
cache
reference
much
simpler
write
prove
correct
public
static
ln
copy
ln
null
return
null
else
return
new
ln
value
copy
next
note
proof
correctness
base
case
empty
list
method
returns
correct
answer
null
copy
empty
list
node
linked
list
containing
value
recursive
call
applied
strictly
smaller
linked
list
next
containing
one
fewer
node
assuming
copy
next
correctly
returns
reference
copy
linked
list
containing
nodes
first
one
method
correctly
returns
copy
entire
list
returning
reference
copy
first
node
whose
next
reference
copy
nodes
following
first
note
complexity
classes
cases
worst
case
recursive
call
nodes
linked
list
contains
recursive
mutator
methods
recursive
mutator
methods
follow
pattern
return
reference
mutated
linked
list
instead
void
generalization
allows
simple
recursive
implementation
method
approach
takes
bit
getting
used
pattern
used
repeatedly
recursive
processing
tree
mutators
following
method
used
used
return
reference
linked
list
new
node
containing
value
inserted
rear
public
static
ln
insertrear
ln
int
value
null
return
new
ln
value
null
else
next
insertrear
next
value
return
call
method
like
front
insertrear
front
5
note
proof
correctness
base
case
empty
list
method
returns
correct
answer
reference
list
consisting
new
node
containing
value
recursive
call
applied
strictly
smaller
linked
list
next
containing
one
fewer
node
assuming
inserrear
next
value
correctly
returns
reference
linked
list
next
containing
nodes
first
new
node
containing
value
inerted
rear
storing
reference
list
next
returning
correctly
returning
reference
linked
list
new
node
containing
value
inerted
rear
last
part
proof
definitely
complicated
subtle
understood
will
require
thinking
possibly
hand
simulation
code
another
way
write
method
might
consider
code
simpler
one
return
end
returning
reference
either
new
node
node
passed
public
static
ln
insertrear
ln
int
value
null
new
ln
value
null
else
next
insertrear
next
value
return
can
extend
pattern
ever
slightly
insert
value
ordered
list
rely
short
circuit
evaluation
public
static
ln
insertordered
ln
int
value
null
value
value
return
new
ln
value
else
next
insertordered
next
value
return
call
method
front
insertordered
front
5
compare
recursive
method
iterative
one
solves
task
likewise
code
another
way
write
method
using
just
one
return
public
static
ln
insertordered
ln
int
value
null
value
value
new
ln
value
else
next
insertordered
next
value
return
finally
two
methods
removing
values
linked
list
first
removes
just
first
occurrence
value
second
removes
occurrences
public
static
ln
removefirst
ln
int
value
null
return
null
else
value
value
return
next
else
next
removefirst
next
value
return
call
method
front
removefirst
front
5
can
simplify
method
public
static
ln
removefirst
ln
int
value
null
value
value
next
else
next
removefirst
next
value
return
note
null
method
just
returns
null
second
version
identical
first
except
true
test
inner
statement
returns
removeall
next
instead
just
next
thus
version
value
recursively
removed
smaller
linked
list
well
recursive
methods
compared
iterative
ones
small
changes
semantics
operation
often
lead
small
changes
code
public
static
ln
removeall
ln
int
value
null
return
null
else
value
value
return
removeall
next
value
else
next
removeall
next
value
return
call
method
front
removeall
front
5
can
simplify
method
public
static
ln
removeall
ln
int
value
null
value
value
removeall
next
value
else
next
removeall
next
value
return
finally
notice
one
form
inefficiency
recursive
calls
parameter
like
value
must
repeatedly
passed
copied
one
method
call
next
smart
java
compiler
can
recognize
phenomenon
generate
code
equivalent
without
overhead
actually
passing
value
recursive
methods
collections
implementing
collection
classes
recursive
methods
typically
must
write
pair
methods
operation
first
method
public
one
specified
interface
can
written
iteratively
recursively
written
iteratively
simply
calls
second
method
private
static
one
work
example
suppose
implementing
generic
priority
queue
ln
stores
value
object
via
linked
list
using
front
instance
variable
prioritycomparator
instance
variables
implement
add
method
class
following
pair
methods
public
void
add
object
front
add
front
private
static
ln
add
ln
object
null
prioritycomparator
compare
value
0
return
new
ln
value
else
next
add
next
return
sometimes
will
use
name
add
second
method
overloading
public
method
different
private
prototype
helper
method
times
might
use
standard
name
method
discussed
insertordered
will
explore
detail
pattern
paired
methods
discuss
processing
trees
problem
set
ensure
understand
material
lecture
please
solve
announced
problems
read
lecture
get
stumped
problem
go
back
read
relevant
part
lecture
still
questions
please
get
help
instructor
ta
student
examine
method
public
static
boolean
equallength
ln
l1
ln
l2
return
length
l1
length
l2
although
method
trivial
write
takes
long
time
execute
passed
large
linked
list
million
node
list
short
one
5
node
list
computes
length
separately
computing
length
large
list
takes
much
time
computing
length
small
list
rewrite
method
directly
using
recursion
traverses
much
list
necessary
compute
result
tries
reach
6th
node
list
fails
smaller
list
knows
answer
hint
deal
following
four
cases
l1
l2
empty
l1
empty
l2
empty
l1
empty
l2
empty
finally
l1
l2
empty
three
four
cases
answer
can
returned
immediately
requires
recursion
write
public
static
method
named
merge
takes
two
parameters
reference
sorted
increasing
order
list
method
returns
reference
new
sorted
list
copies
values
two
parameter
lists
remain
unchanged
hint
use
recursive
structures
limilar
equallength
method
described
familiarize
methods
covered
lecture
know
prove
hand
simulate
